[["index.html", "ENGE 5714 Course Notes 2021 Preamble", " ENGE 5714 Course Notes 2021 Dr. Katz 2021-03-14 Preamble This book will be a living document of notes for ENGE 5714 - Quantitative Research Methods in Engineering Education. I will try to keep it updated and post alerts about updates in our course Slack workspace. "],["week-1-introductions.html", "Chapter1 Week 1: Introductions", " Chapter1 Week 1: Introductions In week one we just reviewed some of the materials from the fall semester. By the end we discussed R and RStudio, but this first week was primarily about getting to know each other and the outline of the course. "],["week-2-intro-stats-data-distributions-intro-r-rstudio.html", "Chapter2 Week 2: Intro stats, Data &amp; Distributions, Intro R &amp; RStudio 2.1 First steps in R 2.2 Getting your R environment set up 2.3 Reading in data 2.4 Exploring the data 2.5 Plotting data 2.6 Some brief stats", " Chapter2 Week 2: Intro stats, Data &amp; Distributions, Intro R &amp; RStudio This week, we discuss some very basic ideas related to statistics, data, and working in R. 2.1 First steps in R We can create a new variable by assigning it a value with the &lt;- operator. Lets create a vector of numbers 1 to 10 with the seq() function and then a separate vector that takes each of the x values, multiplies it by 2, and adds 3. x &lt;- seq(1:10) y &lt;- 2* x + 3 Just to make sure everything worked as expected, we can then just type x and y and R will print their values. We could also look in the environment window to see whether those variables (and their expected values) were actually created. x ## [1] 1 2 3 4 5 6 7 8 9 10 y ## [1] 5 7 9 11 13 15 17 19 21 23 So far, so good. If we want to quickly visualize this, we could create a simple scatter plot with the plot() command (note: we will come back to plotting data much more in week 3). plot(x, y) 2.2 Getting your R environment set up One of the first things you will have in any script or .rmd file is a section to load all the libraries that you use in that script. You can install a library by using the install.packages() function, for example: install.packages(\"tidyverse\"), install.packages(\"janitor\"), and install.packages(\"psych\") with this installed, you can then load the package using the library() function library(tidyverse) ## -- Attaching packages --- tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.3 v dplyr 1.0.0 ## v tidyr 1.1.0 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts ------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(janitor) ## Warning: package &#39;janitor&#39; was built under R version 4.0.3 ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test library(psych) ## ## Attaching package: &#39;psych&#39; ## The following objects are masked from &#39;package:ggplot2&#39;: ## ## %+%, alpha 2.3 Reading in data A good first step when working in R is to check which directory you are working in with the getwd() function. You should get a directory in response. getwd() ## [1] &quot;C:/Users/akatz4/Desktop/test_course_note&quot; You can also check which files are in that directory with list.files(). list.files() ## [1] &quot;_book&quot; ## [2] &quot;_bookdown.yml&quot; ## [3] &quot;_bookdown_files&quot; ## [4] &quot;_output.yml&quot; ## [5] &quot;01-Week_01.Rmd&quot; ## [6] &quot;02-Week_02.Rmd&quot; ## [7] &quot;03-Week_03.Rmd&quot; ## [8] &quot;04-Week_04.Rmd&quot; ## [9] &quot;05-Week_05.Rmd&quot; ## [10] &quot;06-Week_06.Rmd&quot; ## [11] &quot;07-Week_07.Rmd&quot; ## [12] &quot;08-Week_08.Rmd&quot; ## [13] &quot;book.bib&quot; ## [14] &quot;ChildAggression.dat&quot; ## [15] &quot;docs&quot; ## [16] &quot;ENGE_5714_2021_pre_survey.csv&quot; ## [17] &quot;Free Reduced Lunch by Schools and Grade Structures 2008-2017_final.csv&quot; ## [18] &quot;index.Rmd&quot; ## [19] &quot;packages.bib&quot; ## [20] &quot;preamble.tex&quot; ## [21] &quot;README.md&quot; ## [22] &quot;RExam.dat&quot; ## [23] &quot;seniorsurvey.csv&quot; ## [24] &quot;student_happiness.csv&quot; ## [25] &quot;style.css&quot; ## [26] &quot;survey_student_info.csv&quot; ## [27] &quot;test_course_note.Rproj&quot; ## [28] &quot;test_course_notes.Rmd&quot; ## [29] &quot;test_course_notes_files&quot; If you notice that the file you are looking for is not there, then you can use setwd() to change your working directory setwd(\"./Week 2/\") After that, make sure you have switched to the correct working directory getwd() and then list.files(). Assuming you have directed yourself to the correct place, you can now read in the file(s) that you want to be working with. There are a lot of ways to do this. Since we will be spending a lot of time in class working with .csv files, we will focus on using the read_csv() function from the readr package (part of the tidyverse collection of packages). This function will read in the .csv file and store the data as a tibble (a tidyverse version of a data frame, which we can think of as a collection of observations stored in rows with values for variables for each observation stored in columns). prior_survey &lt;- read_csv(&quot;ENGE_5714_2021_pre_survey.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## student_id = col_double() ## ) ## See spec(...) for full column specifications. 2.4 Exploring the data Now that we have loaded in the data, lets take a look at the csv. If we just run a line with the name of the tibble - i.e., prior_survey then we should receive a printout that shows the first several rows of that tibble and a listing of all the columns, along with the data types (i.e., double for numeric values, character for strings, etc) of each column. prior_survey ## # A tibble: 24 x 49 ## student_id `I have taken a~ `I am intereste~ `I know what a ~ ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Somewhat disagr~ Somewhat agree Strongly disagr~ ## 2 2 Strongly disagr~ Neither agree n~ Somewhat agree ## 3 3 Strongly disagr~ Somewhat agree Somewhat agree ## 4 4 Somewhat disagr~ Strongly agree Strongly disagr~ ## 5 5 Somewhat agree Strongly agree Somewhat agree ## 6 6 Somewhat disagr~ Somewhat agree Somewhat disagr~ ## 7 7 Strongly disagr~ Somewhat agree Strongly disagr~ ## 8 8 Somewhat agree Somewhat agree Somewhat agree ## 9 9 Strongly disagr~ Strongly agree Somewhat agree ## 10 10 Neither agree n~ Strongly agree Somewhat agree ## # ... with 14 more rows, and 45 more variables: `I know what a type II error ## # is` &lt;chr&gt;, `I know what a (statistical) confidence level is` &lt;chr&gt;, `I know ## # what a p value is` &lt;chr&gt;, `I know what p-hacking means` &lt;chr&gt;, `I know what ## # statistical power means` &lt;chr&gt;, `I have heard of frequentist statistics ## # before` &lt;chr&gt;, `I have heard of Bayesian statistics before` &lt;chr&gt;, `I have ## # heard the term &quot;parametric statistics&quot; before` &lt;chr&gt;, `I have heard the ## # term &quot;non-parametric statistics&quot; before` &lt;chr&gt;, `I know what a histogram ## # is.` &lt;chr&gt;, `I know what a probability distribution is.` &lt;chr&gt;, `I know ## # what a random variable is.` &lt;chr&gt;, `I know what a probability distribution ## # function is.` &lt;chr&gt;, `I know what a cumulative distribution function ## # is.` &lt;chr&gt;, `I know what the expectation of a random variable is.` &lt;chr&gt;, ## # `I know how to calculate the variance of a random variable.` &lt;chr&gt;, `I know ## # what a z score is.` &lt;chr&gt;, `I know how to calculate the correlation between ## # two variables.` &lt;chr&gt;, `I know how to interpret the correlation coefficient ## # between two variables` &lt;chr&gt;, `I have heard of linear regression` &lt;chr&gt;, `I ## # know how to run a linear regression (in some software...or by hand, if I&#39;m ## # feeling wild).` &lt;chr&gt;, `I know how to interpret a linear ## # regression.` &lt;chr&gt;, `I have heard of multiple regression` &lt;chr&gt;, `I know ## # how to perform a multiple regression` &lt;chr&gt;, `I know how to interpret a ## # multiple regression` &lt;chr&gt;, `I have heard of logistic regression.` &lt;chr&gt;, ## # `I understand when to use a logistic regression.` &lt;chr&gt;, `I know how to ## # interpret the results of a logistic regression` &lt;chr&gt;, `I have heard of ## # t-tests` &lt;chr&gt;, `I have performed a t-test before` &lt;chr&gt;, `I know how to ## # interpret the results of a t-test` &lt;chr&gt;, `I have heard of Analysis of ## # Variance.` &lt;chr&gt;, `I understand when to run an Analysis of Variance ## # (ANOVA)` &lt;chr&gt;, `I know how to interpret the results from an ANOVA` &lt;chr&gt;, ## # `I have heard of a chi-square test` &lt;chr&gt;, `I have used a chi-square test ## # before` &lt;chr&gt;, `I know how to interpret the results of a chi-square ## # test` &lt;chr&gt;, `I have heard of cluster analysis before` &lt;chr&gt;, `I have used ## # cluster analysis before` &lt;chr&gt;, `I know how to interpret the results of a ## # cluster analysis` &lt;chr&gt;, `I have heard of factor analysis (either ## # exploratory or confirmatory)` &lt;chr&gt;, `I have used factor analysis (either ## # exploratory or confirmatory)` &lt;chr&gt;, `I know how to interpret the results ## # of a factor analysis (either exploratory or confirmatory)` &lt;chr&gt;, `I ## # already have R and Rstudio downloaded to my computer.` &lt;chr&gt;, `I have used ## # R before` &lt;chr&gt; When we do this, we see that there are a bunch of columns that have spaces in their names. This is okay (in the sense that R can handle this), but it can be a little frustrating to work with. Lets try cleaning the column names with clean_names() from the janitor package. This function will replace the spaces in the column names with underscores and make everything lower case. So, a column name like I have take a statistics course before will be changed to i_have_taken_a_statistics_course_before. prior_survey &lt;- prior_survey %&gt;% clean_names() # from janitor package Look at the data in prior_survey again and see if anything looks different (hint: it should). prior_survey ## # A tibble: 24 x 49 ## student_id i_have_taken_a_~ i_am_interested~ i_know_what_a_t~ ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Somewhat disagr~ Somewhat agree Strongly disagr~ ## 2 2 Strongly disagr~ Neither agree n~ Somewhat agree ## 3 3 Strongly disagr~ Somewhat agree Somewhat agree ## 4 4 Somewhat disagr~ Strongly agree Strongly disagr~ ## 5 5 Somewhat agree Strongly agree Somewhat agree ## 6 6 Somewhat disagr~ Somewhat agree Somewhat disagr~ ## 7 7 Strongly disagr~ Somewhat agree Strongly disagr~ ## 8 8 Somewhat agree Somewhat agree Somewhat agree ## 9 9 Strongly disagr~ Strongly agree Somewhat agree ## 10 10 Neither agree n~ Strongly agree Somewhat agree ## # ... with 14 more rows, and 45 more variables: ## # i_know_what_a_type_ii_error_is &lt;chr&gt;, ## # i_know_what_a_statistical_confidence_level_is &lt;chr&gt;, ## # i_know_what_a_p_value_is &lt;chr&gt;, i_know_what_p_hacking_means &lt;chr&gt;, ## # i_know_what_statistical_power_means &lt;chr&gt;, ## # i_have_heard_of_frequentist_statistics_before &lt;chr&gt;, ## # i_have_heard_of_bayesian_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_parametric_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_non_parametric_statistics_before &lt;chr&gt;, ## # i_know_what_a_histogram_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_is &lt;chr&gt;, ## # i_know_what_a_random_variable_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_function_is &lt;chr&gt;, ## # i_know_what_a_cumulative_distribution_function_is &lt;chr&gt;, ## # i_know_what_the_expectation_of_a_random_variable_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_variance_of_a_random_variable &lt;chr&gt;, ## # i_know_what_a_z_score_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_correlation_between_two_variables &lt;chr&gt;, ## # i_know_how_to_interpret_the_correlation_coefficient_between_two_variables &lt;chr&gt;, ## # i_have_heard_of_linear_regression &lt;chr&gt;, ## # i_know_how_to_run_a_linear_regression_in_some_software_or_by_hand_if_im_feeling_wild &lt;chr&gt;, ## # i_know_how_to_interpret_a_linear_regression &lt;chr&gt;, ## # i_have_heard_of_multiple_regression &lt;chr&gt;, ## # i_know_how_to_perform_a_multiple_regression &lt;chr&gt;, ## # i_know_how_to_interpret_a_multiple_regression &lt;chr&gt;, ## # i_have_heard_of_logistic_regression &lt;chr&gt;, ## # i_understand_when_to_use_a_logistic_regression &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_logistic_regression &lt;chr&gt;, ## # i_have_heard_of_t_tests &lt;chr&gt;, i_have_performed_a_t_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_t_test &lt;chr&gt;, ## # i_have_heard_of_analysis_of_variance &lt;chr&gt;, ## # i_understand_when_to_run_an_analysis_of_variance_anova &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_from_an_anova &lt;chr&gt;, ## # i_have_heard_of_a_chi_square_test &lt;chr&gt;, ## # i_have_used_a_chi_square_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_chi_square_test &lt;chr&gt;, ## # i_have_heard_of_cluster_analysis_before &lt;chr&gt;, ## # i_have_used_cluster_analysis_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_cluster_analysis &lt;chr&gt;, ## # i_have_heard_of_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_have_used_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_already_have_r_and_rstudio_downloaded_to_my_computer &lt;chr&gt;, ## # i_have_used_r_before &lt;chr&gt; One other function that will we see more in the future is the table() function, which will create a table with the counts of the values for a variable. For example, if we wanted to quickly know how students answered the I have taken a quantitative research methods course before question, we can run the following: table(prior_survey$i_have_taken_a_quantitative_research_methods_course_before) ## ## Neither agree nor disagree Somewhat agree ## 2 5 ## Somewhat disagree Strongly agree ## 5 2 ## Strongly disagree ## 10 2.5 Plotting data We will discuss plotting more next week, but here is a brief preview of whats to come There are multiple ways to plot data. Focusing on using ggplot, here are two. The first way passes the prior_survey dataframe explicitly to ggplot ggplot(data = prior_survey, mapping = aes(x = i_know_what_a_type_i_error_is)) + geom_bar() + coord_flip() The second way does this implicitly, using the pipe operator. Note that the results should be the same. prior_survey %&gt;% ggplot(mapping = aes(x = i_know_what_a_type_i_error_is)) + geom_bar() + coord_flip() If we wanted to get extra fancy, we could first convert the data from a wide format to a long format and then start plotting all the items together. Converting to long format would produce something like this: prior_survey %&gt;% gather(key = &quot;survey_item&quot;, value = &quot;survey_response&quot;) ## # A tibble: 1,176 x 2 ## survey_item survey_response ## &lt;chr&gt; &lt;chr&gt; ## 1 student_id 1 ## 2 student_id 2 ## 3 student_id 3 ## 4 student_id 4 ## 5 student_id 5 ## 6 student_id 6 ## 7 student_id 7 ## 8 student_id 8 ## 9 student_id 9 ## 10 student_id 10 ## # ... with 1,166 more rows Then we can combine that with the group_by() and summarize() functions and plot the results. prior_survey %&gt;% gather(key = &quot;survey_item&quot;, value = &quot;survey_response&quot;) %&gt;% group_by(survey_item, survey_response) %&gt;% summarize(n = n()) %&gt;% ggplot(mapping = aes(x = survey_response, y = survey_item, fill = n)) + geom_tile() ## `summarise()` regrouping output by &#39;survey_item&#39; (override with `.groups` argument) This plot is okay for giving a general sense of what is going on in these plots but there are a bunch of other ways to go about doing this. First, maybe we want to rename the response categories to a numerical scale. We can accomplish this with a mutate() and case_when(). prior_survey &lt;- prior_survey %&gt;% gather(key = &quot;survey_item&quot;, value = &quot;survey_response&quot;) %&gt;% mutate(survey_response_num = case_when(survey_response == &quot;Strongly disagree&quot; ~ 0, survey_response == &quot;Somewhat disagree&quot; ~ 1, survey_response == &quot;Neither agree nor disagree&quot; ~ 2, survey_response == &quot;Somewhat agree&quot; ~ 3, survey_response == &quot;Strongly agree&quot; ~ 4, )) Then we plot the same data but with the numerical scale along the x-axis. prior_survey %&gt;% group_by(survey_item, survey_response_num) %&gt;% summarize(n = n()) %&gt;% ggplot(mapping = aes(x = survey_response_num, y = survey_item, fill = n)) + geom_tile() ## `summarise()` regrouping output by &#39;survey_item&#39; (override with `.groups` argument) ## Warning: Removed 3 rows containing missing values (geom_tile). 2.6 Some brief stats In this weeks reading, there was also discussion about standard errors and the central limit theorem. These are fairly important theoretical concepts to grasp. To some extent they deal with the scenario where you go out and repeatedly sample from a population and calculate a statistic from each of those samples. The distributions of that statistic is what we will call the sampling distribution (as opposed to the sample distribution, which would more accurately describe the distribution of the data that we get in any one sample that we draw from the population). 2.6.1 Central Limit Theorem and Standard Error Demo - pop_students &lt;- 10000 zoom_min_pop &lt;- rnorm(n = pop_students, mean = 600, sd = 100) hist(zoom_min_pop) zoom_min_sample &lt;- sample(x = zoom_min_pop, size = 200, replace = FALSE) hist(zoom_min_sample) mean(zoom_min_sample) ## [1] 595.3331 sd(zoom_min_sample) ## [1] 102.2323 As a brief aside, lets review the idea of a loop num_reps &lt;- 100 data_vec &lt;- rep(NA, num_reps) # this creates an empty vector of size num_reps with NA in each entry # this loops through the vector starting at position 1 and ending at the final position (num_reps). For demonstration purposes, we replacing the NA in each entry with the number of that entry (i.e., the NA in the 20th entry is replaced with the number 20) for (i in 1:num_reps){ data_vec[i] &lt;- i } Okay, so thats how we create an empty vector and how we loop through its different entries. For this demo, we will also need to remenber how to generate random numbers from a norm distribution with a specified mean and standard deviation. rnorm(n = 10, mean = 5, sd = 2) # n is the number of random numbers we draw from this normal distribution ## [1] 6.569018 7.959722 7.306136 2.840594 8.440812 7.714271 1.296482 6.181196 ## [9] 6.803690 3.619418 Okay, so thats not bad. Now, that command will produce a vector with 10 random numbers. We can calculate the mean and standard deviation of those 10 numbers (which should be close to the values that we specified in rnorm() with the mean() and sd() functions. mean(rnorm(n = 10, mean = 5, sd = 2)) ## [1] 6.124485 sd(rnorm(n = 10, mean = 5, sd = 2)) ## [1] 1.82359 Next, lets act as if we are drawing a certain sample of size samp_size of data points for num_reps number of times. Keep in mind that, in practice, when we are collecting data ourselves in our own research, num_reps will almost always be 1. We are just demonstrating the underlying assumptions for how we can calculate some of the statistics that we use. num_reps &lt;- 1000 # specify how many times to take a sample samp_size &lt;- 200 # specify the size of each sample data_vec &lt;- rep(NA, num_reps) # create an empty vector of size num_reps with NA in each entry. for (i in 1:num_reps){ data_vec[i] &lt;- mean(rnorm(n = samp_size, mean = 600, sd = 100)) # store the mean of each of the num_rep samples } With this, we have a vector data_vec of size num_reps with the mean of each of our samples that we drew. This vector contains our sampling distribution of our sample means. NOTE: The standard deviation of this sampling mean is what we are calling our standard error. We can plot a histogram of this sampling distribution and calculate the standard deviation of the sampling mean. hist(data_vec) sd(data_vec) ## [1] 7.144478 On your own, try copying this code and changing the num_reps and sample_size variables to larger and smaller values. Focus on how the x-axis values in your histogram change when you change the num_reps and samp_size variables. Hint: CLT will explain the normal distribution of the sampling mean (the shape you see in the histogram) while the Weak Law of Large Numbers will explain the concentration around the true mean as samp_size increases (i.e., when we draw a larger sample size from the population, our sample mean gets closer to the population mean). ## Quick note on the rep() function: notice what happens when you specify &quot;each&quot; vs &quot;times&quot;. rep(c(1, 2), times = 5) ## [1] 1 2 1 2 1 2 1 2 1 2 rep(c(1, 2), each = 5) ## [1] 1 1 1 1 1 2 2 2 2 2 "],["week-3-data-cleaning-organizing-describing-and-communicating.html", "Chapter3 Week 3: Data Cleaning, Organizing, Describing, and Communicating 3.1 Visualizing your data 3.2 Joining two datasets 3.3 Discrete Predictor, Continuous Outcome 3.4 Continuous predictor and continuous outcome 3.5 Mutating Variables 3.6 Filtering and Selecting 3.7 Grouping and Summarizing", " Chapter3 Week 3: Data Cleaning, Organizing, Describing, and Communicating This week we focus on different steps you will often take when you first start working with your data. These tend to fall under the umbrella of data processing and often need to happen before you can start doing any kind of analysis. 3.1 Visualizing your data Once your data have been clearned, you are ready to start visualizing what you are working with. There is a huge range of what you can do with these plots. Thats great! On the other hand, it can quickly start to feel overwhelming. To help get this under control and make it more manageable, it is convenient to think about the types of data that you have. In particular, are your variables nominal, ordinal, interval, or ratio variables? 3.1.1 One continuous variable (either predictor or outcome variable) When you have one continuous variable, a standard option is to plot a histogram. These are plots that show the frequency of each of the values that the variable takes. Oftentimes it is helpful to create bins of values so that any number that falls in the 0-4 range counts in one bin, numbers from 5-9 are in a second bin, and so on. For this example, we will start by generating some data using rnorm(), which generates a random number (or in our case, num numbers) from a normal distribution with mean mu and standard deviation stdev. num &lt;- 50 mu &lt;- 5 stdev &lt;- 2 x &lt;- rnorm(n = num, mean = mu, sd = stdev) With these data generated, we can then quickly plot the histogram with hist(). This will use base R graphics. hist(x) You can also do this using ggplot rather than base R graphics. x_df &lt;- tibble(x_col = x) ggplot(data = x_df, mapping = aes(x = x_col)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The histogram is a very standard plot, and you should consider it a go-to option in your toolkit. Alternatively, you can use geom_density() instead of geom_histogram() to get a smooth graph rather than one with discrete bins. We will use the same data that we generated before. We will write this two ways to demnostrate how the pipe %&gt;% operator works. First way: ggplot(data = x_df, mapping = aes(x = x_col)) + geom_density() Second way: x_df %&gt;% ggplot(mapping = aes(x = x_col)) + geom_density() Just for fun, look at what happens to the the plot if you increase the sample size First, we will generate the data with a sample size of 5,000 rather than 50. num &lt;- 5000 mu &lt;- 5 stdev &lt;- 2 x &lt;- rnorm(n = num, mean = mu, sd = stdev) x_df &lt;- tibble(x_col = x) Then we will plot the histogram x_df %&gt;% ggplot(aes(x = x_col)) + geom_histogram() + labs(x = &quot;x value&quot;, y = &quot;Count&quot;, title = &quot;Histogram of normal distribution with n = 5000, mu = 5, sd = 2&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. And, finally, we can make the density plot instead of the histogram, if thats our jam. ggplot(data = x_df, mapping = aes(x = x_col)) + geom_density() 3.1.2 One Discrete Variable (either predictor or outcome) What if instead of a continuous (i.e., interval or ratio) variable we have a discrete variable such as a nominal (e.g., major, university) or ordinal (e.g., Likert scale item, level of education) variable? For that we can use something like geom_bar() or geom_col() to plot the counts of observations within each of those categories. To demonstrate this, we first need some data to work with. We will use the pre-semester, prior knowledge survey that everyone took. I have combined this years results with last years results in order to increase the sample size. After reading in the data, I will also use the clean_names() function from the janitor package. ## load in the data survey_df &lt;- read_csv(&quot;ENGE_5714_2021_pre_survey.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## student_id = col_double() ## ) ## See spec(...) for full column specifications. survey_df &lt;- survey_df %&gt;% clean_names() Next, we can go ahead and make a bar plot with the following code: survey_df %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() Notice that the ordering is not quite what we would want. It is alphabetical. Lets try to fix this. Here is one way: we first specify the levels of that variable (i.e., the different values that it could take) and store that in the variable q_levels. Then, we pass that to the factor() function, which will tell R that we want whichever variable is passed to factor() two things. First, it will say that we want to make that variable a factor variable with levels = .... Second, we set ordered = TRUE to tell R that there is a specific ordering to that variable. This way, whenever there is something like a plot that we make, the ordering will persist in the labeling and R will not show the labels in alphabetical order. Here is an example of that in action: q_levels &lt;- c(&quot;Strongly disagree&quot;, &quot;Somewhat disagree&quot;, &quot;Neither agree nor disagree&quot;, &quot;Somewhat agree&quot;, &quot;Strongly agree&quot;) survey_df$i_have_taken_a_quantitative_research_methods_course_before &lt;- factor(survey_df$i_have_taken_a_quantitative_research_methods_course_before, levels = q_levels, ordered = TRUE) Now try plotting these data. We will also add in a coord_flip() to plot the categories along the y-axis. This is a common move to avoid text from the different levels overlapping with each other. Finally, we will also change the x, y, and title labels with labs(). survey_df %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() + coord_flip() + labs(x = &quot;I have taken a quantitative research methods course before&quot;, y = &quot;Count&quot;, title = &quot;Reordered Example&quot;) 3.2 Joining two datasets Lets imagine that we have a separate dataset that has information about the students who completed the pre-course prior knowledge survey. First, we will load in that dataset survey_info_df &lt;- read_csv(&quot;survey_student_info.csv&quot;) ## Parsed with column specification: ## cols( ## student_id = col_double(), ## standing = col_character(), ## college = col_character(), ## required = col_character() ## ) Next, lets join the two datasets based on the student id column, which is in each of the two dataframes. survey_df &lt;- survey_df %&gt;% inner_join(survey_info_df, by = &quot;student_id&quot;) Now we should have both datasets joined into one and saved as survey_df. With this, we can make some nicer plots and do something like use facet_grid() to look at students who are masters and doctoral students, for example. survey_df %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() + facet_grid(standing ~.) + labs(x = &quot;I have taken a quantitative research methods course before&quot;, y = &quot;Count&quot;, title = &quot;Reordered Example&quot;) The x axis looks a little crowded. What if we try coord_flip()? survey_df %&gt;% filter(standing == &quot;doctoral&quot;) %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() + coord_flip() + facet_grid(standing ~.) + labs(x = &quot;I have taken a quantitative research methods course before&quot;, y = &quot;Count&quot;, title = &quot;Reordered Example&quot;) That looks much better. A quick note on filters If you want to look at only a subset of your data, you will want to use the filter() function. The general idea is that you can look at observations (rows) that match a certain criteria. For example, you may want to only look at students from a certain region or year or major. In our case, with the prior knowledge survey, lets say we only want to look at student who have to take the course (i.e., there is a yes for them for the required variable). We can do that with the first line. The second line just stores the result as a new dataframe called filtered_df. survey_df %&gt;% filter(required == &quot;yes&quot;) ## # A tibble: 12 x 52 ## student_id i_have_taken_a_~ i_am_interested~ i_know_what_a_t~ ## &lt;dbl&gt; &lt;ord&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Somewhat disagr~ Somewhat agree Strongly disagr~ ## 2 2 Strongly disagr~ Neither agree n~ Somewhat agree ## 3 4 Somewhat disagr~ Strongly agree Strongly disagr~ ## 4 8 Somewhat agree Somewhat agree Somewhat agree ## 5 9 Strongly disagr~ Strongly agree Somewhat agree ## 6 11 Strongly disagr~ Strongly agree Strongly disagr~ ## 7 16 Strongly agree Strongly agree Somewhat agree ## 8 17 Strongly disagr~ Strongly agree Strongly disagr~ ## 9 18 Somewhat disagr~ Somewhat agree Somewhat disagr~ ## 10 20 Strongly disagr~ Neither agree n~ Neither agree n~ ## 11 22 Strongly disagr~ Strongly agree Strongly disagr~ ## 12 23 Somewhat agree Strongly agree Somewhat agree ## # ... with 48 more variables: i_know_what_a_type_ii_error_is &lt;chr&gt;, ## # i_know_what_a_statistical_confidence_level_is &lt;chr&gt;, ## # i_know_what_a_p_value_is &lt;chr&gt;, i_know_what_p_hacking_means &lt;chr&gt;, ## # i_know_what_statistical_power_means &lt;chr&gt;, ## # i_have_heard_of_frequentist_statistics_before &lt;chr&gt;, ## # i_have_heard_of_bayesian_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_parametric_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_non_parametric_statistics_before &lt;chr&gt;, ## # i_know_what_a_histogram_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_is &lt;chr&gt;, ## # i_know_what_a_random_variable_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_function_is &lt;chr&gt;, ## # i_know_what_a_cumulative_distribution_function_is &lt;chr&gt;, ## # i_know_what_the_expectation_of_a_random_variable_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_variance_of_a_random_variable &lt;chr&gt;, ## # i_know_what_a_z_score_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_correlation_between_two_variables &lt;chr&gt;, ## # i_know_how_to_interpret_the_correlation_coefficient_between_two_variables &lt;chr&gt;, ## # i_have_heard_of_linear_regression &lt;chr&gt;, ## # i_know_how_to_run_a_linear_regression_in_some_software_or_by_hand_if_im_feeling_wild &lt;chr&gt;, ## # i_know_how_to_interpret_a_linear_regression &lt;chr&gt;, ## # i_have_heard_of_multiple_regression &lt;chr&gt;, ## # i_know_how_to_perform_a_multiple_regression &lt;chr&gt;, ## # i_know_how_to_interpret_a_multiple_regression &lt;chr&gt;, ## # i_have_heard_of_logistic_regression &lt;chr&gt;, ## # i_understand_when_to_use_a_logistic_regression &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_logistic_regression &lt;chr&gt;, ## # i_have_heard_of_t_tests &lt;chr&gt;, i_have_performed_a_t_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_t_test &lt;chr&gt;, ## # i_have_heard_of_analysis_of_variance &lt;chr&gt;, ## # i_understand_when_to_run_an_analysis_of_variance_anova &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_from_an_anova &lt;chr&gt;, ## # i_have_heard_of_a_chi_square_test &lt;chr&gt;, ## # i_have_used_a_chi_square_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_chi_square_test &lt;chr&gt;, ## # i_have_heard_of_cluster_analysis_before &lt;chr&gt;, ## # i_have_used_cluster_analysis_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_cluster_analysis &lt;chr&gt;, ## # i_have_heard_of_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_have_used_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_already_have_r_and_rstudio_downloaded_to_my_computer &lt;chr&gt;, ## # i_have_used_r_before &lt;chr&gt;, standing &lt;chr&gt;, college &lt;chr&gt;, required &lt;chr&gt; filtered_df &lt;- survey_df %&gt;% filter(required == &quot;yes&quot;) A little more about plotting We are going to shift gears again and look at a few different kinds of plots. The main thing to remember here is that you want to think about whether the variables you have are nominal, ordinal, or continuous (that includes interval and ratio). 3.3 Discrete Predictor, Continuous Outcome So far we have looked at plots for one variable, but of course we want to have ways to plot multiple variables simultaneously. We will start with the scneario where where we want to plot a continuous variable against a discrete variable. This can arise when you want to plot something like an assessment score and you think it may differ across groups in some way (maybe you intentionally introduced a difference by exposing the two groups to different interventions, for example). In these scenarios, a boxplot is a very standard way to go. To demonstrate this, we will simulate a situation in which we want to look at differences on an assessment. We are specificially interested in differences between chemistry and chemical engineering students. Lets go ahead and create the data by creating two groups of 20 students each. The chemical engineering students will have scores generated from a normal distribution with \\(\\mu = 85\\) and \\(\\sigma = 4\\) (i.e., a mean of 85 and a standard deviation of 4). We will say the chemistry students have scores from a normal distribution with \\(\\mu = 78\\) anad \\(\\sigma = 6\\). This about what these distributions might look like in your head. group_size &lt;- 20 chem_e_scores &lt;- rnorm(n = group_size, mean = 85, sd = 4) chem_scores &lt;- rnorm(n = group_size, mean = 78, sd = 6) data_df &lt;- tibble( discipline = rep(c(&quot;ChemE&quot;, &quot;Chemistry&quot;), each = group_size), score = c(chem_e_scores, chem_scores) ) With these data, we can then create a boxplot using geom_boxplot() data_df %&gt;% ggplot(aes(x = discipline, y = score)) + geom_boxplot() You can make a few modifications to possibly make this plot easier to read. The first is to put the discrete category on the y axis instead of the x axis. The second is to use geom_jitter() in addition to geom_boxplot() to show the individual points in each group. data_df %&gt;% ggplot(aes(y = score, x = discipline)) + geom_boxplot() + geom_jitter() 3.4 Continuous predictor and continuous outcome First, lets re-do a lot of the steps in this weeks script for reading in data and transforming it a little mydata &lt;- read_csv(&quot;Free Reduced Lunch by Schools and Grade Structures 2008-2017_final.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## div_num = col_double() ## ) ## See spec(...) for full column specifications. Check the structure of the data (this output is a bit long). str(mydata) ## tibble [2,101 x 137] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ sch_id : chr [1:2101] &quot;001-0070&quot; &quot;001-0080&quot; &quot;001-0530&quot; &quot;001-0540&quot; ... ## $ div_num : num [1:2101] 1 1 1 1 1 1 1 1 1 1 ... ## $ div_name : chr [1:2101] &quot;Accomack County&quot; &quot;Accomack County&quot; &quot;Accomack County&quot; &quot;Accomack County&quot; ... ## $ school_num : chr [1:2101] &quot;0070&lt;U+00A0&gt;&quot; &quot;0080&lt;U+00A0&gt;&quot; &quot;0530&lt;U+00A0&gt;&quot; &quot;0540&lt;U+00A0&gt;&quot; ... ## $ school_name : chr [1:2101] &quot;NANDUA HIGH&quot; &quot;CHINCOTEAGUE ELEM&quot; &quot;TANGIER COMBINED&quot; &quot;ARCADIA HIGH&quot; ... ## $ school_name2 : chr [1:2101] NA NA NA NA ... ## $ type0809 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2008 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2008 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2008 : chr [1:2101] &quot;731&quot; &quot;263&quot; &quot;80&quot; &quot;638&quot; ... ## $ total_2008 : chr [1:2101] &quot;731&quot; &quot;263&quot; &quot;80&quot; &quot;638&quot; ... ## $ snp_0809 : chr [1:2101] &quot;659&quot; &quot;257&quot; &quot;80&quot; &quot;622&quot; ... ## $ free_elig_0809: chr [1:2101] &quot;306&quot; &quot;95&quot; &quot;38&quot; &quot;289&quot; ... ## $ free_per_0809 : chr [1:2101] &quot;46.43%&quot; &quot;36.96%&quot; &quot;47.50%&quot; &quot;46.46%&quot; ... ## $ red_elig_0809 : chr [1:2101] &quot;64&quot; &quot;8&quot; &quot;0&quot; &quot;56&quot; ... ## $ red_per_0809 : chr [1:2101] &quot;9.71%&quot; &quot;3.11%&quot; &quot;0.00%&quot; &quot;9.00%&quot; ... ## $ totalFRL_0809 : chr [1:2101] &quot;370&quot; &quot;103&quot; &quot;38&quot; &quot;345&quot; ... ## $ totalper_0809 : chr [1:2101] &quot;56.15%&quot; &quot;40.08%&quot; &quot;47.50%&quot; &quot;55.47%&quot; ... ## $ type0910 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2009 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2009 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2009 : chr [1:2101] &quot;654&quot; &quot;266&quot; &quot;78&quot; &quot;634&quot; ... ## $ total_2009 : chr [1:2101] &quot;654&quot; &quot;266&quot; &quot;78&quot; &quot;634&quot; ... ## $ snp_0910 : chr [1:2101] &quot;655&quot; &quot;266&quot; &quot;78&quot; &quot;635&quot; ... ## $ free_elig_0910: chr [1:2101] &quot;290&quot; &quot;99&quot; &quot;36&quot; &quot;286&quot; ... ## $ free_per_0910 : chr [1:2101] &quot;44.27%&quot; &quot;37.22%&quot; &quot;46.15%&quot; &quot;45.04%&quot; ... ## $ red_elig_0910 : chr [1:2101] &quot;37&quot; &quot;14&quot; &quot;0&quot; &quot;66&quot; ... ## $ red_per_0910 : chr [1:2101] &quot;5.65%&quot; &quot;5.26%&quot; &quot;0.00%&quot; &quot;10.39%&quot; ... ## $ totalFRL_09010: chr [1:2101] &quot;327&quot; &quot;113&quot; &quot;36&quot; &quot;352&quot; ... ## $ totalper_0910 : chr [1:2101] &quot;49.92%&quot; &quot;42.48%&quot; &quot;46.15%&quot; &quot;55.43%&quot; ... ## $ type1011 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2010 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2010 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2010 : chr [1:2101] &quot;603&quot; &quot;268&quot; &quot;74&quot; &quot;614&quot; ... ## $ total_2010 : chr [1:2101] &quot;603&quot; &quot;268&quot; &quot;74&quot; &quot;614&quot; ... ## $ snp_1011 : chr [1:2101] &quot;603&quot; &quot;277&quot; &quot;74&quot; &quot;606&quot; ... ## $ free_elig_1011: chr [1:2101] &quot;285&quot; &quot;108&quot; &quot;32&quot; &quot;308&quot; ... ## $ free_per_1011 : chr [1:2101] &quot;47.26%&quot; &quot;38.99%&quot; &quot;43.24%&quot; &quot;50.83%&quot; ... ## $ red_elig_1011 : chr [1:2101] &quot;46&quot; &quot;8&quot; &quot;0&quot; &quot;50&quot; ... ## $ red_per_1011 : chr [1:2101] &quot;7.63%&quot; &quot;2.89%&quot; &quot;0.00%&quot; &quot;8.25%&quot; ... ## $ totalFRL_1011 : chr [1:2101] &quot;331&quot; &quot;116&quot; &quot;32&quot; &quot;358&quot; ... ## $ totalper_1011 : chr [1:2101] &quot;54.89%&quot; &quot;41.88%&quot; &quot;43.24%&quot; &quot;59.08%&quot; ... ## $ type1112 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2011 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2011 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2011 : chr [1:2101] &quot;593&quot; &quot;276&quot; &quot;73&quot; &quot;605&quot; ... ## $ total_2011 : chr [1:2101] &quot;593&quot; &quot;276&quot; &quot;73&quot; &quot;605&quot; ... ## $ snp_1112 : chr [1:2101] &quot;593&quot; &quot;281&quot; &quot;73&quot; &quot;611&quot; ... ## $ free_elig_1112: chr [1:2101] &quot;289&quot; &quot;116&quot; &quot;31&quot; &quot;318&quot; ... ## $ free_per_1112 : chr [1:2101] &quot;48.74%&quot; &quot;41.28%&quot; &quot;42.47%&quot; &quot;52.05%&quot; ... ## $ red_elig_1112 : chr [1:2101] &quot;50&quot; &quot;14&quot; &quot;0&quot; &quot;44&quot; ... ## $ red_per_1112 : chr [1:2101] &quot;8.43%&quot; &quot;4.98%&quot; &quot;0.00%&quot; &quot;7.20%&quot; ... ## $ totalFRL_1112 : chr [1:2101] &quot;339&quot; &quot;130&quot; &quot;31&quot; &quot;362&quot; ... ## $ totalper_1112 : chr [1:2101] &quot;57.17%&quot; &quot;46.26%&quot; &quot;42.47%&quot; &quot;59.25%&quot; ... ## $ type1213 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2012 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2012 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2012 : chr [1:2101] &quot;637&quot; &quot;258&quot; &quot;68&quot; &quot;579&quot; ... ## $ total_2012 : chr [1:2101] &quot;637&quot; &quot;258&quot; &quot;68&quot; &quot;579&quot; ... ## $ snp_1213 : chr [1:2101] &quot;633&quot; &quot;259&quot; &quot;68&quot; &quot;579&quot; ... ## $ free_elig_1213: chr [1:2101] &quot;324&quot; &quot;117&quot; &quot;21&quot; &quot;348&quot; ... ## $ free_per_1213 : chr [1:2101] &quot;51.18%&quot; &quot;45.17%&quot; &quot;30.88%&quot; &quot;60.10%&quot; ... ## $ red_elig_1213 : chr [1:2101] &quot;42&quot; &quot;20&quot; &quot;5&quot; &quot;33&quot; ... ## $ red_per_1213 : chr [1:2101] &quot;6.64%&quot; &quot;7.72%&quot; &quot;7.35%&quot; &quot;5.70%&quot; ... ## $ totalFRL_1213 : chr [1:2101] &quot;366&quot; &quot;137&quot; &quot;26&quot; &quot;381&quot; ... ## $ totalper_1213 : chr [1:2101] &quot;57.82%&quot; &quot;52.90%&quot; &quot;38.24%&quot; &quot;65.80%&quot; ... ## $ type1314 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2013 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2013 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2013 : chr [1:2101] &quot;670&quot; &quot;238&quot; &quot;66&quot; &quot;582&quot; ... ## $ total_2013 : chr [1:2101] &quot;670&quot; &quot;238&quot; &quot;66&quot; &quot;582&quot; ... ## $ snp_1314 : chr [1:2101] &quot;668&quot; &quot;239&quot; &quot;56&quot; &quot;589&quot; ... ## $ free_elig_1314: chr [1:2101] &quot;346&quot; &quot;102&quot; &quot;12&quot; &quot;347&quot; ... ## $ free_per_1314 : chr [1:2101] &quot;51.80%&quot; &quot;42.68%&quot; &quot;21.43%&quot; &quot;58.91%&quot; ... ## $ red_elig_1314 : chr [1:2101] &quot;44&quot; &quot;19&quot; &quot;4&quot; &quot;54&quot; ... ## $ red_per_1314 : chr [1:2101] &quot;6.59%&quot; &quot;7.95%&quot; &quot;7.14%&quot; &quot;9.17%&quot; ... ## $ totalFRL_1314 : chr [1:2101] &quot;390&quot; &quot;121&quot; &quot;16&quot; &quot;401&quot; ... ## $ totalper_1314 : chr [1:2101] &quot;58.38%&quot; &quot;50.63%&quot; &quot;28.57%&quot; &quot;68.08%&quot; ... ## $ type1415 : chr [1:2101] NA NA NA NA ... ## $ lowgrade_2014 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2014 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2014 : chr [1:2101] &quot;685&quot; &quot;251&quot; &quot;65&quot; &quot;581&quot; ... ## $ total_2014 : chr [1:2101] &quot;685&quot; &quot;251&quot; &quot;65&quot; &quot;581&quot; ... ## $ snp_1415 : chr [1:2101] &quot;672&quot; &quot;239&quot; &quot;61&quot; &quot;586&quot; ... ## $ free_elig_1415: chr [1:2101] &quot;361&quot; &quot;93&quot; &quot;14&quot; &quot;351&quot; ... ## $ free_per_1415 : chr [1:2101] &quot;53.72%&quot; &quot;38.91%&quot; &quot;22.95%&quot; &quot;59.90%&quot; ... ## $ red_elig_1415 : chr [1:2101] &quot;40&quot; &quot;17&quot; &quot;4&quot; &quot;40&quot; ... ## $ red_per_1415 : chr [1:2101] &quot;5.95%&quot; &quot;7.11%&quot; &quot;6.56%&quot; &quot;6.83%&quot; ... ## $ totalFRL_1415 : chr [1:2101] &quot;401&quot; &quot;110&quot; &quot;18&quot; &quot;391&quot; ... ## $ totalper_1415 : chr [1:2101] &quot;59.67%&quot; &quot;46.03%&quot; &quot;29.51%&quot; &quot;66.72%&quot; ... ## $ CEP_1516 : chr [1:2101] &quot;#NULL!&quot; &quot;#NULL!&quot; &quot;#NULL!&quot; &quot;#NULL!&quot; ... ## $ type1516 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2015 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2015 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2015 : chr [1:2101] &quot;737&quot; &quot;259&quot; &quot;65&quot; &quot;621&quot; ... ## $ total_2015 : chr [1:2101] &quot;737&quot; &quot;259&quot; &quot;65&quot; &quot;621&quot; ... ## $ snp_1516 : chr [1:2101] &quot;728&quot; &quot;268&quot; &quot;67&quot; &quot;608&quot; ... ## $ free_elig_1516: chr [1:2101] &quot;362&quot; &quot;109&quot; &quot;12&quot; &quot;339&quot; ... ## $ free_per_1516 : chr [1:2101] &quot;49.73%&quot; &quot;40.67%&quot; &quot;17.91%&quot; &quot;55.76%&quot; ... ## [list output truncated] ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. sch_id = col_character(), ## .. div_num = col_double(), ## .. div_name = col_character(), ## .. school_num = col_character(), ## .. school_name = col_character(), ## .. school_name2 = col_character(), ## .. type0809 = col_character(), ## .. lowgrade_2008 = col_character(), ## .. higrade_2008 = col_character(), ## .. totalFT_2008 = col_character(), ## .. total_2008 = col_character(), ## .. snp_0809 = col_character(), ## .. free_elig_0809 = col_character(), ## .. free_per_0809 = col_character(), ## .. red_elig_0809 = col_character(), ## .. red_per_0809 = col_character(), ## .. totalFRL_0809 = col_character(), ## .. totalper_0809 = col_character(), ## .. type0910 = col_character(), ## .. lowgrade_2009 = col_character(), ## .. higrade_2009 = col_character(), ## .. totalFT_2009 = col_character(), ## .. total_2009 = col_character(), ## .. snp_0910 = col_character(), ## .. free_elig_0910 = col_character(), ## .. free_per_0910 = col_character(), ## .. red_elig_0910 = col_character(), ## .. red_per_0910 = col_character(), ## .. totalFRL_09010 = col_character(), ## .. totalper_0910 = col_character(), ## .. type1011 = col_character(), ## .. lowgrade_2010 = col_character(), ## .. higrade_2010 = col_character(), ## .. totalFT_2010 = col_character(), ## .. total_2010 = col_character(), ## .. snp_1011 = col_character(), ## .. free_elig_1011 = col_character(), ## .. free_per_1011 = col_character(), ## .. red_elig_1011 = col_character(), ## .. red_per_1011 = col_character(), ## .. totalFRL_1011 = col_character(), ## .. totalper_1011 = col_character(), ## .. type1112 = col_character(), ## .. lowgrade_2011 = col_character(), ## .. higrade_2011 = col_character(), ## .. totalFT_2011 = col_character(), ## .. total_2011 = col_character(), ## .. snp_1112 = col_character(), ## .. free_elig_1112 = col_character(), ## .. free_per_1112 = col_character(), ## .. red_elig_1112 = col_character(), ## .. red_per_1112 = col_character(), ## .. totalFRL_1112 = col_character(), ## .. totalper_1112 = col_character(), ## .. type1213 = col_character(), ## .. lowgrade_2012 = col_character(), ## .. higrade_2012 = col_character(), ## .. totalFT_2012 = col_character(), ## .. total_2012 = col_character(), ## .. snp_1213 = col_character(), ## .. free_elig_1213 = col_character(), ## .. free_per_1213 = col_character(), ## .. red_elig_1213 = col_character(), ## .. red_per_1213 = col_character(), ## .. totalFRL_1213 = col_character(), ## .. totalper_1213 = col_character(), ## .. type1314 = col_character(), ## .. lowgrade_2013 = col_character(), ## .. higrade_2013 = col_character(), ## .. totalFT_2013 = col_character(), ## .. total_2013 = col_character(), ## .. snp_1314 = col_character(), ## .. free_elig_1314 = col_character(), ## .. free_per_1314 = col_character(), ## .. red_elig_1314 = col_character(), ## .. red_per_1314 = col_character(), ## .. totalFRL_1314 = col_character(), ## .. totalper_1314 = col_character(), ## .. type1415 = col_character(), ## .. lowgrade_2014 = col_character(), ## .. higrade_2014 = col_character(), ## .. totalFT_2014 = col_character(), ## .. total_2014 = col_character(), ## .. snp_1415 = col_character(), ## .. free_elig_1415 = col_character(), ## .. free_per_1415 = col_character(), ## .. red_elig_1415 = col_character(), ## .. red_per_1415 = col_character(), ## .. totalFRL_1415 = col_character(), ## .. totalper_1415 = col_character(), ## .. CEP_1516 = col_character(), ## .. type1516 = col_character(), ## .. lowgrade_2015 = col_character(), ## .. higrade_2015 = col_character(), ## .. totalFT_2015 = col_character(), ## .. total_2015 = col_character(), ## .. snp_1516 = col_character(), ## .. free_elig_1516 = col_character(), ## .. free_per_1516 = col_character(), ## .. red_elig_1516 = col_character(), ## .. red_Per_1516 = col_character(), ## .. totalFRL_1516 = col_character(), ## .. totalper_1516 = col_character(), ## .. CEP_1617 = col_character(), ## .. type1617 = col_character(), ## .. lowgrade_2016 = col_character(), ## .. higrade_2016 = col_character(), ## .. totalFT_2016 = col_character(), ## .. total_2016 = col_character(), ## .. snp_2016 = col_character(), ## .. free_elig_1617 = col_character(), ## .. free_per_1617 = col_character(), ## .. red_elig_1617 = col_character(), ## .. red_per_1617 = col_character(), ## .. totalFRL_1617 = col_character(), ## .. totalper_1617 = col_character(), ## .. CEP_1718 = col_character(), ## .. type1718 = col_character(), ## .. lowgrade_2017 = col_character(), ## .. higrade_2017 = col_character(), ## .. totalFT_2017 = col_character(), ## .. total_2017 = col_character(), ## .. snp_1718 = col_character(), ## .. free_elig_1718 = col_character(), ## .. free_per_1718 = col_character(), ## .. red_elig_1718 = col_character(), ## .. red_per_1718 = col_character(), ## .. totalFRL_1718 = col_character(), ## .. totalper_1718 = col_character(), ## .. stable = col_character(), ## .. new = col_character(), ## .. closed = col_character(), ## .. close_yr = col_character(), ## .. reuseid = col_character(), ## .. gradechg = col_character(), ## .. gradechg_yr = col_character(), ## .. grchgyr_2 = col_character() ## .. ) Or just check the structure of one specific variable. str(mydata$total_2017) ## chr [1:2101] &quot;742&quot; &quot;236&quot; &quot;60&quot; &quot;624&quot; &quot;286&quot; &quot;485&quot; &quot;583&quot; &quot;550&quot; &quot;600&quot; &quot;514&quot; ... NOTE: When you have a lot of variables, running this str() function is not a great idea - the output is a little too cumbersome 3.5 Mutating Variables Note that almost all of the data reads in as a character data type which are just strings, This can create issues. We know that many of the columns are actually storing numbers or numeric values as R refers to them. We need to fix this. Lets tell R that these columns (at least the two we are going to use) are numeric. We are going to see two interchangeable ways to do this. First, we use the $ operator which lets me specify a specific column within my data frame in combination with the as.numeric() function mydata$total_2017&lt;-as.numeric(mydata$total_2017) mydata$totalFRL_1718&lt;-as.numeric(mydata$totalFRL_1718) Some columns have a percent symbol, which you will need to remove before coercing to numeric data type mydata &lt;- mydata %&gt;% mutate(totalper_0809 = str_remove(totalper_0809, &quot;%&quot;)) Then we can change the column from character to numeric mydata$totalper_0809 &lt;- as.numeric(mydata$totalper_0809) ## Warning: NAs introduced by coercion Check to make sure it converted the column type correctly using str(). str(mydata$totalper_0809) ## num [1:2101] 56.1 40.1 47.5 55.5 33.4 ... Second, alternatively, we can do this for a whole set of variables at once. We just need to specify a matching criteria. newdf &lt;- mydata %&gt;% mutate_at(vars(starts_with(&quot;total&quot;)), as.numeric) ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion newdf &lt;- newdf %&gt;% mutate_at(vars(starts_with(&quot;totalFRL&quot;)), as.numeric) Check whether the old and new variables are stored differently (old as a character, new as a numeric variable) str(mydata$total_2008) ## chr [1:2101] &quot;731&quot; &quot;263&quot; &quot;80&quot; &quot;638&quot; &quot;333&quot; &quot;536&quot; &quot;610&quot; &quot;490&quot; &quot;585&quot; &quot;450&quot; ... str(newdf$total_2008) ## num [1:2101] 731 263 80 638 333 536 610 490 585 450 ... 3.6 Filtering and Selecting A basic operation we do a lot is to filter the data so that we are working with a subset of all that we have. We can do this with the filter() function, part of the dplyr package (in the tidyverse collection of packages). Lets say we want to look at the schools with div_num values less than 50. newdf %&gt;% filter(div_num &lt; 50) ## # A tibble: 800 x 137 ## sch_id div_num div_name school_num school_name school_name2 type0809 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001-0~ 1 Accomac~ &quot;0070\\xa0&quot; NANDUA HIGH &lt;NA&gt; SCH-HIGH ## 2 001-0~ 1 Accomac~ &quot;0080\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-ELEM ## 3 001-0~ 1 Accomac~ &quot;0530\\xa0&quot; TANGIER CO~ &lt;NA&gt; SCH-COMB ## 4 001-0~ 1 Accomac~ &quot;0540\\xa0&quot; ARCADIA HI~ &lt;NA&gt; SCH-HIGH ## 5 001-0~ 1 Accomac~ &quot;0580\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-COMB ## 6 001-0~ 1 Accomac~ &quot;0590\\xa0&quot; PUNGOTEAGU~ &lt;NA&gt; SCH-ELEM ## 7 001-0~ 1 Accomac~ &quot;0600\\xa0&quot; KEGOTANK E~ &lt;NA&gt; SCH-ELEM ## 8 001-0~ 1 Accomac~ &quot;0701\\xa0&quot; ACCAWMACKE~ &lt;NA&gt; SCH-ELEM ## 9 001-0~ 1 Accomac~ &quot;0702\\xa0&quot; METOMPKIN ~ &lt;NA&gt; SCH-ELEM ## 10 001-0~ 1 Accomac~ &quot;0703\\xa0&quot; NANDUA MID~ &lt;NA&gt; SCH-MID ## # ... with 790 more rows, and 130 more variables: lowgrade_2008 &lt;chr&gt;, ## # higrade_2008 &lt;chr&gt;, totalFT_2008 &lt;dbl&gt;, total_2008 &lt;dbl&gt;, snp_0809 &lt;chr&gt;, ## # free_elig_0809 &lt;chr&gt;, free_per_0809 &lt;chr&gt;, red_elig_0809 &lt;chr&gt;, ## # red_per_0809 &lt;chr&gt;, totalFRL_0809 &lt;dbl&gt;, totalper_0809 &lt;dbl&gt;, ## # type0910 &lt;chr&gt;, lowgrade_2009 &lt;chr&gt;, higrade_2009 &lt;chr&gt;, ## # totalFT_2009 &lt;dbl&gt;, total_2009 &lt;dbl&gt;, snp_0910 &lt;chr&gt;, free_elig_0910 &lt;chr&gt;, ## # free_per_0910 &lt;chr&gt;, red_elig_0910 &lt;chr&gt;, red_per_0910 &lt;chr&gt;, ## # totalFRL_09010 &lt;dbl&gt;, totalper_0910 &lt;dbl&gt;, type1011 &lt;chr&gt;, ## # lowgrade_2010 &lt;chr&gt;, higrade_2010 &lt;chr&gt;, totalFT_2010 &lt;dbl&gt;, ## # total_2010 &lt;dbl&gt;, snp_1011 &lt;chr&gt;, free_elig_1011 &lt;chr&gt;, ## # free_per_1011 &lt;chr&gt;, red_elig_1011 &lt;chr&gt;, red_per_1011 &lt;chr&gt;, ## # totalFRL_1011 &lt;dbl&gt;, totalper_1011 &lt;dbl&gt;, type1112 &lt;chr&gt;, ## # lowgrade_2011 &lt;chr&gt;, higrade_2011 &lt;chr&gt;, totalFT_2011 &lt;dbl&gt;, ## # total_2011 &lt;dbl&gt;, snp_1112 &lt;chr&gt;, free_elig_1112 &lt;chr&gt;, ## # free_per_1112 &lt;chr&gt;, red_elig_1112 &lt;chr&gt;, red_per_1112 &lt;chr&gt;, ## # totalFRL_1112 &lt;dbl&gt;, totalper_1112 &lt;dbl&gt;, type1213 &lt;chr&gt;, ## # lowgrade_2012 &lt;chr&gt;, higrade_2012 &lt;chr&gt;, totalFT_2012 &lt;dbl&gt;, ## # total_2012 &lt;dbl&gt;, snp_1213 &lt;chr&gt;, free_elig_1213 &lt;chr&gt;, ## # free_per_1213 &lt;chr&gt;, red_elig_1213 &lt;chr&gt;, red_per_1213 &lt;chr&gt;, ## # totalFRL_1213 &lt;dbl&gt;, totalper_1213 &lt;dbl&gt;, type1314 &lt;chr&gt;, ## # lowgrade_2013 &lt;chr&gt;, higrade_2013 &lt;chr&gt;, totalFT_2013 &lt;dbl&gt;, ## # total_2013 &lt;dbl&gt;, snp_1314 &lt;chr&gt;, free_elig_1314 &lt;chr&gt;, ## # free_per_1314 &lt;chr&gt;, red_elig_1314 &lt;chr&gt;, red_per_1314 &lt;chr&gt;, ## # totalFRL_1314 &lt;dbl&gt;, totalper_1314 &lt;dbl&gt;, type1415 &lt;chr&gt;, ## # lowgrade_2014 &lt;chr&gt;, higrade_2014 &lt;chr&gt;, totalFT_2014 &lt;dbl&gt;, ## # total_2014 &lt;dbl&gt;, snp_1415 &lt;chr&gt;, free_elig_1415 &lt;chr&gt;, ## # free_per_1415 &lt;chr&gt;, red_elig_1415 &lt;chr&gt;, red_per_1415 &lt;chr&gt;, ## # totalFRL_1415 &lt;dbl&gt;, totalper_1415 &lt;dbl&gt;, CEP_1516 &lt;chr&gt;, type1516 &lt;chr&gt;, ## # lowgrade_2015 &lt;chr&gt;, higrade_2015 &lt;chr&gt;, totalFT_2015 &lt;dbl&gt;, ## # total_2015 &lt;dbl&gt;, snp_1516 &lt;chr&gt;, free_elig_1516 &lt;chr&gt;, ## # free_per_1516 &lt;chr&gt;, red_elig_1516 &lt;chr&gt;, red_Per_1516 &lt;chr&gt;, ## # totalFRL_1516 &lt;dbl&gt;, totalper_1516 &lt;dbl&gt;, CEP_1617 &lt;chr&gt;, type1617 &lt;chr&gt;, ## # lowgrade_2016 &lt;chr&gt;, higrade_2016 &lt;chr&gt;, ... Or, if we want to look at schools where the highest grade in 2008 was grade five, we can try: newdf %&gt;% filter(higrade_2008 == &quot;5&quot;) # this returns a subsetted dataframe with 878 rows ## # A tibble: 878 x 137 ## sch_id div_num div_name school_num school_name school_name2 type0809 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001-0~ 1 Accomac~ &quot;0080\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-ELEM ## 2 001-0~ 1 Accomac~ &quot;0590\\xa0&quot; PUNGOTEAGU~ &lt;NA&gt; SCH-ELEM ## 3 001-0~ 1 Accomac~ &quot;0600\\xa0&quot; KEGOTANK E~ &lt;NA&gt; SCH-ELEM ## 4 001-0~ 1 Accomac~ &quot;0701\\xa0&quot; ACCAWMACKE~ &lt;NA&gt; SCH-ELEM ## 5 001-0~ 1 Accomac~ &quot;0702\\xa0&quot; METOMPKIN ~ &lt;NA&gt; SCH-ELEM ## 6 002-0~ 2 Albemar~ &quot;0010\\xa0&quot; HOLLYMEAD ~ &lt;NA&gt; SCH-ELEM ## 7 002-0~ 2 Albemar~ &quot;0030\\xa0&quot; SCOTTSVILL~ &lt;NA&gt; SCH-ELEM ## 8 002-0~ 2 Albemar~ &quot;0040\\xa0&quot; MARY CARR ~ &lt;NA&gt; SCH-ELEM ## 9 002-0~ 2 Albemar~ &quot;0100\\xa0&quot; BROADUS WO~ &lt;NA&gt; SCH-ELEM ## 10 002-0~ 2 Albemar~ &quot;0150\\xa0&quot; PAUL H CAL~ &lt;NA&gt; SCH-ELEM ## # ... with 868 more rows, and 130 more variables: lowgrade_2008 &lt;chr&gt;, ## # higrade_2008 &lt;chr&gt;, totalFT_2008 &lt;dbl&gt;, total_2008 &lt;dbl&gt;, snp_0809 &lt;chr&gt;, ## # free_elig_0809 &lt;chr&gt;, free_per_0809 &lt;chr&gt;, red_elig_0809 &lt;chr&gt;, ## # red_per_0809 &lt;chr&gt;, totalFRL_0809 &lt;dbl&gt;, totalper_0809 &lt;dbl&gt;, ## # type0910 &lt;chr&gt;, lowgrade_2009 &lt;chr&gt;, higrade_2009 &lt;chr&gt;, ## # totalFT_2009 &lt;dbl&gt;, total_2009 &lt;dbl&gt;, snp_0910 &lt;chr&gt;, free_elig_0910 &lt;chr&gt;, ## # free_per_0910 &lt;chr&gt;, red_elig_0910 &lt;chr&gt;, red_per_0910 &lt;chr&gt;, ## # totalFRL_09010 &lt;dbl&gt;, totalper_0910 &lt;dbl&gt;, type1011 &lt;chr&gt;, ## # lowgrade_2010 &lt;chr&gt;, higrade_2010 &lt;chr&gt;, totalFT_2010 &lt;dbl&gt;, ## # total_2010 &lt;dbl&gt;, snp_1011 &lt;chr&gt;, free_elig_1011 &lt;chr&gt;, ## # free_per_1011 &lt;chr&gt;, red_elig_1011 &lt;chr&gt;, red_per_1011 &lt;chr&gt;, ## # totalFRL_1011 &lt;dbl&gt;, totalper_1011 &lt;dbl&gt;, type1112 &lt;chr&gt;, ## # lowgrade_2011 &lt;chr&gt;, higrade_2011 &lt;chr&gt;, totalFT_2011 &lt;dbl&gt;, ## # total_2011 &lt;dbl&gt;, snp_1112 &lt;chr&gt;, free_elig_1112 &lt;chr&gt;, ## # free_per_1112 &lt;chr&gt;, red_elig_1112 &lt;chr&gt;, red_per_1112 &lt;chr&gt;, ## # totalFRL_1112 &lt;dbl&gt;, totalper_1112 &lt;dbl&gt;, type1213 &lt;chr&gt;, ## # lowgrade_2012 &lt;chr&gt;, higrade_2012 &lt;chr&gt;, totalFT_2012 &lt;dbl&gt;, ## # total_2012 &lt;dbl&gt;, snp_1213 &lt;chr&gt;, free_elig_1213 &lt;chr&gt;, ## # free_per_1213 &lt;chr&gt;, red_elig_1213 &lt;chr&gt;, red_per_1213 &lt;chr&gt;, ## # totalFRL_1213 &lt;dbl&gt;, totalper_1213 &lt;dbl&gt;, type1314 &lt;chr&gt;, ## # lowgrade_2013 &lt;chr&gt;, higrade_2013 &lt;chr&gt;, totalFT_2013 &lt;dbl&gt;, ## # total_2013 &lt;dbl&gt;, snp_1314 &lt;chr&gt;, free_elig_1314 &lt;chr&gt;, ## # free_per_1314 &lt;chr&gt;, red_elig_1314 &lt;chr&gt;, red_per_1314 &lt;chr&gt;, ## # totalFRL_1314 &lt;dbl&gt;, totalper_1314 &lt;dbl&gt;, type1415 &lt;chr&gt;, ## # lowgrade_2014 &lt;chr&gt;, higrade_2014 &lt;chr&gt;, totalFT_2014 &lt;dbl&gt;, ## # total_2014 &lt;dbl&gt;, snp_1415 &lt;chr&gt;, free_elig_1415 &lt;chr&gt;, ## # free_per_1415 &lt;chr&gt;, red_elig_1415 &lt;chr&gt;, red_per_1415 &lt;chr&gt;, ## # totalFRL_1415 &lt;dbl&gt;, totalper_1415 &lt;dbl&gt;, CEP_1516 &lt;chr&gt;, type1516 &lt;chr&gt;, ## # lowgrade_2015 &lt;chr&gt;, higrade_2015 &lt;chr&gt;, totalFT_2015 &lt;dbl&gt;, ## # total_2015 &lt;dbl&gt;, snp_1516 &lt;chr&gt;, free_elig_1516 &lt;chr&gt;, ## # free_per_1516 &lt;chr&gt;, red_elig_1516 &lt;chr&gt;, red_Per_1516 &lt;chr&gt;, ## # totalFRL_1516 &lt;dbl&gt;, totalper_1516 &lt;dbl&gt;, CEP_1617 &lt;chr&gt;, type1617 &lt;chr&gt;, ## # lowgrade_2016 &lt;chr&gt;, higrade_2016 &lt;chr&gt;, ... Note that we had to set it equal to the character value 5 rather than the numeric value 5. Why? If we wanted to filter on numeric values instead, we would want to do something like this: newdf %&gt;% mutate(higrade_2008 = as.numeric(higrade_2008)) %&gt;% filter(higrade_2008 == 5) # again, this returns a subsetted dataframe with 878 rows ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## # A tibble: 878 x 137 ## sch_id div_num div_name school_num school_name school_name2 type0809 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001-0~ 1 Accomac~ &quot;0080\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-ELEM ## 2 001-0~ 1 Accomac~ &quot;0590\\xa0&quot; PUNGOTEAGU~ &lt;NA&gt; SCH-ELEM ## 3 001-0~ 1 Accomac~ &quot;0600\\xa0&quot; KEGOTANK E~ &lt;NA&gt; SCH-ELEM ## 4 001-0~ 1 Accomac~ &quot;0701\\xa0&quot; ACCAWMACKE~ &lt;NA&gt; SCH-ELEM ## 5 001-0~ 1 Accomac~ &quot;0702\\xa0&quot; METOMPKIN ~ &lt;NA&gt; SCH-ELEM ## 6 002-0~ 2 Albemar~ &quot;0010\\xa0&quot; HOLLYMEAD ~ &lt;NA&gt; SCH-ELEM ## 7 002-0~ 2 Albemar~ &quot;0030\\xa0&quot; SCOTTSVILL~ &lt;NA&gt; SCH-ELEM ## 8 002-0~ 2 Albemar~ &quot;0040\\xa0&quot; MARY CARR ~ &lt;NA&gt; SCH-ELEM ## 9 002-0~ 2 Albemar~ &quot;0100\\xa0&quot; BROADUS WO~ &lt;NA&gt; SCH-ELEM ## 10 002-0~ 2 Albemar~ &quot;0150\\xa0&quot; PAUL H CAL~ &lt;NA&gt; SCH-ELEM ## # ... with 868 more rows, and 130 more variables: lowgrade_2008 &lt;chr&gt;, ## # higrade_2008 &lt;dbl&gt;, totalFT_2008 &lt;dbl&gt;, total_2008 &lt;dbl&gt;, snp_0809 &lt;chr&gt;, ## # free_elig_0809 &lt;chr&gt;, free_per_0809 &lt;chr&gt;, red_elig_0809 &lt;chr&gt;, ## # red_per_0809 &lt;chr&gt;, totalFRL_0809 &lt;dbl&gt;, totalper_0809 &lt;dbl&gt;, ## # type0910 &lt;chr&gt;, lowgrade_2009 &lt;chr&gt;, higrade_2009 &lt;chr&gt;, ## # totalFT_2009 &lt;dbl&gt;, total_2009 &lt;dbl&gt;, snp_0910 &lt;chr&gt;, free_elig_0910 &lt;chr&gt;, ## # free_per_0910 &lt;chr&gt;, red_elig_0910 &lt;chr&gt;, red_per_0910 &lt;chr&gt;, ## # totalFRL_09010 &lt;dbl&gt;, totalper_0910 &lt;dbl&gt;, type1011 &lt;chr&gt;, ## # lowgrade_2010 &lt;chr&gt;, higrade_2010 &lt;chr&gt;, totalFT_2010 &lt;dbl&gt;, ## # total_2010 &lt;dbl&gt;, snp_1011 &lt;chr&gt;, free_elig_1011 &lt;chr&gt;, ## # free_per_1011 &lt;chr&gt;, red_elig_1011 &lt;chr&gt;, red_per_1011 &lt;chr&gt;, ## # totalFRL_1011 &lt;dbl&gt;, totalper_1011 &lt;dbl&gt;, type1112 &lt;chr&gt;, ## # lowgrade_2011 &lt;chr&gt;, higrade_2011 &lt;chr&gt;, totalFT_2011 &lt;dbl&gt;, ## # total_2011 &lt;dbl&gt;, snp_1112 &lt;chr&gt;, free_elig_1112 &lt;chr&gt;, ## # free_per_1112 &lt;chr&gt;, red_elig_1112 &lt;chr&gt;, red_per_1112 &lt;chr&gt;, ## # totalFRL_1112 &lt;dbl&gt;, totalper_1112 &lt;dbl&gt;, type1213 &lt;chr&gt;, ## # lowgrade_2012 &lt;chr&gt;, higrade_2012 &lt;chr&gt;, totalFT_2012 &lt;dbl&gt;, ## # total_2012 &lt;dbl&gt;, snp_1213 &lt;chr&gt;, free_elig_1213 &lt;chr&gt;, ## # free_per_1213 &lt;chr&gt;, red_elig_1213 &lt;chr&gt;, red_per_1213 &lt;chr&gt;, ## # totalFRL_1213 &lt;dbl&gt;, totalper_1213 &lt;dbl&gt;, type1314 &lt;chr&gt;, ## # lowgrade_2013 &lt;chr&gt;, higrade_2013 &lt;chr&gt;, totalFT_2013 &lt;dbl&gt;, ## # total_2013 &lt;dbl&gt;, snp_1314 &lt;chr&gt;, free_elig_1314 &lt;chr&gt;, ## # free_per_1314 &lt;chr&gt;, red_elig_1314 &lt;chr&gt;, red_per_1314 &lt;chr&gt;, ## # totalFRL_1314 &lt;dbl&gt;, totalper_1314 &lt;dbl&gt;, type1415 &lt;chr&gt;, ## # lowgrade_2014 &lt;chr&gt;, higrade_2014 &lt;chr&gt;, totalFT_2014 &lt;dbl&gt;, ## # total_2014 &lt;dbl&gt;, snp_1415 &lt;chr&gt;, free_elig_1415 &lt;chr&gt;, ## # free_per_1415 &lt;chr&gt;, red_elig_1415 &lt;chr&gt;, red_per_1415 &lt;chr&gt;, ## # totalFRL_1415 &lt;dbl&gt;, totalper_1415 &lt;dbl&gt;, CEP_1516 &lt;chr&gt;, type1516 &lt;chr&gt;, ## # lowgrade_2015 &lt;chr&gt;, higrade_2015 &lt;chr&gt;, totalFT_2015 &lt;dbl&gt;, ## # total_2015 &lt;dbl&gt;, snp_1516 &lt;chr&gt;, free_elig_1516 &lt;chr&gt;, ## # free_per_1516 &lt;chr&gt;, red_elig_1516 &lt;chr&gt;, red_Per_1516 &lt;chr&gt;, ## # totalFRL_1516 &lt;dbl&gt;, totalper_1516 &lt;dbl&gt;, CEP_1617 &lt;chr&gt;, type1617 &lt;chr&gt;, ## # lowgrade_2016 &lt;chr&gt;, higrade_2016 &lt;chr&gt;, ... 3.7 Grouping and Summarizing Lets shift gears to a different combination of operations Lets go ahead and try using tidyverse to narrow to what we want. Imagine we want to see the county level aggregate numbers for FRL in the 2017-2018 school year. We will start out with our entire data frame and then use pipes (the %&gt;% operator) to work from there. The final result will be stored in our new data frame that we are creating, called county_level_aggregate. First, select will pick columns Next, group_by and summarize work together to get us our aggregate totals. county_level_aggregate &lt;- newdf %&gt;% select(div_name, total_2017, totalFRL_1718) %&gt;% group_by(div_name) %&gt;% summarize(totalstudents = sum(total_2017), totalFRL = sum(totalFRL_1718)) ## `summarise()` ungrouping output (override with `.groups` argument) Now, we can compute percentages if we like and we can specify a new column by referring to. One that doesnt exist yet but will after we run this code. We will do this two interchangeable ways. First, the old school way: county_level_aggregate$percent_FRL &lt;- county_level_aggregate$totalFRL/county_level_aggregate$totalstudents*100 Second, the tidyverse way: county_level_aggregate &lt;- county_level_aggregate %&gt;% mutate(percent_frl = totalFRL / totalstudents * 100) Just for fun, lets see how this could have been incorporated into our summarize call county_level_percents &lt;- newdf %&gt;% select(div_name, total_2017, totalFRL_1718) %&gt;% group_by(div_name) %&gt;% summarize(percentFRL=sum(totalFRL_1718)/sum(total_2017) * 100) ## `summarise()` ungrouping output (override with `.groups` argument) Something is going to look weird with this plot newdf %&gt;% ggplot(aes(totalFRL_0809, totalFT_2008)) + geom_point() + labs(title = &quot;FRL 2008&quot;, x = &quot;totalFRL_0809&quot;) ## Warning: Removed 236 rows containing missing values (geom_point). Lets see if we can fix it newdf %&gt;% filter(!is.na(totalFRL_0809)) %&gt;% ggplot(aes(totalFRL_0809, totalFT_2008)) + geom_point() + labs(title = &quot;FRL 2008&quot;, x = &quot;totalFRL_0809&quot;) + xlim(0, 1000) + ylim(0, 1000) ## Warning: Removed 324 rows containing missing values (geom_point). "],["week-4-assumptions-and-correlations.html", "Chapter4 Week 4: Assumptions and Correlations 4.1 Assumptions 4.2 Correlation 4.3 Another worked example for cleaning and prelim analysis", " Chapter4 Week 4: Assumptions and Correlations This week we will be discussing Chapters 5 and 6 from DSUR. These notes will pull out some of the important pieces from each chapter. 4.1 Assumptions These assumptions that we are making are helpful when determining whether we should be using parametric vs non-parametric statistical tests. What does parametric mean here? It means that the data are from a parameterized distribution (i.e., parameters characterize the distribution that the data come from). An example of a parameterized distribution that we have already seen is the normal distribution. The two parameters for the normal distribution are \\(\\mu\\) for the mean and \\(\\sigma\\) for the standard deviation. We have seen this altogether with this kind of notation to denote that \\(x_i\\) is from a normal distribution: \\(x_i \\sim \\mathcal{N} (\\mu, \\,\\sigma^{2})\\) 4.1.1 Normally distributed data This assumption is about the normality of the sampling distribution. The big idea here is that we tend to operate under the belief that if our sampled data are normally distributed then the underlying sampling distribution is also normally distributed. Also, keep in mind that this becomes less of a concern as our sample size increases (thank, Central Limit Theorem!). There are several tests for normality that we will discuss, which include either (a) calculations or (b) visual examination. We will discuss both. 4.1.1.1 Visual check of normality You can accomplish this with a histogram (e.g., hist() or geom_histogram() or a q-q plot qplot() (which stands for quantile-quantile). 4.1.2 Homogeneity of variance Here, you want to know whether the variance of a variable is the same across different groups. For example, if you are looking at test scores in chemistry and chemical engineering students, you want to know if the variances (spread) of the test scores in the chemistry group and the chemical engineering group are close to each other. 4.1.3 Interval data This might be a little redundant given that we want normally distributed data, but you want at least interval data (ratio data are also fine, but in practice very few things we work with actually qualify as ratio variables). If you have ordinal or nominal variables, you might be in trouble with this assumption 4.1.4 Independence This assumption is about the observations not being related to each other or affecting each other in some way. In practice, this can also be a little tricky. For example, if you are sampling students from different classrooms, depending on the variables you are measuring, you might actually have reason to believe that students in one classroom are more related to each other than students in a different classroom. In practice, you can handle this with a multi-level model (aka hierarchical model), but that is beyond the scope of this class. 4.2 Correlation 4.2.1 Covariance First, start with the observation that variance is calculated with: \\(Variance(s^2) = \\frac{\\sum(x_i - \\overline{x})^2}{N - 1} = \\frac{\\sum(x_i - \\overline{x})(x_i - \\overline{x})}{N - 1}\\) But now lets say that we want to know how, for each observation we have, how does the value of \\(x\\) vary with the value of \\(y\\) on average. For example, when the value of \\(x\\) increases, does the value of \\(y\\) also increase? This could happen when \\(x\\) represents the number of hours of sleep you get each night and \\(y\\) is your average grade on an exam you take the next day. The opposite could arise when \\(x\\) increases but we expect \\(y\\) to go down. An example of this might be when \\(x\\) is the number of hilarious jokes that a teacher tells in class and \\(y\\) is the number of students who fall asleep in class. As the number of jokes increases, we might expect/hope that it keeps students attention and keeps them from dozing. This generally process of considering how one variable changes when another variable changes is where the notion of covariance comes in. In practice, what we really want to know is: when \\(x_i\\) is above its average value in a sample (\\(\\overline{x}\\)), how does \\(y_i\\) change? Does it also tend to be above the sample average for \\(y\\) (\\(\\overline{y}\\))? This is expressed in the general formular for covariance: \\(cov(x,y) = \\frac{\\sum(x_i - \\overline{x})(y_i - \\overline{y})}{N - 1}\\) While covariance can be a helpful value to work with in many settings, for most of what we do in this class, we will be using correlation coefficients instead of covariance. This is because covariance is an unnormalized value, which can make comparisons across different ranges of values difficult. 4.2.2 Correlation coefficient In order to standardize the covariance to a value the is easier to work with across ranges of values, we use the correlatoin coefficient. There are several version of this, depending on the type of data you are working with. The most basic version is the Pearson correlation coefficient. It is calculated by dividing the covariance by the standard deviations of your two variables of interest: \\(r = \\frac{cov_{xy}}{s_xs_y} = \\frac{\\sum(x_i - \\overline{x})(y_i - \\overline{y})}{(N-1)s_xs_y}\\) This is a bivariate correlation coefficient because it is looking at the correlation between two variables. There are also partial correlation coefficients, which look at the correlation between two variables whil controlling for other variables. We can calculate the correlatoin between two variables using the cor() or cor.test() functions, which are part of base R. 4.3 Another worked example for cleaning and prelim analysis This script takes an incomplete subset of senior data from a .csv file, cleans it, computes factor scores, and prepares it for analysis. If you have not already done so, make sure that you have run library(tidyverse) and library(psych) since we will be using functions from both of those packages. 4.3.1 Loading in data First, as usual, load in your data. We will use the file seniorsurvey.csv for this demo. file_path &lt;- \"YOUR PATH HERE\" setwd(file_path) use this command to change the working directory to the folder where you have your file list.files() run this to make sure that your file is in your current working directory seniorSurvey_df &lt;- read_csv(&quot;seniorsurvey.csv&quot;) # replace text in the parentheses with your file name ## Parsed with column specification: ## cols( ## .default = col_double() ## ) ## See spec(...) for full column specifications. 4.3.2 Data prep and cleaning After loading, it is always nice to just see how things loaded in. Functions like str() and describe() from the psych package are nice for this. For example, if we use describe(), we can see the following (we deleted some variables): psych::describe(seniorSurvey_df) ## vars n mean sd median ## What is your PRIMARY MAJOR? 1 1849 31.79 20.43 29 ## Internship, field experience, co-op, or practicum 2 1121 1.00 0.00 1 ## ParticipateServiceL 3 489 1.00 0.00 1 ## ParticipateCService 4 1296 1.00 0.00 1 ## ParticipateStudyAbroadSemester 5 142 1.00 0.00 1 ## SJ1 6 1733 2.32 1.03 2 ## SJ2 7 1732 2.08 0.96 2 ## SJ3 8 1731 2.77 0.88 3 ## SJ4 9 1726 2.27 1.01 2 ## SJ5 10 1728 3.27 0.92 3 ## SJ6 11 1719 3.50 0.83 4 ## SJ7 12 1719 4.01 0.79 4 ## SJ8 13 1719 4.15 0.83 4 ## DA1 14 1719 2.23 0.93 2 ## DA2 15 1719 2.86 0.95 3 ## DA3 16 1720 1.97 0.81 2 ## DA4 17 1721 4.20 0.72 4 ## DA5 18 1721 4.06 0.81 4 ## LocalRole 19 1453 3.49 0.94 4 ## LocalFinance 20 1453 3.22 0.90 3 ## LocalTime 21 1453 3.58 0.89 4 ## GlobalRole 22 1446 3.57 0.99 4 ## GlobalFinance 23 1449 3.19 1.00 3 ## GlobalTime 24 1449 3.42 0.98 3 ## Your gender? 25 1678 1.49 0.50 1 ## trimmed mad min max range ## What is your PRIMARY MAJOR? 31.25 28.17 1 70 69 ## Internship, field experience, co-op, or practicum 1.00 0.00 1 1 0 ## ParticipateServiceL 1.00 0.00 1 1 0 ## ParticipateCService 1.00 0.00 1 1 0 ## ParticipateStudyAbroadSemester 1.00 0.00 1 1 0 ## SJ1 2.25 1.48 1 5 4 ## SJ2 1.98 1.48 1 5 4 ## SJ3 2.79 1.48 1 5 4 ## SJ4 2.20 1.48 1 5 4 ## SJ5 3.27 1.48 1 5 4 ## SJ6 3.54 1.48 1 5 4 ## SJ7 4.07 0.00 1 5 4 ## SJ8 4.23 1.48 1 5 4 ## DA1 2.15 1.48 1 5 4 ## DA2 2.89 1.48 1 5 4 ## DA3 1.90 0.00 1 5 4 ## DA4 4.27 1.48 1 5 4 ## DA5 4.11 1.48 1 5 4 ## LocalRole 3.51 1.48 1 5 4 ## LocalFinance 3.23 1.48 1 5 4 ## LocalTime 3.63 1.48 1 5 4 ## GlobalRole 3.62 1.48 1 5 4 ## GlobalFinance 3.18 1.48 1 5 4 ## GlobalTime 3.44 1.48 1 5 4 ## Your gender? 1.49 0.00 1 2 1 ## skew kurtosis se ## What is your PRIMARY MAJOR? 0.18 -1.33 0.48 ## Internship, field experience, co-op, or practicum NaN NaN 0.00 ## ParticipateServiceL NaN NaN 0.00 ## ParticipateCService NaN NaN 0.00 ## ParticipateStudyAbroadSemester NaN NaN 0.00 ## SJ1 0.46 -0.51 0.02 ## SJ2 0.64 -0.16 0.02 ## SJ3 -0.03 -0.14 0.02 ## SJ4 0.52 -0.40 0.02 ## SJ5 -0.19 -0.03 0.02 ## SJ6 -0.40 0.15 0.02 ## SJ7 -0.75 1.05 0.02 ## SJ8 -0.86 0.69 0.02 ## DA1 0.57 -0.11 0.02 ## DA2 -0.09 -0.41 0.02 ## DA3 0.70 0.31 0.02 ## DA4 -0.66 0.54 0.02 ## DA5 -0.59 0.16 0.02 ## LocalRole -0.44 -0.33 0.02 ## LocalFinance -0.19 -0.27 0.02 ## LocalTime -0.59 0.22 0.02 ## GlobalRole -0.47 -0.30 0.03 ## GlobalFinance -0.11 -0.33 0.03 ## GlobalTime -0.35 -0.17 0.03 ## Your gender? 0.03 -2.00 0.01 Upon examining this, we can notice a few things: Primary Major variable is all messed up. We wont fix it here, but basically there is a numeric code needed (e.g., 13 = underwater basket weaving) Columns 3 and 5 have lots of missing values (note the small Ns)  this means that this was asked via checkbox so (1) is true and missing is not missing but False SJ1-8 and DA1-5 all look essentially ok  about the same N (some survey fatigue or skips) but all values in range (1-5) Now, we know that SJ and DA are scales from the literature and we want to compute scale scores for those. Typically for attitude scales like these we just report means across the items. So, we will use the psych package to use a built in function to help us with this. If you have not used psych yet, be sure it is installed using the command install.packages(psych)  you need only do this once and then in subsequent uses you only need library(psych) to tell R to look in that package for the functions you will be using. library(psych) Subset out only the SJ and DA items in their own dataframe and then use tools in the psych package to compute scale means The first method to do this - use numbering of the columns: seniorSurveyScales_df &lt;- seniorSurvey_df[6:18] A second method to do this - use select() from dplyr seniorSurveyScales_df &lt;- seniorSurvey_df %&gt;% select(SJ1:DA5) Use the make.keys() function from psych package to key-in how the scales are built (mapping items to scales, use - for reverse scored items) my_keys &lt;- make.keys(seniorSurveyScales_df, list(SJCa=c(-1,-2,-3,-4),SJCh=c(5,6,7),DA=c(-9,-10,-11,12,13))) Use scoreItems function to score each respondent on the three scales of interest SJCa, SJCh, and DA  the default here in scoreItems is to takes the mean of the items (not additive though that is sometimes used) and also, it imputes missing values instead of dropping cases the scoreItems function calculates many things. At this stage, all we really want are the scores, so we include a line to only extract that info. my_scales &lt;- scoreItems(my_keys, seniorSurveyScales_df) my_scores &lt;- my_scales$scores Now, if you view the first few rows of the my.scores vector using the header  head() command  it looks like we expect: head(my_scores) ## SJCa SJCh DA ## [1,] 2.75 3.000000 3.2 ## [2,] 3.75 3.333333 4.2 ## [3,] 3.00 3.000000 3.0 ## [4,] 2.25 4.333333 3.6 ## [5,] 3.00 3.333333 3.4 ## [6,] 4.50 4.333333 3.4 Now, lets build a clean dataframe to prep for analysis - by clean in this case I mean that we have replaced item scores from the scales with their means and also that we have fixed the NAs that dont belong (for participation variables, in this dataset, the NAs should be 0s) my_df &lt;- data.frame(seniorSurvey_df[1:5],my_scores, seniorSurvey_df[19:25]) This is an old school method to replace NAs in specific columns my_df$ParticipateServiceL[is.na(my_df$ParticipateServiceL)] &lt;- 0 my_df$ParticipateCService[is.na(my_df$ParticipateCService)] &lt;- 0 my_df$ParticipateStudyAbroadSemester[is.na(my_df$ParticipateStudyAbroadSemester)] &lt;- 0 my_df\\(ParticipateInternCoop...[is.na(mydf\\)ParticipateInternCoop)] &lt;- 0 - this variable read in cumbersomely named and I dont care about it right now so Ill skip Here is An alternative method to replace NAs in specific columns: my_df &lt;- my_df %&gt;% replace_na(list(ParticipateCService = 0, ParticipateStudyAbroadSemester = 0, ParticipateServiceL = 0)) 4.3.3 Preliminary analysis At this point, we are ready for some analysis Lets investigate correlations. What seems most obvious would just be to run cor() but, as we found out in class, this can cause us to run full speed ahead without considering assumptions my_correlations &lt;- my_df %&gt;% select(SJCa,SJCh,DA) %&gt;% cor() print(my_correlations) ## SJCa SJCh DA ## SJCa 1.0000000 0.2590211 0.3342276 ## SJCh 0.2590211 1.0000000 0.2310703 ## DA 0.3342276 0.2310703 1.0000000 Ok, so, it is important that we note that this ran correlations but R doesnt know that this was sample data and therefore that we are interested instatistical significance (or not) of these results AND that our data may need another method (e.g., non-parametric). cor() does have a way to run spearman instead. my_spearman_correlations &lt;- my_df %&gt;% select(SJCa,SJCh,DA) %&gt;% cor(method=&quot;spearman&quot;) print(my_spearman_correlations) ## SJCa SJCh DA ## SJCa 1.0000000 0.2727828 0.3148168 ## SJCh 0.2727828 1.0000000 0.2340174 ## DA 0.3148168 0.2340174 1.0000000 If we need p values though, we need to change to something else  corr.test my_results &lt;- corr.test(my_df$SJCa,my_df$DA) Then we can pull out results from this list or print it. Lets do both. print(my_results,short=FALSE) ## Call:corr.test(x = my_df$SJCa, y = my_df$DA) ## Correlation matrix ## [1] 0.33 ## Sample Size ## [1] 1852 ## Probability values adjusted for multiple tests. ## [1] 0 ## ## Confidence intervals based upon normal theory. To get bootstrapped values, try cor.ci ## raw.lower raw.r raw.upper raw.p lower.adj upper.adj ## NA-NA 0.29 0.33 0.37 0 0.29 0.37 my_results$r # correlation coefficient ## [1] 0.3342276 my_results$p # p-value ## [1] 1.433637e-49 Visually, we should be able to see this on a scatterplot. We are going to use qplot which stands for quickplot from within ggplot. It is useful and quicker for simple plotting than building up ggplot (though from the same package) we need to jitter my points (take geom=jitter out if you want to see why) qplot(SJCa,DA,data=my_df,geom=&quot;jitter&quot;) qqnorm(my_df$SJCa, frame = FALSE) qqline(my_df$SJCa, col = &quot;steelblue&quot;, lwd = 1.5) my_df %&gt;% ggplot(aes(x = SJCa)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Other functions we used today in class were describe() and also the q-q plot creation to investigate normality assumption copying syntax from the Field, Miles, &amp; Field book "],["week-5-simple-regression.html", "Chapter5 Week 5: Simple Regression 5.1 General Modeling Philosophy 5.2 Data generation demo - one set sample size 5.3 Data generation demo - one set sample size; 5.4 Data generation with three different sample sizes", " Chapter5 Week 5: Simple Regression require(tidyverse) require(psych) require(kableExtra) ## Loading required package: kableExtra ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows library(broom) This week we will start learning about linear regression. In particular, we focus on simple regression. These kinds of models involve one predictor variable and one continuous outcome variable. Next week we will move to models with multiple regression, which involves - you guessed it - multiple predictor variables. 5.1 General Modeling Philosophy The general approach is to model the outcome variable as a function of some predictor(s) plus an error term. Mathematically, this looks like: \\(outcome_i = model + error_i\\) where the \\(i\\) subscript refers to the \\(i^{th}\\) person in the sample. 5.1.0.1 Review of the normal distribution and standardizing variables Just to review, lets think about normally distributed variables and the notion of centering and standardizing. First, we will generate some data by drawing n random numbers from a normal distribution with a mean and standard deviation that we will specify. mean &lt;- 5 sd &lt;- 3 n &lt;- 1000 random_x &lt;- rnorm(n = n, mean = mean, sd = sd) We can then visualize those numbers hist(random_x) Now if we subtract the mean and plot the histogram, notice how the values have all basically shifted to the left along the x-axis. sample_mean &lt;- mean(random_x) centered_x &lt;- random_x - sample_mean hist(centered_x) Finally, we can divide by the sample standard deviation, which should have the effect of either stretching or squishing the values along the x-axis (without changing their mean). Pay attention again to the values along the x-axis. sample_sd &lt;- sd(random_x) standardized_x &lt;- centered_x / sample_sd hist(standardized_x) This final plot should remind you have the standard normal plot (with mean 0 and standard deviation 1). This is noted as \\(x \\sim \\mathcal{N}(0, 1)\\) and is read as x is distributed according to a normal distribution with a mean of 0 and variance of 1. 5.2 Data generation demo - one set sample size The following is a demo from class, found in the week_5_demo.R file #store the sample size that we want to use samp_size &lt;- 100 # uniformly sample X values (values for our predictor variable) from 0 to 20 x &lt;- round(runif(n = samp_size, min = 0, max = 30), digits = 1) # this gives samp_size number of random numbers Store the noise values for our different test models sd_min &lt;- 2 # low noise sd_med &lt;- 6 # medium noise sd_max &lt;- 12 # high noise Generate the outcome variable values under different amounts of noise (the rnorm() function is what is generating noise here) y_noise_sd_none &lt;- 3 + 2*x # this is the true relationship without any noise y_noise_sd_min &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_min), digits = 1) y_noise_sd_med &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_med), digits = 1) y_noise_sd_max &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_max), digits = 1) Typical step 1: visualize! Lets plot each of these x values vs y plot(x, y_noise_sd_none) plot(x, y_noise_sd_min) plot(x, y_noise_sd_med) plot(x, y_noise_sd_max) Lets put all of these vectors together into a data frame to make it easier to analyze later on Note, this is not a vital step for conducting the simple regression demo_df &lt;- tibble(&quot;x&quot; = x, &quot;y_noise_sd_none&quot;=y_noise_sd_none, &quot;y_noise_sd_min&quot; = y_noise_sd_min, &quot;y_noise_sd_med&quot; = y_noise_sd_med, &quot;y_noise_sd_max&quot; = y_noise_sd_max) Check out what demo_df looks like head(demo_df) ## # A tibble: 6 x 5 ## x y_noise_sd_none y_noise_sd_min y_noise_sd_med y_noise_sd_max ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 29 61 62 57.5 65.2 ## 2 21.2 45.4 45.7 44.7 49 ## 3 27.3 57.6 58.5 60 67.5 ## 4 19.4 41.8 43 52 41.3 ## 5 4.7 12.4 14 7.1 8.4 ## 6 24.1 51.2 50.2 54.7 42.8 Order by increasing x value demo_df &lt;- demo_df %&gt;% arrange(x) Check out what the arrange() function did head(demo_df) ## # A tibble: 6 x 5 ## x y_noise_sd_none y_noise_sd_min y_noise_sd_med y_noise_sd_max ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.2 3.4 1.30 6.9 -2.1 ## 2 0.4 3.8 2.8 13.1 -25.3 ## 3 0.6 4.2 6.5 0.4 -2.40 ## 4 0.8 4.6 6.40 -10.2 -6.4 ## 5 1.8 6.6 9.1 5.8 17.9 ## 6 2.1 7.2 7.1 0.7 4.4 Lets make this a long df so that we can plot multiple standard deviation values together demo_df_long &lt;- demo_df %&gt;% pivot_longer(cols = starts_with(&quot;y_noise&quot;), names_to = &quot;y_col&quot;, values_to = &quot;y_val&quot; ) Again, check on what this did head(demo_df_long) ## # A tibble: 6 x 3 ## x y_col y_val ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 0.2 y_noise_sd_none 3.4 ## 2 0.2 y_noise_sd_min 1.30 ## 3 0.2 y_noise_sd_med 6.9 ## 4 0.2 y_noise_sd_max -2.1 ## 5 0.4 y_noise_sd_none 3.8 ## 6 0.4 y_noise_sd_min 2.8 Lets add in a column to note whether the value is from the min, med, max, or zero sd (noise) model demo_df_long &lt;- demo_df_long %&gt;% mutate(sd_val = case_when(str_detect(y_col, &quot;sd_none&quot;) ~ 0, str_detect(y_col, &quot;sd_min&quot;) ~ sd_min, str_detect(y_col, &quot;sd_med&quot;) ~ sd_med, str_detect(y_col, &quot;sd_max&quot;) ~ sd_max)) Use facet_grid to separate the plots out by demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + facet_grid(.~y_col) You can also automatically add in a line with the geom_smooth() function demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_grid(.~y_col) ## `geom_smooth()` using formula &#39;y ~ x&#39; Now we can create a linear model for the data with minimum noise with the following command: fit_demo_min &lt;- lm(y_noise_sd_min ~ x) and we can look at the summary of the model with: summary(fit_demo_min) ## ## Call: ## lm(formula = y_noise_sd_min ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.0057 -1.3448 0.1622 1.2096 6.6062 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.53110 0.38830 9.094 1.12e-14 *** ## x 1.97015 0.02146 91.817 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.939 on 98 degrees of freedom ## Multiple R-squared: 0.9885, Adjusted R-squared: 0.9884 ## F-statistic: 8430 on 1 and 98 DF, p-value: &lt; 2.2e-16 We can also look at model results with the glance() function from the broom package broom::glance(fit_demo_min) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.989 0.988 1.94 8430. 7.34e-97 1 -207. 420. 428. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; We can create models for the med and max sd values as well and take a look at those with the summary() function once again fit_demo_med &lt;- lm(y_noise_sd_med ~ x) summary(fit_demo_med) ## ## Call: ## lm(formula = y_noise_sd_med ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -13.7315 -4.2604 0.2584 3.6923 15.7582 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.88191 1.25616 1.498 0.137 ## x 2.06200 0.06941 29.706 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.271 on 98 degrees of freedom ## Multiple R-squared: 0.9, Adjusted R-squared: 0.899 ## F-statistic: 882.4 on 1 and 98 DF, p-value: &lt; 2.2e-16 fit_demo_max &lt;- lm(y_noise_sd_max ~ x) summary(fit_demo_max) ## ## Call: ## lm(formula = y_noise_sd_max ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -24.0816 -7.0662 0.1627 7.9164 25.9929 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2.6282 2.2549 -1.166 0.247 ## x 2.1716 0.1246 17.428 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.26 on 98 degrees of freedom ## Multiple R-squared: 0.7561, Adjusted R-squared: 0.7536 ## F-statistic: 303.7 on 1 and 98 DF, p-value: &lt; 2.2e-16 Notice the increase in the standard error of the coefficient estimates as the noise in y values went up From a programming perspective, this was not very efficient because I just copied, pasted, and corrected these values. There is a better way to do this using lists (see below) Lets do some fancy stuff to make multiple models at once rather than having to write new lines for each model *Some of these ideas are taken from the R4DS book chapter 25 test_nest &lt;- demo_df_long %&gt;% nest(data = -sd_val) linear_model &lt;- function(df) { lm(y_val ~ x, data = df) } models &lt;- map(test_nest$data, linear_model) summary(models[[2]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.0057 -1.3448 0.1622 1.2096 6.6062 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.53110 0.38830 9.094 1.12e-14 *** ## x 1.97015 0.02146 91.817 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.939 on 98 degrees of freedom ## Multiple R-squared: 0.9885, Adjusted R-squared: 0.9884 ## F-statistic: 8430 on 1 and 98 DF, p-value: &lt; 2.2e-16 summary(models[[3]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -13.7315 -4.2604 0.2584 3.6923 15.7582 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.88191 1.25616 1.498 0.137 ## x 2.06200 0.06941 29.706 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.271 on 98 degrees of freedom ## Multiple R-squared: 0.9, Adjusted R-squared: 0.899 ## F-statistic: 882.4 on 1 and 98 DF, p-value: &lt; 2.2e-16 summary(models[[4]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -24.0816 -7.0662 0.1627 7.9164 25.9929 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2.6282 2.2549 -1.166 0.247 ## x 2.1716 0.1246 17.428 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.26 on 98 degrees of freedom ## Multiple R-squared: 0.7561, Adjusted R-squared: 0.7536 ## F-statistic: 303.7 on 1 and 98 DF, p-value: &lt; 2.2e-16 We can also store the models as new columns in the nested dataframe test_nest &lt;- test_nest %&gt;% mutate(model = map(data, linear_model)) Finally, we can unnest the models to make it easier to compare them with each other in a data frame test_nest &lt;- test_nest %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable 5.3 Data generation demo - one set sample size; The change from the past demo is that we are now sampling from integer values rather than continuous for the predictor Store the sample size that we want to use samp_size &lt;- 200 Instead of sampling uniformly from 0 to 20, this is to sample integers from 40 to 100 uniformly. We take samp_size number of samples. Replace = TRUE means we can get the same x value multiple times x &lt;- sample(x = c(60:100), size = samp_size, replace = TRUE) As before, store the noise values for our different test models sd_min &lt;- 2 sd_med &lt;- 6 sd_max &lt;- 12 y_noise_sd_none &lt;- 3 + 2*x y_noise_sd_min &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_min), digits = 1) y_noise_sd_med &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_med), digits = 1) y_noise_sd_max &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_max), digits = 1) Typical step 1: visualize! Lets plot each of these x values vs y plot(x, y_noise_sd_none) plot(x, y_noise_sd_min) plot(x, y_noise_sd_med) plot(x, y_noise_sd_max) Lets put all of these vectors together into a data frame to make it easier to analyze later on. Note, this is not a vital step for conducting the simple regression demo_df &lt;- tibble(&quot;x&quot; = x, &quot;y_noise_sd_none&quot;=y_noise_sd_none, &quot;y_noise_sd_min&quot; = y_noise_sd_min, &quot;y_noise_sd_med&quot; = y_noise_sd_med, &quot;y_noise_sd_max&quot; = y_noise_sd_max) Order by increasing x value demo_df &lt;- demo_df %&gt;% arrange(x) Lets make this a long df so that we can plot multiple standard deviation values together demo_df_long &lt;- demo_df %&gt;% pivot_longer(cols = starts_with(&quot;y_noise&quot;), names_to = &quot;y_col&quot;, values_to = &quot;y_val&quot; ) demo_df_long &lt;- demo_df_long %&gt;% mutate(sd_val = case_when(str_detect(y_col, &quot;sd_none&quot;) ~ 0, str_detect(y_col, &quot;sd_min&quot;) ~ sd_min, str_detect(y_col, &quot;sd_med&quot;) ~ sd_med, str_detect(y_col, &quot;sd_max&quot;) ~ sd_max)) And visualize the data, faceting by different noise demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + facet_grid(.~y_col) And add in a line with geom_smooth(method = 'lm') demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_grid(.~y_col) ## `geom_smooth()` using formula &#39;y ~ x&#39; Create a linear model and look at the summary. fit_demo_min &lt;- lm(y_noise_sd_min ~ x) summary(fit_demo_min) ## ## Call: ## lm(formula = y_noise_sd_min ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.3548 -1.3510 0.0377 1.2604 5.8356 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.09148 0.92251 3.351 0.000964 *** ## x 1.99958 0.01138 175.744 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.89 on 198 degrees of freedom ## Multiple R-squared: 0.9936, Adjusted R-squared: 0.9936 ## F-statistic: 3.089e+04 on 1 and 198 DF, p-value: &lt; 2.2e-16 We can also look at model results with the glance() function from the broom package broom::glance(fit_demo_min) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.994 0.994 1.89 30886. 2.31e-219 1 -410. 826. 836. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; We can create models for the med and max sd values as well and take a look at those with the summary() function once again. fit_demo_med &lt;- lm(y_noise_sd_med ~ x) summary(fit_demo_med) ## ## Call: ## lm(formula = y_noise_sd_med ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -17.1563 -4.2476 -0.3413 4.5547 21.1413 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.6991 3.2030 1.155 0.25 ## x 1.9788 0.0395 50.089 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.561 on 198 degrees of freedom ## Multiple R-squared: 0.9269, Adjusted R-squared: 0.9265 ## F-statistic: 2509 on 1 and 198 DF, p-value: &lt; 2.2e-16 fit_demo_max &lt;- lm(y_noise_sd_max ~ x) summary(fit_demo_max) ## ## Call: ## lm(formula = y_noise_sd_max ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -31.868 -7.032 0.055 7.526 29.460 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.01522 5.36822 0.003 0.998 ## x 2.03924 0.06621 30.800 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11 on 198 degrees of freedom ## Multiple R-squared: 0.8273, Adjusted R-squared: 0.8264 ## F-statistic: 948.6 on 1 and 198 DF, p-value: &lt; 2.2e-16 Notice the increase in the standard error of the coefficient estimates as the noise in y values went up From a programming perspective, this was not very efficient because I just copied, pasted, and corrected these values. There is a better way to do this using lists (see below) Lets do some fancy stuff to make multiple models at once rather than having to write new lines for each model *Some of these ideas are taken from the R4DS book chapter 25 test_nest &lt;- demo_df_long %&gt;% nest(data = -sd_val) linear_model &lt;- function(df) { lm(y_val ~ x, data = df) } models &lt;- map(test_nest$data, linear_model) summary(models[[2]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.3548 -1.3510 0.0377 1.2604 5.8356 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.09148 0.92251 3.351 0.000964 *** ## x 1.99958 0.01138 175.744 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.89 on 198 degrees of freedom ## Multiple R-squared: 0.9936, Adjusted R-squared: 0.9936 ## F-statistic: 3.089e+04 on 1 and 198 DF, p-value: &lt; 2.2e-16 summary(models[[3]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -17.1563 -4.2476 -0.3413 4.5547 21.1413 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.6991 3.2030 1.155 0.25 ## x 1.9788 0.0395 50.089 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.561 on 198 degrees of freedom ## Multiple R-squared: 0.9269, Adjusted R-squared: 0.9265 ## F-statistic: 2509 on 1 and 198 DF, p-value: &lt; 2.2e-16 summary(models[[4]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -31.868 -7.032 0.055 7.526 29.460 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.01522 5.36822 0.003 0.998 ## x 2.03924 0.06621 30.800 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11 on 198 degrees of freedom ## Multiple R-squared: 0.8273, Adjusted R-squared: 0.8264 ## F-statistic: 948.6 on 1 and 198 DF, p-value: &lt; 2.2e-16 We can also store the models as new columns in the nested dataframe test_nest &lt;- test_nest %&gt;% mutate(model = map(data, linear_model)) Finally, we can unnest the models to make it easier to compare them with each other in a data frame test_nest &lt;- test_nest %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable 5.4 Data generation with three different sample sizes Lets run the same demo but now have three different sample sizes - 10, 50, and 500 First, store the sample sizes we want to use samp_sizes &lt;- c(10, 50, 500) Next, create a bookkeping column for ourselves to keep track of which sample size the future values will come from samp_size_col &lt;- rep(x = c(10,50, 500), times = samp_sizes) Calculate the total number of values we will need from the three samples combined tot_samp_size &lt;- sum(samp_sizes) Sample uniformly from 0 to 20 x &lt;- round(x = runif(n = tot_samp_size, min = 0, max = 20), digits = 1) Store the standard deviations for the min, med, and max models sd_min &lt;- 2 sd_med &lt;- 6 sd_max &lt;- 12 Calculate the y values for the different scenarios where there is no noise up to max noise y_noise_sd_none &lt;- 3 + 2*x y_noise_sd_min &lt;- 3 + 2*x + round(x = rnorm(n = tot_samp_size, mean = 0, sd = sd_min), digits = 1) y_noise_sd_med &lt;- 3 + 2*x + round(x = rnorm(n = tot_samp_size, mean = 0, sd = sd_med), digits = 1) y_noise_sd_max &lt;- 3 + 2*x + round(x = rnorm(n = tot_samp_size, mean = 0, sd = sd_max), digits = 1) Typical step 1: visualize! Lets plot each of these x values vs y plot(x, y_noise_sd_none) plot(x, y_noise_sd_min) plot(x, y_noise_sd_med) plot(x, y_noise_sd_max) Can we calculate the correlations between x and these different y values? (pro tip: yes) Lets put all of these vectors together into a data frame to make it easier to analyze later on Note, this is not a vital step for conducting the simple regression demo_df &lt;- tibble(&quot;n&quot; = samp_size_col, &quot;x&quot; = x, &quot;y_noise_sd_none&quot;=y_noise_sd_none, &quot;y_noise_sd_min&quot; = y_noise_sd_min, &quot;y_noise_sd_med&quot; = y_noise_sd_med, &quot;y_noise_sd_max&quot; = y_noise_sd_max) Order by increasing x value demo_df &lt;- demo_df %&gt;% arrange(n, x) Lets make this a long df so that we can plot multiple standard deviation values together demo_df_long &lt;- demo_df %&gt;% pivot_longer(cols = starts_with(&quot;y_noise&quot;), names_to = &quot;y_col&quot;, values_to = &quot;y_val&quot; ) demo_df_long &lt;- demo_df_long %&gt;% mutate(sd_val = case_when(str_detect(y_col, &quot;sd_none&quot;) ~ 0, str_detect(y_col, &quot;sd_min&quot;) ~ sd_min, str_detect(y_col, &quot;sd_med&quot;) ~ sd_med, str_detect(y_col, &quot;sd_max&quot;) ~ sd_max)) demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + facet_grid(n~y_col) demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_grid(n~y_col) ## `geom_smooth()` using formula &#39;y ~ x&#39; fit_demo_min &lt;- lm(y_noise_sd_min ~ x) summary(fit_demo_min) ## ## Call: ## lm(formula = y_noise_sd_min ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.0266 -1.3792 -0.0061 1.3680 6.6633 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.99008 0.17455 17.13 &lt;2e-16 *** ## x 2.00457 0.01476 135.81 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.006 on 558 degrees of freedom ## Multiple R-squared: 0.9706, Adjusted R-squared: 0.9706 ## F-statistic: 1.844e+04 on 1 and 558 DF, p-value: &lt; 2.2e-16 We can also look at model results with the glance() function from the broom package broom::glance(fit_demo_min) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.971 0.971 2.01 18444. 0 1 -1183. 2373. 2386. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; We can create models for the med and max sd values as well and take a look at those with the summary() function once again fit_demo_med &lt;- lm(y_noise_sd_med ~ x) summary(fit_demo_med) ## ## Call: ## lm(formula = y_noise_sd_med ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -17.9254 -4.0436 -0.5753 4.1624 19.5173 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.43884 0.53719 6.401 3.27e-10 *** ## x 1.92867 0.04543 42.457 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.174 on 558 degrees of freedom ## Multiple R-squared: 0.7636, Adjusted R-squared: 0.7632 ## F-statistic: 1803 on 1 and 558 DF, p-value: &lt; 2.2e-16 fit_demo_max &lt;- lm(y_noise_sd_max ~ x) summary(fit_demo_max) ## ## Call: ## lm(formula = y_noise_sd_max ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -33.765 -7.846 -0.304 7.558 39.377 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.97259 1.02690 4.842 1.66e-06 *** ## x 1.85259 0.08684 21.334 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.8 on 558 degrees of freedom ## Multiple R-squared: 0.4492, Adjusted R-squared: 0.4483 ## F-statistic: 455.1 on 1 and 558 DF, p-value: &lt; 2.2e-16 Notice the increase in the standard error of the coefficient estimates as the noise in y values went up From a programming perspective, this was not very efficient because I just copied, pasted, and corrected these values. There is a better way to do this using lists (see below) Lets do some fancy stuff to make multiple models at once rather than having to write new lines for each model *Some of these ideas are taken from the R4DS book chapter 25 test_nest &lt;- demo_df_long %&gt;% nest(data = -c(sd_val, n)) linear_model &lt;- function(df) { lm(y_val ~ x, data = df) } models &lt;- map(test_nest$data, linear_model) summary(models[[2]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.2414 -0.5167 -0.0661 0.8284 3.5897 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.4615 1.4650 3.045 0.0159 * ## x 1.9347 0.1291 14.986 3.88e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.962 on 8 degrees of freedom ## Multiple R-squared: 0.9656, Adjusted R-squared: 0.9613 ## F-statistic: 224.6 on 1 and 8 DF, p-value: 3.882e-07 summary(models[[3]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -8.0529 -2.7771 0.3169 3.4370 6.4629 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.6539 3.6972 0.447 0.666506 ## x 1.7953 0.3258 5.510 0.000567 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.951 on 8 degrees of freedom ## Multiple R-squared: 0.7915, Adjusted R-squared: 0.7654 ## F-statistic: 30.36 on 1 and 8 DF, p-value: 0.0005669 summary(models[[4]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -8.7200 -3.6850 0.8948 2.8249 10.7632 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 12.6420 4.7214 2.678 0.0280 * ## x 1.2080 0.4161 2.903 0.0198 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.322 on 8 degrees of freedom ## Multiple R-squared: 0.5131, Adjusted R-squared: 0.4522 ## F-statistic: 8.429 on 1 and 8 DF, p-value: 0.01979 We can also store the models as new columns in the nested dataframe test_nest &lt;- test_nest %&gt;% mutate(model = map(data, linear_model)) Finally, we can unnest the models to make it easier to compare them with each other in a data frame test_nest &lt;- test_nest %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable And look at the different models by just calling the data frame test_nest ## # A tibble: 12 x 16 ## n sd_val data model r.squared adj.r.squared sigma statistic p.value ## &lt;dbl&gt; &lt;dbl&gt; &lt;lis&gt; &lt;lis&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10 0 &lt;tib~ &lt;lm&gt; 1 1 3.18e-15 9.15e31 1.60e-125 ## 2 10 2 &lt;tib~ &lt;lm&gt; 0.966 0.961 1.96e+ 0 2.25e 2 3.88e- 7 ## 3 10 6 &lt;tib~ &lt;lm&gt; 0.791 0.765 4.95e+ 0 3.04e 1 5.67e- 4 ## 4 10 12 &lt;tib~ &lt;lm&gt; 0.513 0.452 6.32e+ 0 8.43e 0 1.98e- 2 ## 5 50 0 &lt;tib~ &lt;lm&gt; 1 1 7.99e-15 9.99e31 0. ## 6 50 2 &lt;tib~ &lt;lm&gt; 0.975 0.975 1.87e+ 0 1.89e 3 3.38e- 40 ## 7 50 6 &lt;tib~ &lt;lm&gt; 0.724 0.718 7.07e+ 0 1.26e 2 5.11e- 15 ## 8 50 12 &lt;tib~ &lt;lm&gt; 0.570 0.561 1.15e+ 1 6.37e 1 2.35e- 10 ## 9 500 0 &lt;tib~ &lt;lm&gt; 1 1 3.50e-14 5.43e31 0. ## 10 500 2 &lt;tib~ &lt;lm&gt; 0.971 0.970 2.02e+ 0 1.64e 4 0. ## 11 500 6 &lt;tib~ &lt;lm&gt; 0.769 0.768 6.10e+ 0 1.65e 3 2.13e-160 ## 12 500 12 &lt;tib~ &lt;lm&gt; 0.438 0.437 1.19e+ 1 3.89e 2 2.32e- 64 ## # ... with 7 more variables: df &lt;dbl&gt;, logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, BIC &lt;dbl&gt;, ## # deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; "],["week-6-regression-ii.html", "Chapter6 Week 6: Regression II 6.1 Explore the child aggression data set 6.2 Multiple regression", " Chapter6 Week 6: Regression II This week we will be discussing multiple regression. We will use the child aggression data set as a running example for this. 6.1 Explore the child aggression data set ca_df &lt;- read.table(&quot;ChildAggression.dat&quot;, header = TRUE) Method 1 for quickly getting summary statistics for the data you have, using the built-in summary() function summary(ca_df) ## Aggression Television Computer_Games ## Min. :-1.295608 Min. :-1.46012 Min. :-1.1538345 ## 1st Qu.:-0.174279 1st Qu.:-0.18206 1st Qu.:-0.1687007 ## Median :-0.005548 Median :-0.01247 Median :-0.0001997 ## Mean :-0.005011 Mean :-0.02758 Mean : 0.0103812 ## 3rd Qu.: 0.149611 3rd Qu.: 0.14983 3rd Qu.: 0.1881810 ## Max. : 1.178823 Max. : 0.98162 Max. : 1.6175039 ## Sibling_Aggression Diet Parenting_Style ## Min. :-1.433127 Min. :-1.28490 Min. :-4.46041 ## 1st Qu.:-0.156414 1st Qu.:-0.16136 1st Qu.:-0.58008 ## Median : 0.008459 Median : 0.00934 Median : 0.02736 ## Mean : 0.008275 Mean : 0.01162 Mean : 0.00000 ## 3rd Qu.: 0.185136 3rd Qu.: 0.18708 3rd Qu.: 0.51784 ## Max. : 1.103671 Max. : 1.22383 Max. : 3.99326 Method 2, using the describe() function from the psych package psych::describe(ca_df) ## vars n mean sd median trimmed mad min max range ## Aggression 1 666 -0.01 0.32 -0.01 -0.01 0.24 -1.30 1.18 2.47 ## Television 2 666 -0.03 0.31 -0.01 -0.02 0.25 -1.46 0.98 2.44 ## Computer_Games 3 666 0.01 0.34 0.00 0.00 0.27 -1.15 1.62 2.77 ## Sibling_Aggression 4 666 0.01 0.33 0.01 0.01 0.26 -1.43 1.10 2.54 ## Diet 5 666 0.01 0.34 0.01 0.01 0.26 -1.28 1.22 2.51 ## Parenting_Style 6 666 0.00 1.00 0.03 0.01 0.82 -4.46 3.99 8.45 ## skew kurtosis se ## Aggression -0.02 1.61 0.01 ## Television -0.36 1.34 0.01 ## Computer_Games 0.25 1.60 0.01 ## Sibling_Aggression -0.17 1.40 0.01 ## Diet -0.12 1.51 0.01 ## Parenting_Style -0.22 1.67 0.04 Spot check: where do the se values come from? Now that we have seen some of the numbers, lets try to visualize some of these data. Lets try to visualize the data while were at it ca_df %&gt;% ggplot(aes(x = Aggression)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. We could do this for each of our variables or we could try something a little fancier by using the pivot_longer() function to make a longer dataframe and plot everything at once First, create the long dataframe. After running this command, its a good idea to view the new data frame to make sure this did what you intended ca_df_long &lt;- ca_df %&gt;% pivot_longer(cols = Aggression:Parenting_Style, names_to = &quot;variable_name&quot;, values_to = &quot;variable_value&quot;) After making sure everything looks in order, run the same plot command with the addition of a facet. Note that the fill = variable_name tells R to color the plot with different colors by variable_name and the theme() tells R to get rid of the legend that automatically shows up ca_df_long %&gt;% ggplot(aes(x = variable_value, fill = variable_name)) + geom_histogram() + facet_wrap(variable_name ~.) + theme(legend.position = &quot;none&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. From this we should be able to see that everything is normally distributed and appears to be standardized Lets try a different kind of visualization: the empirical cumulative distribution function (eCDF) (sounds fancy, but its not bad) ca_df_long %&gt;% ggplot(aes(x = variable_value)) + stat_ecdf(geom = &quot;point&quot;) + facet_wrap(variable_name ~.) It looks like a bunch of distorted s shapes. In order to understand what is going on here, we should take a brief detour into the world of cumulative distribution functions (CDFs), eCDFs, and eventually QQ plots. This detour is at the end of the markdown file. Now we can try a third way of visualizing our data - QQ plots! As before, we can plot each variable with separate calls or plot them all together with the long data frame ca_df %&gt;% ggplot(aes(sample=Aggression)) + stat_qq() + stat_qq_line() ca_df_long %&gt;% ggplot(aes(sample=variable_value)) + stat_qq() + stat_qq_line() + facet_wrap(variable_name ~ .) 6.2 Multiple regression Lets create a model of child aggression as a function of parenting style and sibling aggression model_fam &lt;- lm(Aggression ~ Parenting_Style + Sibling_Aggression, data = ca_df) Run the summary on the model summary(model_fam) ## ## Call: ## lm(formula = Aggression ~ Parenting_Style + Sibling_Aggression, ## data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.09755 -0.17180 0.00092 0.15405 1.23037 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.005784 0.012065 -0.479 0.632 ## Parenting_Style 0.061984 0.012257 5.057 5.51e-07 *** ## Sibling_Aggression 0.093409 0.037505 2.491 0.013 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3113 on 663 degrees of freedom ## Multiple R-squared: 0.05325, Adjusted R-squared: 0.05039 ## F-statistic: 18.64 on 2 and 663 DF, p-value: 1.325e-08 This will be helpful later when we want to plot the residuals of the model. Lets create another model of child aggression as a function of computer games and television. model_screens &lt;- lm(Aggression ~ Computer_Games + Television, data = ca_df) summary(model_screens) ## ## Call: ## lm(formula = Aggression ~ Computer_Games + Television, data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.05234 -0.15191 -0.00512 0.15156 1.24062 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.002879 0.012132 -0.237 0.812526 ## Computer_Games 0.153874 0.035845 4.293 2.03e-05 *** ## Television 0.135263 0.039546 3.420 0.000664 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3115 on 663 degrees of freedom ## Multiple R-squared: 0.05149, Adjusted R-squared: 0.04862 ## F-statistic: 17.99 on 2 and 663 DF, p-value: 2.455e-08 Now lets see what the full model looks like with all five predictors model_all &lt;- lm(Aggression ~ Parenting_Style + Sibling_Aggression + Diet + Computer_Games + Television, data = ca_df) summary(model_all) ## ## Call: ## lm(formula = Aggression ~ Parenting_Style + Sibling_Aggression + ## Diet + Computer_Games + Television, data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.12629 -0.15253 -0.00421 0.15222 1.17669 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.004988 0.011983 -0.416 0.677350 ## Parenting_Style 0.056648 0.014557 3.891 0.000110 *** ## Sibling_Aggression 0.081684 0.038780 2.106 0.035550 * ## Diet -0.109054 0.038076 -2.864 0.004315 ** ## Computer_Games 0.142161 0.036920 3.851 0.000129 *** ## Television 0.032916 0.046057 0.715 0.475059 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3071 on 660 degrees of freedom ## Multiple R-squared: 0.08258, Adjusted R-squared: 0.07563 ## F-statistic: 11.88 on 5 and 660 DF, p-value: 5.025e-11 We can get the output from the summary() function but as a tibble instead: broom::tidy(model_all, conf.int = TRUE) ## # A tibble: 6 x 7 ## term estimate std.error statistic p.value conf.low conf.high ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -0.00499 0.0120 -0.416 0.677 -0.0285 0.0185 ## 2 Parenting_Style 0.0566 0.0146 3.89 0.000110 0.0281 0.0852 ## 3 Sibling_Aggression 0.0817 0.0388 2.11 0.0355 0.00554 0.158 ## 4 Diet -0.109 0.0381 -2.86 0.00432 -0.184 -0.0343 ## 5 Computer_Games 0.142 0.0369 3.85 0.000129 0.0697 0.215 ## 6 Television 0.0329 0.0461 0.715 0.475 -0.0575 0.123 We can also get summary statistics like the R^2, F-statistics, and AIC from the glance() function in the Broom package broom::glance(model_all) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.0826 0.0756 0.307 11.9 5.02e-11 5 -156. 325. 357. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; Lets stop here to interpret what the model output is telling us(specifically, the coefficient estimates, the standard errors, the p values, and the R^2 values). Notice the Television p value and standard errors (especially how the estimate is so close to zero, and its 95% confidence interval crosses 0) We can also have R handle factors automatically in a regression model for us. First, we will generate a new factor for the child aggression data - the handedness of the child (left vs right). This code generates a random handedness for each of the 666 students and assigns it to a new column in ca_df handed_levels &lt;- c(&quot;left&quot;, &quot;right&quot;) handed_vector &lt;- sample(handed_levels, size = nrow(ca_df), replace = TRUE, prob = c(0.4, 0.6)) ca_df$Handedness &lt;- handed_vector Check to make sure we have all the predictor names correct to add into the linear model. names(ca_df) ## [1] &quot;Aggression&quot; &quot;Television&quot; &quot;Computer_Games&quot; ## [4] &quot;Sibling_Aggression&quot; &quot;Diet&quot; &quot;Parenting_Style&quot; ## [7] &quot;Handedness&quot; model_all_3 &lt;- lm(Aggression ~ Parenting_Style + Sibling_Aggression + Television + Computer_Games + Diet + Handedness, data = ca_df) Check the model summary and notice how the Handedness predictor variable was handled. summary(model_all_3) ## ## Call: ## lm(formula = Aggression ~ Parenting_Style + Sibling_Aggression + ## Television + Computer_Games + Diet + Handedness, data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.1223 -0.1536 -0.0040 0.1495 1.1798 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0003317 0.0187949 0.018 0.985926 ## Parenting_Style 0.0562165 0.0146137 3.847 0.000131 *** ## Sibling_Aggression 0.0814332 0.0388111 2.098 0.036268 * ## Television 0.0337678 0.0461457 0.732 0.464572 ## Computer_Games 0.1430242 0.0370183 3.864 0.000123 *** ## Diet -0.1094837 0.0381193 -2.872 0.004208 ** ## Handednessright -0.0089557 0.0243655 -0.368 0.713323 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3073 on 659 degrees of freedom ## Multiple R-squared: 0.08277, Adjusted R-squared: 0.07442 ## F-statistic: 9.911 on 6 and 659 DF, p-value: 1.739e-10 lm(Aggression ~ ., data=ca_df) ## ## Call: ## lm(formula = Aggression ~ ., data = ca_df) ## ## Coefficients: ## (Intercept) Television Computer_Games Sibling_Aggression ## 0.0003317 0.0337678 0.1430242 0.0814332 ## Diet Parenting_Style Handednessright ## -0.1094837 0.0562165 -0.0089557 6.2.1 Assumption testing Note: A lot of the things we are doing here can be accomplished with the augment() function in the broom package Check for correlation between adjacent residual terms using Durbin-Watson test dwt(model_all) ## lag Autocorrelation D-W Statistic p-value ## 1 0.04218005 1.912808 0.236 ## Alternative hypothesis: rho != 0 Check for multicollinearity. car::vif(model_all) ## Parenting_Style Sibling_Aggression Diet Computer_Games ## 1.494296 1.132618 1.160466 1.122719 ## Television ## 1.435525 Now lets go back and check for influential cases following the procedure Field does in the textbook. ca_df$residuals &lt;- resid(model_all) # notice how this is the same as looking at View(model_all) and then residuals or model_all$residuals #model_all$residuals ca_df$standardized.residuals &lt;- rstandard(model_all) ca_df$studentized.residuals &lt;- rstudent(model_all) ca_df$cooks.distance &lt;- cooks.distance(model_all) ca_df$dfbeta &lt;- dfbeta(model_all) ca_df$dffit &lt;- dffits(model_all) ca_df$leverage &lt;- hatvalues(model_all) ca_df$covariance.ratios &lt;- covratio(model_all) Now that we have all of the extra model fit statistics calculated, we can add a new olumn using a different method than what he does in the textbook (but this accomplishes the same task). We are using a combination of mutate() and case_when() instead of the traditional logical test subsetting that we see in the bookon pp. 289-290 ca_df &lt;- ca_df %&gt;% mutate(large.residual = case_when(standardized.residuals &gt; 2 | standardized.residuals &lt; -2 ~ TRUE, abs(standardized.residuals) &lt;= 2 ~ FALSE)) Now lets just look at the observations where there was a large residual (absolute value &gt; 2) ca_df %&gt;% filter(large.residual == TRUE) %&gt;% head() ## Aggression Television Computer_Games Sibling_Aggression Diet ## 1 0.7711534 -0.03287184 0.70991822 0.576836667 -0.0229903 ## 2 -0.9309839 -0.14695730 0.58503832 0.143914123 0.1341567 ## 3 0.8437696 -0.53337187 0.62674291 0.006193792 -0.0542531 ## 4 -0.8604237 -0.32734996 -0.10228524 0.088454410 0.3403472 ## 5 0.7374707 0.05104538 0.06804261 0.742478946 0.3607529 ## 6 0.6158280 -0.17945254 -0.14381635 0.337002793 -0.5992525 ## Parenting_Style Handedness residuals standardized.residuals ## 1 -1.2481665 left 0.6973813 2.289855 ## 2 -1.0470961 right -0.9421375 -3.081966 ## 3 0.2386578 right 0.7572738 2.484122 ## 4 -0.6988965 left -0.7606374 -2.483667 ## 5 0.9243197 right 0.6574374 2.152417 ## 6 -1.0334894 right 0.6128345 2.006389 ## studentized.residuals cooks.distance dfbeta.(Intercept) ## 1 2.297263 0.014610960 0.0010048327 ## 2 -3.102033 0.014474124 -0.0013336489 ## 3 2.493925 0.015185553 0.0008375093 ## 4 -2.493465 0.005595170 -0.0010247662 ## 5 2.158374 0.008347004 0.0008799517 ## 6 2.011011 0.007252602 0.0009296294 ## dfbeta.Parenting_Style dfbeta.Sibling_Aggression dfbeta.Diet ## 1 -0.0022102310 0.0053377408 -0.0015602060 ## 2 0.0022877988 -0.0008058492 -0.0011872151 ## 3 0.0016068696 0.0002508274 -0.0028943101 ## 4 0.0006636867 -0.0011984511 -0.0042173119 ## 5 0.0008756410 0.0069052922 0.0014075292 ## 6 -0.0005401040 0.0047888699 -0.0054530647 ## dfbeta.Computer_Games dfbeta.Television dffit leverage ## 1 0.0067966200 0.0013345865 0.2970419 0.016444209 ## 2 -0.0079629954 -0.0003344591 -0.2966131 0.009060145 ## 3 0.0072143563 -0.0098994502 0.3030411 0.014550253 ## 4 0.0015183740 0.0029152017 -0.1839467 0.005412783 ## 5 -0.0015476206 -0.0021915865 0.2244095 0.010694476 ## 6 -0.0004611714 -0.0010521222 0.2090845 0.010694131 ## covariance.ratios large.residual ## 1 0.9780649 TRUE ## 2 0.9335336 TRUE ## 3 0.9679182 TRUE ## 4 0.9590456 TRUE ## 5 0.9778335 TRUE ## 6 0.9832825 TRUE Theres a problem here because we dont preserve observation numbers. In general, it might be a good idea to give each observation an ID with something like dim(ca_df)[1] ## [1] 666 ca_df &lt;- ca_df %&gt;% mutate(ID = seq(1:dim(ca_df)[1])) In the tidyverse, there is an even simpler way to do this with the rowid_to_column() function! ca_df &lt;- ca_df %&gt;% rowid_to_column(var = &quot;participant_id&quot;) Now we can run the filter again and see which observations have large residuals ca_df %&gt;% filter(large.residual == TRUE) %&gt;% view() Plot the residuals against the fitted values ca_df$fitted &lt;- model_all$fitted.values First, plot the distribution of the residuals by themselves histogram &lt;- ca_df %&gt;% ggplot(aes(x = studentized.residuals)) + geom_histogram(aes(y = ..density..)) + labs(x = &quot;Studentized Residuals&quot;, y = &quot;Density&quot;) histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Now lets add a normal density on top of that for comparison histogram + stat_function(fun = dnorm, args = list(mean = mean(ca_df$studentized.residuals, na.rm = TRUE), sd = sd(ca_df$studentized.residuals, na.rm = TRUE)), color = &quot;blue&quot;, size = 1) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Second, plot the residuals against the fitted values to make sure there are no systematic patterns ca_df %&gt;% ggplot(aes(x = fitted, y = studentized.residuals)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + labs(x = &quot;Fitted Residual&quot;, y = &quot;Studentized Residual&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; We can also skip all the fancy code from the book and use the plot() function on the model. R knows that this means we want to plot four fit plots par(mfrow=c(2,2)) # this changes the arrangement for the plots to show two rows and two columns of plots plot(model_all) par(mfrow=c(1,1)) # this changes the plotting arrangement back to the default of one plot at a time Note that we could also create a model that uses all our covariates as predictors with the following call model_all_2 &lt;- lm(Aggression ~ ., data=ca_df) Inspect the results to make sure it is giving the same results as before plot(model_all_2) summary(model_all_2) ## Warning in summary.lm(model_all_2): essentially perfect fit: summary may be ## unreliable ## ## Call: ## lm(formula = Aggression ~ ., data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.287e-15 -3.000e-17 5.500e-18 3.940e-17 5.010e-15 ## ## Coefficients: (2 not defined because of singularities) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.988e-03 1.526e-15 -3.269e+12 &lt; 2e-16 *** ## participant_id 3.942e-19 5.795e-20 6.802e+00 2.35e-11 *** ## Television 3.292e-02 4.325e-17 7.610e+14 &lt; 2e-16 *** ## Computer_Games 1.422e-01 3.476e-17 4.090e+15 &lt; 2e-16 *** ## Sibling_Aggression 8.168e-02 3.636e-17 2.247e+15 &lt; 2e-16 *** ## Diet -1.091e-01 3.592e-17 -3.036e+15 &lt; 2e-16 *** ## Parenting_Style 5.665e-02 1.371e-17 4.132e+15 &lt; 2e-16 *** ## Handednessright -2.311e-17 2.266e-17 -1.020e+00 0.308 ## residuals 1.000e+00 2.920e-12 3.424e+11 &lt; 2e-16 *** ## standardized.residuals 1.027e-12 1.746e-12 5.880e-01 0.557 ## studentized.residuals -5.539e-16 4.211e-15 -1.320e-01 0.895 ## cooks.distance 4.188e-15 3.962e-15 1.057e+00 0.291 ## dfbeta(Intercept) -1.074e-09 1.842e-09 -5.830e-01 0.560 ## dfbetaParenting_Style 2.896e-14 2.120e-14 1.366e+00 0.172 ## dfbetaSibling_Aggression -8.907e-12 1.524e-11 -5.840e-01 0.559 ## dfbetaDiet -1.248e-11 2.140e-11 -5.830e-01 0.560 ## dfbetaComputer_Games -1.116e-11 1.912e-11 -5.840e-01 0.560 ## dfbetaTelevision 2.963e-11 5.079e-11 5.830e-01 0.560 ## dffit -2.272e-15 3.951e-15 -5.750e-01 0.565 ## leverage -3.102e-15 2.493e-15 -1.244e+00 0.214 ## covariance.ratios 2.302e-16 1.520e-15 1.510e-01 0.880 ## large.residualTRUE -8.634e-17 8.636e-17 -1.000e+00 0.318 ## ID NA NA NA NA ## fitted NA NA NA NA ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.831e-16 on 644 degrees of freedom ## Multiple R-squared: 1, Adjusted R-squared: 1 ## F-statistic: 4.03e+31 on 21 and 644 DF, p-value: &lt; 2.2e-16 Check how augment() works and which parts of the above it replicates augmented_model_all &lt;- augment(model_all) ca_df_long %&gt;% ggplot(aes(x = variable_value, fill = variable_name)) + geom_histogram(position = &quot;identity&quot;, alpha = 0.5) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 6.2.2 Detour: Cumulative Distribution Function (CDF), empirical CDF, and QQ Plot Discussion Our goal here is to visualize the cumulative distribution function for a normal distribution as a stepping stone toward undestanding QQ plots. We will use plots of the empirical cumulative distribution function (eCDF) As a way to visualize our data. Although we have not discussed eCDFs before, they are another tool you can use to visualize the distribution of quantitative data. We will also look at the effect of sample size on the kinds of plots that we may make when visualizing the distribution of data. First, lets generate some data to help us see what these concepts are all about. Note that We are generating data to make things easier on ourselves - we know the underlying data-generating process. So that lets us form an expectation of what should happen. These kinds of toy examples can be helpful for building an intuition about these concepts that we can then use in our own work. df_1 &lt;- tibble(x = round(rnorm(n = 25, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 25, times = 25)) df_2 &lt;- tibble(x = round(rnorm(n = 50, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 50, times = 50)) df_3 &lt;- tibble(x = round(rnorm(n = 100, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 100, times = 100)) df_4 &lt;- tibble(x = round(rnorm(n = 200, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 200, times = 200)) df_5 &lt;- tibble(x = round(rnorm(n = 500, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 500, times = 500)) Combine the generated data together into one data frame to make it easy to plot everything in one ggplot call. sample_df &lt;- bind_rows(df_1, df_2, df_3, df_4, df_5) Look at the empirical CDFs sample_df %&gt;% ggplot(aes(x)) + stat_ecdf(geom = &quot;point&quot;) + facet_grid(samp_size~.) sample_df %&gt;% ggplot(aes(x)) + geom_histogram() + facet_grid(samp_size~.) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. In class, this should lead to a discussion about how to find quantiles now lets try to look at some QQ plots. df_1 %&gt;% ggplot(aes(sample=x)) + stat_qq() + stat_qq_line() Lets try to wrap our heads around what is going on by looking at sorted versions of df_1 values head(df_1 %&gt;% arrange(x)) ## # A tibble: 6 x 2 ## x samp_size ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -2.3 25 ## 2 -1.7 25 ## 3 -1.2 25 ## 4 -0.9 25 ## 5 -0.8 25 ## 6 -0.8 25 Lets also look at the other end of the dataframe. We can do this either using arrange(desc(x)) or tail instead of head Confirm that theyre basically two ways of accomplishing the same objective. head(df_1 %&gt;% arrange(desc(x))) ## # A tibble: 6 x 2 ## x samp_size ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2.2 25 ## 2 1.1 25 ## 3 1 25 ## 4 1 25 ## 5 0.9 25 ## 6 0.7 25 tail(df_1 %&gt;% arrange(x)) ## # A tibble: 6 x 2 ## x samp_size ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.7 25 ## 2 0.9 25 ## 3 1 25 ## 4 1 25 ## 5 1.1 25 ## 6 2.2 25 End detour 6.2.3 Generating data for student happiness exercise. We are going to student happiness scores on a scale from 0 to 100 as a function of their time spent outdoors, time spent on Zoom, class standing, and department. pop_size &lt;- 5000 sample_size &lt;- 200 pop_df &lt;- tibble(standing = rep(c(&quot;undergrad&quot;, &quot;masters&quot;, &quot;phd&quot;), times = c(pop_size/2, pop_size/4, pop_size/4))) pop_df$discipline &lt;- rep(c(&quot;mechanical&quot;, &quot;civil&quot;, &quot;electrical&quot;), length.out = pop_size) pop_df$min_outdoors &lt;- round(runif(n = pop_size, min = 0, max = 300), 0) pop_df$min_zoom &lt;- round(runif(n = pop_size, min = 0, max = 400), 0) pop_df &lt;- pop_df %&gt;% mutate(undergrad = case_when(standing == &quot;undergrad&quot; ~ 1, TRUE ~ 0), masters = case_when(standing == &quot;masters&quot; ~ 1, TRUE ~ 0), phd = case_when(standing == &quot;phd&quot; ~ 1, TRUE ~ 0), civil = case_when(discipline == &quot;civil&quot; ~ 1, TRUE ~ 0), mechanical = case_when(discipline == &quot;mechanical&quot; ~ 1, TRUE ~ 0), electrical = case_when(discipline == &quot;electrical&quot; ~ 1, TRUE ~ 0)) With the predictors generated, we can now generate the happiness scores. #pop_df &lt;- pop_df %&gt;% # mutate(happiness = 50 + -.2*(min_zoom+runif(n = 1, min = 10, max = 30)) + .1 * min_outdoors + 4*civil -.3 * mechanical) b_0 &lt;- 50 b_out &lt;- 0.03 b_zoom &lt;- -0.05 b_civ &lt;- 6 b_mech &lt;- 2 b_ele &lt;- -3 b_under &lt;- 5 b_masters &lt;- -2 b_phd &lt;- 10 pop_df$happiness &lt;- b_0 + b_out*(pop_df$min_outdoors + rnorm(pop_size, 0, 40)) + b_zoom*(pop_df$min_zoom + rnorm(pop_size, 0, 40)) + b_civ*(pop_df$civil + rnorm(pop_size, 0, 2)) + b_mech*pop_df$mechanical + b_ele*pop_df$electrical + b_under * pop_df$undergrad + b_masters*pop_df$masters + b_phd*pop_df$phd + round(rnorm(n = pop_size, mean = 0, sd = 10), 0) We will save the full population dataset. That is what we will start with in class. pop_df %&gt;% write_csv(&quot;student_happiness.csv&quot;) Now we create a sample of students by sampling from the population dataframe. samp_df &lt;- sample_n(pop_df, size = 200) On the modeling side, we can first start with a very simple model with only one predictor. happiness_zoom &lt;- lm(happiness ~ min_zoom, data = samp_df) summary(happiness_zoom) ## ## Call: ## lm(formula = happiness ~ min_zoom, data = samp_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -38.397 -9.266 -0.983 11.048 44.208 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 61.17095 2.38701 25.627 &lt; 2e-16 *** ## min_zoom -0.04462 0.01047 -4.259 3.17e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 16.16 on 198 degrees of freedom ## Multiple R-squared: 0.08394, Adjusted R-squared: 0.07931 ## F-statistic: 18.14 on 1 and 198 DF, p-value: 3.165e-05 Next, we can look at what happens with a more complex model with multiple predictors. Pay attention to how the \\(R^2\\) value changes. happiness_all &lt;- lm(happiness ~ min_outdoors + min_zoom + civil + mechanical + electrical + undergrad + masters + phd, data = samp_df) summary(happiness_all) ## ## Call: ## lm(formula = happiness ~ min_outdoors + min_zoom + civil + mechanical + ## electrical + undergrad + masters + phd, data = samp_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -37.922 -9.746 -1.116 12.272 33.192 ## ## Coefficients: (2 not defined because of singularities) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 51.880982 3.526718 14.711 &lt; 2e-16 *** ## min_outdoors 0.038552 0.012230 3.152 0.001878 ** ## min_zoom -0.045929 0.009842 -4.667 5.72e-06 *** ## civil 10.537767 2.726812 3.865 0.000152 *** ## mechanical 10.887178 2.646000 4.115 5.74e-05 *** ## electrical NA NA NA NA ## undergrad -1.652246 2.599635 -0.636 0.525811 ## masters -9.938416 3.027577 -3.283 0.001221 ** ## phd NA NA NA NA ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 14.99 on 193 degrees of freedom ## Multiple R-squared: 0.2319, Adjusted R-squared: 0.2081 ## F-statistic: 9.713 on 6 and 193 DF, p-value: 2.413e-09 An alternative way of writing the full model happiness_all &lt;- lm(happiness ~ min_outdoors + min_zoom + discipline + standing, data = samp_df) summary(happiness_all) ## ## Call: ## lm(formula = happiness ~ min_outdoors + min_zoom + discipline + ## standing, data = samp_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -37.922 -9.746 -1.116 12.272 33.192 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 52.480334 3.728491 14.075 &lt; 2e-16 *** ## min_outdoors 0.038552 0.012230 3.152 0.001878 ** ## min_zoom -0.045929 0.009842 -4.667 5.72e-06 *** ## disciplineelectrical -10.537767 2.726812 -3.865 0.000152 *** ## disciplinemechanical 0.349411 2.533103 0.138 0.890433 ## standingphd 9.938416 3.027577 3.283 0.001221 ** ## standingundergrad 8.286170 2.621890 3.160 0.001830 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 14.99 on 193 degrees of freedom ## Multiple R-squared: 0.2319, Adjusted R-squared: 0.2081 ## F-statistic: 9.713 on 6 and 193 DF, p-value: 2.413e-09 "],["week-7-logistic-regression.html", "Chapter7 Week 7: Logistic Regression 7.1 Round 1 - No systematic variation in outcomes 7.2 Round 2 - Systematic varation in outcomes as a function of discipline 7.3 Round 3 - Systematic varation in outcomes as a function of discipline and gpa 7.4 Round 4 - GPA and persistence vary by discipline", " Chapter7 Week 7: Logistic Regression To study how to run a logistic regression model in R, we are going to create simulate some data. NOTE: Simulating data is a good way to get a sense of how the model works since you already know the data-generate process that you are trying to characterize with the model. This means you already know the ground truth. In practice, we do not have this luxury when we run our studies - it is this ground truth that were looking for. Nonetheless, it can be helpful to remove one piece of uncertainty when learning the technical aspects by using data that are already characterized because you made them. We will proceed through several rounds of data generation to see how the model may vary. 7.1 Round 1 - No systematic variation in outcomes disciplines &lt;- c(&quot;civil&quot;, &quot;mechanical&quot;, &quot;electrical&quot;, &quot;systems&quot;) disciplines_prob &lt;- c(0.25, 0.3, 0.35, 0.1) know_engineer &lt;- c(&quot;immediate_fam&quot;, &quot;distant_fam&quot;, &quot;friend&quot;, &quot;none&quot;) know_engineer_prob &lt;- c(0.2, 0.4, 0.3, 0.1) persistence &lt;- c(&quot;yes&quot;, &quot;no&quot;) persistence_prob &lt;- c(0.8, 0.2) Now we will generate the actual sample of 500 students samp_size &lt;- 500 disc_samp &lt;- sample(x = disciplines, size = samp_size, prob = disciplines_prob, replace = TRUE) know_samp &lt;- sample(x = know_engineer, size = samp_size, prob = know_engineer_prob, replace = TRUE) pers_samp &lt;- sample(x = persistence, size = samp_size, prob = persistence_prob, replace = TRUE) samp_df &lt;- tibble(discipline = disc_samp, know_eng = know_samp, persist = pers_samp, gpa = round(rnorm(n = samp_size, mean = 3, sd = 0.3), 2)) Up to now, we have simulated the data collection process. This is the point where we would typically be cleaning the data and starting our analysis First, add in a new binary column for the persistence variable (coding yes as 1 and no as 0) samp_df &lt;- samp_df %&gt;% mutate(persist_bin = case_when(persist == &quot;yes&quot; ~ 1, persist == &quot;no&quot; ~ 0)) Second, get a sense of the distributions of some of the variables in our model str(samp_df) ## tibble [500 x 5] (S3: tbl_df/tbl/data.frame) ## $ discipline : chr [1:500] &quot;systems&quot; &quot;electrical&quot; &quot;electrical&quot; &quot;mechanical&quot; ... ## $ know_eng : chr [1:500] &quot;none&quot; &quot;distant_fam&quot; &quot;immediate_fam&quot; &quot;friend&quot; ... ## $ persist : chr [1:500] &quot;yes&quot; &quot;no&quot; &quot;yes&quot; &quot;yes&quot; ... ## $ gpa : num [1:500] 3.16 3 3.42 3.08 2.98 2.74 2.95 2.79 3.24 3.32 ... ## $ persist_bin: num [1:500] 1 0 1 1 1 1 1 0 0 0 ... table(samp_df$persist) ## ## no yes ## 91 409 describe(samp_df) ## Warning in describe(samp_df): NAs introduced by coercion ## Warning in describe(samp_df): NAs introduced by coercion ## Warning in describe(samp_df): NAs introduced by coercion ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## vars n mean sd median trimmed mad min max range skew ## discipline* 1 500 NaN NA NA NaN NA Inf -Inf -Inf NA ## know_eng* 2 500 NaN NA NA NaN NA Inf -Inf -Inf NA ## persist* 3 500 NaN NA NA NaN NA Inf -Inf -Inf NA ## gpa 4 500 3.01 0.31 3.01 3.01 0.3 2.03 3.91 1.88 -0.01 ## persist_bin 5 500 0.82 0.39 1.00 0.90 0.0 0.00 1.00 1.00 -1.64 ## kurtosis se ## discipline* NA NA ## know_eng* NA NA ## persist* NA NA ## gpa -0.06 0.01 ## persist_bin 0.70 0.02 table(samp_df$discipline) ## ## civil electrical mechanical systems ## 128 185 144 43 xtabs(~ discipline + persist_bin, data = samp_df) ## persist_bin ## discipline 0 1 ## civil 28 100 ## electrical 34 151 ## mechanical 21 123 ## systems 8 35 Third, model the outcome (persistence) as a function of three predictor variables (discipline, knowing an engineering, and gpa) model &lt;- glm(persist_bin ~ discipline + know_eng + gpa, data = samp_df, family = binomial()) summary(model) ## ## Call: ## glm(formula = persist_bin ~ discipline + know_eng + gpa, family = binomial(), ## data = samp_df) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.1568 0.5063 0.6005 0.6719 0.8277 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 2.2773 1.1906 1.913 0.0558 . ## disciplineelectrical 0.2254 0.2873 0.785 0.4327 ## disciplinemechanical 0.5008 0.3200 1.565 0.1175 ## disciplinesystems 0.1977 0.4483 0.441 0.6592 ## know_engfriend 0.1037 0.2672 0.388 0.6979 ## know_engimmediate_fam 0.5073 0.3589 1.414 0.1574 ## know_engnone 0.3165 0.4495 0.704 0.4814 ## gpa -0.3808 0.3797 -1.003 0.3159 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 474.41 on 499 degrees of freedom ## Residual deviance: 468.21 on 492 degrees of freedom ## AIC: 484.21 ## ## Number of Fisher Scoring iterations: 4 tidy(model) ## # A tibble: 8 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 2.28 1.19 1.91 0.0558 ## 2 disciplineelectrical 0.225 0.287 0.785 0.433 ## 3 disciplinemechanical 0.501 0.320 1.57 0.118 ## 4 disciplinesystems 0.198 0.448 0.441 0.659 ## 5 know_engfriend 0.104 0.267 0.388 0.698 ## 6 know_engimmediate_fam 0.507 0.359 1.41 0.157 ## 7 know_engnone 0.317 0.450 0.704 0.481 ## 8 gpa -0.381 0.380 -1.00 0.316 Since we generated the data without any relationships between the predictors and the binary outcome, we do not expect any of the predictor variables to be statistically significant. Sometimes there will be a significant predictor, but that emphasizes the idea p values are not necessarily the most reliable indicator of importance. 7.2 Round 2 - Systematic varation in outcomes as a function of discipline Now, to introduce some systematic variation, we will change the probabilities of persistence (the outcome variable we are modeling) as a function of major but not as a function of the other two predictors disciplines &lt;- c(&quot;civil&quot;, &quot;mechanical&quot;, &quot;electrical&quot;, &quot;systems&quot;) disciplines_prob &lt;- c(0.25, 0.3, 0.35, 0.1) know_engineer &lt;- c(&quot;immediate_fam&quot;, &quot;distant_fam&quot;, &quot;friend&quot;, &quot;none&quot;) know_engineer_prob &lt;- c(0.2, 0.4, 0.3, 0.1) We generate the actual data here. samp_size &lt;- 5000 disc_samp_2 &lt;- sample(x = disciplines, size = samp_size, prob = disciplines_prob, replace = TRUE) know_samp_2 &lt;- sample(x = know_engineer, size = samp_size, prob = know_engineer_prob, replace = TRUE) #pers_samp_2 &lt;- sample(x = persistence, size = samp_size, prob = persistence_prob, replace = TRUE) Now we will combine our data into one dataframe. samp_df_2 &lt;- tibble(discipline = disc_samp_2, know_eng = know_samp_2, gpa = round(rnorm(n = samp_size, mean = 3, sd = 0.3), 2)) Now we want to have some different outcomes whose probabilities vary by discipline. Well create a new column called persist_prob that describes the probability of persisting from year one to year two (e.g., 0.6 means there is a 0.6 prob of a student persisting) samp_df_2 &lt;- samp_df_2 %&gt;% mutate(persist_prob = case_when(discipline == &quot;civil&quot; ~ 0.6, discipline == &quot;mechanical&quot; ~ 0.7, discipline == &quot;electrical&quot; ~ 0.8, discipline == &quot;systems&quot; ~ 0.9)) We will create a vector that samples depending on the value of the persistence probability at that index. That value varies depending on the discipline for that student at that index value in the vector. persist_outcome &lt;- modify(.x = samp_df_2$persist_prob, .f = ~rbinom(n = 1, size = 1, prob = .x)) Now we add that persistence outcome column to our dataframe samp_df_2$persist_bin &lt;- persist_outcome Up to now, we have simulated the data collection process. This is the point where we would typically be cleaning the data and starting our analysis, str(samp_df_2) ## tibble [5,000 x 5] (S3: tbl_df/tbl/data.frame) ## $ discipline : chr [1:5000] &quot;electrical&quot; &quot;mechanical&quot; &quot;electrical&quot; &quot;electrical&quot; ... ## $ know_eng : chr [1:5000] &quot;friend&quot; &quot;distant_fam&quot; &quot;distant_fam&quot; &quot;distant_fam&quot; ... ## $ gpa : num [1:5000] 3.5 3.07 3.03 2.57 3.13 2.8 2.76 3.42 3.01 2.85 ... ## $ persist_prob: num [1:5000] 0.8 0.7 0.8 0.8 0.6 0.8 0.6 0.9 0.6 0.6 ... ## $ persist_bin : num [1:5000] 1 1 1 1 1 1 0 1 1 0 ... Lets check on the distribution of persistence by major. xtabs() is a function that creates a contingency table (more on that in 2 weeks) xtabs(~ persist_bin + discipline, data=samp_df_2) ## discipline ## persist_bin civil electrical mechanical systems ## 0 526 326 477 60 ## 1 737 1357 1064 453 Or we can use describe() describe(samp_df_2) ## Warning in describe(samp_df_2): NAs introduced by coercion ## Warning in describe(samp_df_2): NAs introduced by coercion ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## vars n mean sd median trimmed mad min max range skew ## discipline* 1 5000 NaN NA NA NaN NA Inf -Inf -Inf NA ## know_eng* 2 5000 NaN NA NA NaN NA Inf -Inf -Inf NA ## gpa 3 5000 3.01 0.30 3.0 3.01 0.30 1.91 4.12 2.21 0.06 ## persist_prob 4 5000 0.73 0.10 0.7 0.72 0.15 0.60 0.90 0.30 0.10 ## persist_bin 5 5000 0.72 0.45 1.0 0.78 0.00 0.00 1.00 1.00 -0.99 ## kurtosis se ## discipline* NA NA ## know_eng* NA NA ## gpa 0.06 0.00 ## persist_prob -1.02 0.00 ## persist_bin -1.02 0.01 Or even use table() table(samp_df_2$discipline) ## ## civil electrical mechanical systems ## 1263 1683 1541 513 Now, model the outcome (persistence) as a function of three predictor variables (discipline, knowing an engineering, and gpa) model_2 &lt;- glm(persist_bin ~ discipline + know_eng + gpa, data = samp_df_2, family = binomial()) And examine the model output with either summary() summary(model_2) ## ## Call: ## glm(formula = persist_bin ~ discipline + know_eng + gpa, family = binomial(), ## data = samp_df_2) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.1424 -1.2855 0.6611 0.8680 1.0852 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.35145 0.33153 1.060 0.28911 ## disciplineelectrical 1.08537 0.08412 12.902 &lt; 2e-16 *** ## disciplinemechanical 0.46340 0.07944 5.834 5.42e-09 *** ## disciplinesystems 1.68832 0.14888 11.340 &lt; 2e-16 *** ## know_engfriend 0.23347 0.07935 2.942 0.00326 ** ## know_engimmediate_fam 0.08323 0.08782 0.948 0.34328 ## know_engnone 0.06379 0.11337 0.563 0.57363 ## gpa -0.03448 0.10778 -0.320 0.74907 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 5908.6 on 4999 degrees of freedom ## Residual deviance: 5638.2 on 4992 degrees of freedom ## AIC: 5654.2 ## ## Number of Fisher Scoring iterations: 4 or tidy() tidy(model_2) ## # A tibble: 8 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.351 0.332 1.06 2.89e- 1 ## 2 disciplineelectrical 1.09 0.0841 12.9 4.38e-38 ## 3 disciplinemechanical 0.463 0.0794 5.83 5.42e- 9 ## 4 disciplinesystems 1.69 0.149 11.3 8.27e-30 ## 5 know_engfriend 0.233 0.0794 2.94 3.26e- 3 ## 6 know_engimmediate_fam 0.0832 0.0878 0.948 3.43e- 1 ## 7 know_engnone 0.0638 0.113 0.563 5.74e- 1 ## 8 gpa -0.0345 0.108 -0.320 7.49e- 1 7.3 Round 3 - Systematic varation in outcomes as a function of discipline and gpa Now, to introduce some systematic variation, we will change the probabilities of persistence (the outcome variable we are modeling) as a function of major and gpa but not as a function of knowing an engineer. disciplines &lt;- c(&quot;civil&quot;, &quot;mechanical&quot;, &quot;electrical&quot;, &quot;systems&quot;) disciplines_prob &lt;- c(0.25, 0.3, 0.35, 0.1) know_engineer &lt;- c(&quot;immediate_fam&quot;, &quot;distant_fam&quot;, &quot;friend&quot;, &quot;none&quot;) know_engineer_prob &lt;- c(0.2, 0.4, 0.3, 0.1) Simulate the dataf or disciplines, knowing an engineer, and the persistence outcome samp_size &lt;- 500 disc_samp_3 &lt;- sample(x = disciplines, size = samp_size, prob = disciplines_prob, replace = TRUE) know_samp_3 &lt;- sample(x = know_engineer, size = samp_size, prob = know_engineer_prob, replace = TRUE) pers_samp_3 &lt;- sample(x = persistence, size = samp_size, prob = persistence_prob, replace = TRUE) And combine all the generated data into one dataframe with tibble(). samp_df_3 &lt;- tibble(discipline = disc_samp_3, know_eng = know_samp_3, persist = pers_samp_3) Up to now, we have simulated the data collection process. This is the point where we would typically be cleaning the data and starting out analysis To run the logistic regression, we need our outcome coded as 0/1, not no/yes to address this, we add in a new binary column for the persistence variable (coding yes as 1 and no as 0) samp_df_3 &lt;- samp_df_3 %&gt;% mutate(persist_bin = case_when(persist == &quot;yes&quot; ~ 1, persist == &quot;no&quot; ~ 0)) Now, since we want to look at the potential effect of gpa on persistence, we create a bookkeeping column for gpa_mean for students who do and do not persist to year two. samp_df_3 &lt;- samp_df_3 %&gt;% mutate(gpa_mean = case_when(persist == &quot;yes&quot; ~ 3.4, persist == &quot;no&quot; ~ 3.0)) Simulate the gpa data gpa_vec &lt;- round(modify(.x = samp_df_3$gpa_mean, .f = ~rnorm(n = 1, mean = .x, sd = .2)), 2) Add the simulated data back to our data frame samp_df_3$gpa &lt;- gpa_vec Up to now, we have simulated the data collection process. This is the point where we would typically be cleaning the data and starting our analysis Check the structure of the dataframe to make sure it looks as expected str(samp_df_3) ## tibble [500 x 6] (S3: tbl_df/tbl/data.frame) ## $ discipline : chr [1:500] &quot;mechanical&quot; &quot;electrical&quot; &quot;civil&quot; &quot;civil&quot; ... ## $ know_eng : chr [1:500] &quot;friend&quot; &quot;immediate_fam&quot; &quot;immediate_fam&quot; &quot;distant_fam&quot; ... ## $ persist : chr [1:500] &quot;yes&quot; &quot;yes&quot; &quot;yes&quot; &quot;yes&quot; ... ## $ persist_bin: num [1:500] 1 1 1 1 1 1 1 1 0 1 ... ## $ gpa_mean : num [1:500] 3.4 3.4 3.4 3.4 3.4 3.4 3.4 3.4 3 3.4 ... ## $ gpa : num [1:500] 3.45 3.82 3.42 3.63 3.45 3.26 3.83 3.23 3.15 3.14 ... Lets check on the distribution of persistence by major. xtabs() is a function that creates a contingency table (more on that in 2 weeks) xtabs(~ persist_bin + discipline, data=samp_df_3) ## discipline ## persist_bin civil electrical mechanical systems ## 0 30 35 36 5 ## 1 100 127 130 37 or with describe() describe(samp_df_3) ## Warning in describe(samp_df_3): NAs introduced by coercion ## Warning in describe(samp_df_3): NAs introduced by coercion ## Warning in describe(samp_df_3): NAs introduced by coercion ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## vars n mean sd median trimmed mad min max range skew ## discipline* 1 500 NaN NA NA NaN NA Inf -Inf -Inf NA ## know_eng* 2 500 NaN NA NA NaN NA Inf -Inf -Inf NA ## persist* 3 500 NaN NA NA NaN NA Inf -Inf -Inf NA ## persist_bin 4 500 0.79 0.41 1.00 0.86 0.00 0.00 1.00 1.00 -1.41 ## gpa_mean 5 500 3.32 0.16 3.40 3.34 0.00 3.00 3.40 0.40 -1.41 ## gpa 6 500 3.31 0.26 3.34 3.32 0.27 2.56 3.88 1.32 -0.34 ## kurtosis se ## discipline* NA NA ## know_eng* NA NA ## persist* NA NA ## persist_bin -0.03 0.02 ## gpa_mean -0.03 0.01 ## gpa -0.24 0.01 or with table(). table(samp_df_3$discipline) ## ## civil electrical mechanical systems ## 130 162 166 42 Check the distribution of the gpa values by discipline, just to make sure samp_df_3 %&gt;% ggplot(aes(x = gpa, fill = discipline)) + geom_histogram(alpha = 0.2, position = &quot;identity&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # be sure to put alpha before position samp_df_3 %&gt;% ggplot(aes(x = gpa, fill = persist)) + geom_histogram(alpha = 0.2, position = &quot;identity&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Now, model the outcome (persistence) as a function of three predictor variables (discipline, knowing an engineering, and gpa) model_3 &lt;- glm(persist_bin ~ discipline + know_eng + gpa, data = samp_df_3, family = binomial()) And examine the results with summary() or tidy() summary(model_3) ## ## Call: ## glm(formula = persist_bin ~ discipline + know_eng + gpa, family = binomial(), ## data = samp_df_3) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.95665 0.05105 0.18222 0.41311 2.17923 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -30.9280 3.1802 -9.725 &lt;2e-16 *** ## disciplineelectrical 0.6007 0.4104 1.464 0.143 ## disciplinemechanical 0.1713 0.4070 0.421 0.674 ## disciplinesystems 1.1028 0.6992 1.577 0.115 ## know_engfriend -0.4395 0.3893 -1.129 0.259 ## know_engimmediate_fam -0.1139 0.4268 -0.267 0.790 ## know_engnone -0.6012 0.5407 -1.112 0.266 ## gpa 10.0531 1.0073 9.980 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 516.59 on 499 degrees of freedom ## Residual deviance: 274.07 on 492 degrees of freedom ## AIC: 290.07 ## ## Number of Fisher Scoring iterations: 6 tidy(model_3) ## # A tibble: 8 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -30.9 3.18 -9.73 2.35e-22 ## 2 disciplineelectrical 0.601 0.410 1.46 1.43e- 1 ## 3 disciplinemechanical 0.171 0.407 0.421 6.74e- 1 ## 4 disciplinesystems 1.10 0.699 1.58 1.15e- 1 ## 5 know_engfriend -0.439 0.389 -1.13 2.59e- 1 ## 6 know_engimmediate_fam -0.114 0.427 -0.267 7.90e- 1 ## 7 know_engnone -0.601 0.541 -1.11 2.66e- 1 ## 8 gpa 10.1 1.01 9.98 1.87e-23 7.4 Round 4 - GPA and persistence vary by discipline disciplines &lt;- c(&quot;civil&quot;, &quot;mechanical&quot;, &quot;electrical&quot;, &quot;systems&quot;) disciplines_prob &lt;- c(0.25, 0.3, 0.35, 0.1) know_engineer &lt;- c(&quot;immediate_fam&quot;, &quot;distant_fam&quot;, &quot;friend&quot;, &quot;none&quot;) know_engineer_prob &lt;- c(0.2, 0.4, 0.3, 0.1) Simulate the data for disciplines, knowing an engineer, and the persistence outcome samp_size &lt;- 500 student_id &lt;- seq(samp_size) disc_samp_4 &lt;- sample(x = disciplines, size = samp_size, prob = disciplines_prob, replace = TRUE) know_samp_4 &lt;- sample(x = know_engineer, size = samp_size, prob = know_engineer_prob, replace = TRUE) pers_samp_4 &lt;- sample(x = persistence, size = samp_size, prob = persistence_prob, replace = TRUE) Combine these all together in tibble(). samp_df_4 &lt;- tibble(sid = student_id, discipline = disc_samp_4, know_eng = know_samp_4) Up to now, we have simulated the data collection process. This is the point where we would typically be cleaning the data and starting out analysis Start the data analysis for logistic regression here Now, since we want to look at the potential effect of gpa on persistence, we create a bookkeeping column for gpa_mean for students who do and do not persist to year two. samp_df_4 &lt;- samp_df_4 %&gt;% mutate(gpa_mean = case_when(discipline == &quot;civil&quot; ~ 3.0, discipline == &quot;electrical&quot; ~ 3.15, discipline == &quot;mechanical&quot; ~ 3.3, discipline == &quot;systems&quot; ~ 3.45)) Simulate the gpa data. gpa_vec &lt;- round(modify(.x = samp_df_4$gpa_mean, .f = ~rnorm(n = 1, mean = .x, sd = .1)), 2) Add the simulated data back to our data frame samp_df_4$gpa &lt;- gpa_vec We will create a vector that samples depending on the value of the persistence probability at that index. That value varies depending on the discipline for that student at that index value in the vector. Now we want to have some different outcomes whose probabilities vary by discipline. Well create a new column called. persist_prob that describes the probability of persisting from year one to year two (e.g., 0.6 means there is a 0.6 prob of a student persisting) samp_df_4 &lt;- samp_df_4 %&gt;% mutate(persist_prob = case_when(discipline == &quot;civil&quot; ~ 0.6, discipline == &quot;mechanical&quot; ~ 0.7, discipline == &quot;electrical&quot; ~ 0.8, discipline == &quot;systems&quot; ~ 0.9)) persist_outcome &lt;- modify(.x = samp_df_4$persist_prob, .f = ~rbinom(n = 1, size = 1, prob = .x)) Now we add that persistence outcome column to our dataframe samp_df_4$persist_bin &lt;- persist_outcome Up to now, we have simulated the data collection process. This is the point where we would typically be cleaning the data and starting our analysis Check the structure of the dataframe to make sure it looks as expected. str(samp_df_4) ## tibble [500 x 7] (S3: tbl_df/tbl/data.frame) ## $ sid : int [1:500] 1 2 3 4 5 6 7 8 9 10 ... ## $ discipline : chr [1:500] &quot;electrical&quot; &quot;electrical&quot; &quot;electrical&quot; &quot;mechanical&quot; ... ## $ know_eng : chr [1:500] &quot;distant_fam&quot; &quot;immediate_fam&quot; &quot;friend&quot; &quot;distant_fam&quot; ... ## $ gpa_mean : num [1:500] 3.15 3.15 3.15 3.3 3 3.45 3 3.15 3.15 3.3 ... ## $ gpa : num [1:500] 2.99 2.95 3.13 3.23 3.09 3.57 2.88 3.25 3.39 3.09 ... ## $ persist_prob: num [1:500] 0.8 0.8 0.8 0.7 0.6 0.9 0.6 0.8 0.8 0.7 ... ## $ persist_bin : num [1:500] 1 0 1 1 0 1 0 0 1 1 ... Lets check on the distribution of persistence by major. xtabs() is a function that creates a contingency table (more on that in 2 weeks). xtabs(~ persist_bin + discipline, data=samp_df_4) ## discipline ## persist_bin civil electrical mechanical systems ## 0 49 34 43 9 ## 1 73 144 112 36 describe(samp_df_4) ## Warning in describe(samp_df_4): NAs introduced by coercion ## Warning in describe(samp_df_4): NAs introduced by coercion ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to min; returning Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## Warning in FUN(newX[, i], ...): no non-missing arguments to max; returning -Inf ## vars n mean sd median trimmed mad min max range ## sid 1 500 250.50 144.48 250.50 250.50 185.32 1.00 500.00 499.00 ## discipline* 2 500 NaN NA NA NaN NA Inf -Inf -Inf ## know_eng* 3 500 NaN NA NA NaN NA Inf -Inf -Inf ## gpa_mean 4 500 3.19 0.14 3.15 3.18 0.22 3.00 3.45 0.45 ## gpa 5 500 3.19 0.17 3.20 3.19 0.17 2.78 3.63 0.85 ## persist_prob 6 500 0.73 0.09 0.70 0.73 0.15 0.60 0.90 0.30 ## persist_bin 7 500 0.73 0.44 1.00 0.79 0.00 0.00 1.00 1.00 ## skew kurtosis se ## sid 0.00 -1.21 6.46 ## discipline* NA NA NA ## know_eng* NA NA NA ## gpa_mean 0.18 -0.89 0.01 ## gpa 0.11 -0.35 0.01 ## persist_prob 0.05 -1.00 0.00 ## persist_bin -1.03 -0.93 0.02 table(samp_df_4$discipline) ## ## civil electrical mechanical systems ## 122 178 155 45 Check the distribution of the gpa values by discipline, just to make sure. samp_df_4 %&gt;% ggplot(aes(x = gpa, fill = discipline)) + geom_histogram(alpha = 0.2, position = &quot;identity&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. be sure to put alpha before position samp_df_4 %&gt;% ggplot(aes(x = gpa, fill = as_factor(persist_bin))) + geom_histogram(alpha = 0.2, position = &quot;identity&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Now, model the outcome (persistence) as a function of three predictor variables (discipline, knowing an engineering, and gpa) model_4 &lt;- glm(persist_bin ~ discipline + know_eng + gpa, data = samp_df_4, family = binomial()) summary(model_4) ## ## Call: ## glm(formula = persist_bin ~ discipline + know_eng + gpa, family = binomial(), ## data = samp_df_4) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.9664 -1.2860 0.6731 0.8202 1.1175 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 1.8297 3.1549 0.580 0.561930 ## disciplineelectrical 1.1537 0.3209 3.595 0.000324 *** ## disciplinemechanical 0.7242 0.4162 1.740 0.081795 . ## disciplinesystems 1.2693 0.6369 1.993 0.046249 * ## know_engfriend 0.3072 0.2690 1.142 0.253381 ## know_engimmediate_fam -0.0742 0.2590 -0.287 0.774492 ## know_engnone -0.2379 0.3837 -0.620 0.535200 ## gpa -0.4946 1.0495 -0.471 0.637426 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 583.26 on 499 degrees of freedom ## Residual deviance: 563.31 on 492 degrees of freedom ## AIC: 579.31 ## ## Number of Fisher Scoring iterations: 4 tidy(model_4) ## # A tibble: 8 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 1.83 3.15 0.580 0.562 ## 2 disciplineelectrical 1.15 0.321 3.60 0.000324 ## 3 disciplinemechanical 0.724 0.416 1.74 0.0818 ## 4 disciplinesystems 1.27 0.637 1.99 0.0462 ## 5 know_engfriend 0.307 0.269 1.14 0.253 ## 6 know_engimmediate_fam -0.0742 0.259 -0.287 0.774 ## 7 know_engnone -0.238 0.384 -0.620 0.535 ## 8 gpa -0.495 1.05 -0.471 0.637 7.4.1 Interlude looking at poisson distribution n &lt;- 10000 set.seed(123) x_samp_5 &lt;- rpois(n, lambda = 5) hist(x_samp_5) x_samp_10 &lt;- rpois(n, lambda = 10) hist(x_samp_10) param_vect &lt;- rep(c(1, 2, 3, 4, 5, 6), each = n) samp_vect &lt;- modify(.x = param_vect, .f = ~ rpois(n = 1, lambda = .x)) samp_df &lt;- tibble(param_val = param_vect, sample_val = samp_vect) samp_df %&gt;% ggplot(aes(x = sample_val)) + geom_histogram() + facet_grid(param_val ~ .) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. "],["week-8-comparing-two-means-t-tests.html", "Chapter8 Week 8: Comparing two means (t-tests) 8.1 Demo 1 - Comparing salary data for chemical engineering and environmental engineering 8.2 Demo 2 - Student SAT scores", " Chapter8 Week 8: Comparing two means (t-tests) This week we focus on comparing two means. This can be the means of an outcome variable collected in two discrete groups (e.g., first-year and second-year students) or the same group across two time points (e.g., pre-test and post-test). The following contains a number of demos to illustrate how and when we would use t-tests. 8.1 Demo 1 - Comparing salary data for chemical engineering and environmental engineering First, lets generate some data so that we know the underlying data-generating process that we use statistical tests to characterize. Well have a sample of 100 participants. N &lt;- 100 student_id &lt;- seq(N) group_size &lt;- N/2 chem_eng_df &lt;- tibble(id = seq(group_size), salary = round(rnorm(n = group_size, mean = 75000, sd = 3000), 2), discipline = &quot;chemical&quot;) chem_eng_df %&gt;% ggplot(aes(x= salary)) + geom_histogram(color = &quot;white&quot;) + theme_bw() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. env_eng_df &lt;- tibble(id = seq(group_size), salary = round(rnorm(n = group_size, mean = 65000, sd = 4000), 2), discipline = &quot;environmental&quot;) env_eng_df %&gt;% ggplot(aes(x= salary)) + geom_histogram(color = &quot;white&quot;) + theme_bw() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Combine the two disciplinary dataframes together. salary_comb_long &lt;- bind_rows(chem_eng_df, env_eng_df) salary_comb_long %&gt;% ggplot(aes(x = salary, fill = discipline)) + geom_histogram(alpha = 0.2, position = &quot;identity&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Independent samples t-test using the long format approach (NB: the long format is a good practice - it keeps the grouping variable in one column and the continuous outcome variable in a separate column). salary_test &lt;- t.test(salary ~ discipline, data = salary_comb_long, paired = FALSE) salary_test ## ## Welch Two Sample t-test ## ## data: salary by discipline ## t = 14.982, df = 95.279, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 9159.492 11957.530 ## sample estimates: ## mean in group chemical mean in group environmental ## 75218.01 64659.50 Use the tidy() function from the broom package to generate a tibble with the output of the t.test(). tidy(salary_test) ## # A tibble: 1 x 10 ## estimate estimate1 estimate2 statistic p.value parameter conf.low conf.high ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10559. 75218. 64659. 15.0 8.65e-27 95.3 9159. 11958. ## # ... with 2 more variables: method &lt;chr&gt;, alternative &lt;chr&gt; Remember that a t-test is similar to a linear regression model with a binary predictor variable and continuous outcome variable. In this case, the model is something like \\(salary_i = \\beta_0 + \\beta_1 * discipline_i\\) Notice how the value of the t-statistic (t value in the linear model summary table) is close to the t value calculated with the t-test! salary_lm &lt;- lm(salary ~ discipline, data = salary_comb_long) summary(salary_lm) ## ## Call: ## lm(formula = salary ~ discipline, data = salary_comb_long) ## ## Residuals: ## Min 1Q Median 3Q Max ## -9496.0 -2100.7 239.4 2288.4 9202.1 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 75218.0 498.3 150.94 &lt;2e-16 *** ## disciplineenvironmental -10558.5 704.7 -14.98 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3524 on 98 degrees of freedom ## Multiple R-squared: 0.6961, Adjusted R-squared: 0.693 ## F-statistic: 224.5 on 1 and 98 DF, p-value: &lt; 2.2e-16 Calculate the effect size of discipline on salary. (t &lt;- salary_test$statistic[[1]]) # wrapping this in parentheses prints out the value of t at the same time that it stores the value of t ## [1] 14.98229 (df &lt;- salary_test$parameter[[1]]) ## [1] 95.27933 (r &lt;- sqrt(t^2/(t^2 + df))) ## [1] 0.8378649 round(r,3) ## [1] 0.838 r^2 ## [1] 0.7020177 We now have the results of an independent samples t-test and the effect size. Think about what would happen if we changed the sample size or if we changed the underlying distributions that we used to generate the salary data. We can also run the t-test using a wide format approach salary_comb_wide &lt;- salary_comb_long %&gt;% pivot_wider(names_from = discipline, values_from = salary) salary_test_2 &lt;- t.test(salary_comb_wide$chemical, salary_comb_wide$environmental, paired = FALSE) salary_test_2 ## ## Welch Two Sample t-test ## ## data: salary_comb_wide$chemical and salary_comb_wide$environmental ## t = 14.982, df = 95.279, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 9159.492 11957.530 ## sample estimates: ## mean of x mean of y ## 75218.01 64659.50 8.2 Demo 2 - Student SAT scores Lets try a second example. This time well simulate data we might have where a dependent samples t-test would be appropriate. We are going to simulate the scenario where we have student SAT scores on both the verbal section and math section. samp_size &lt;- 1000 student_id &lt;- seq(samp_size) sat_verbal &lt;- round(rnorm(n = samp_size, mean = 620, sd = 55), 0) sat_math &lt;- round(rnorm(n = samp_size, mean = 700, sd = 40), 0) sat_verbal_capped &lt;- modify(.x = sat_verbal, .f = ~ min(800, .x)) sat_math_capped &lt;- modify(.x = sat_math, .f = ~min(800, .x)) sat_df &lt;- tibble(id = student_id, verbal = sat_verbal_capped, math = sat_math_capped) sat_df %&gt;% ggplot(aes(x = verbal)) + geom_histogram() + labs(title = &quot;Simulated SAT Verbal Histogram&quot;, x = &quot;Verbal Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. sat_df %&gt;% ggplot(aes(x = math)) + geom_histogram() + labs(title = &quot;Simulated SAT Math Histogram&quot;, x = &quot;Math Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Alternatively, we could plot these together by either making a long data set or just overlaying histograms and modifying transparency (the alpha parameter). sat_df %&gt;% ggplot() + geom_histogram(aes(x = math, fill = &quot;red&quot;), alpha = 0.2) + labs(title = &quot;Simulated SAT Scores Histogram&quot;, x = &quot;SAT Score&quot;, y = &quot;Count&quot;) + geom_histogram(aes(x = verbal, fill = &quot;blue&quot;), alpha = 0.2) + scale_fill_manual(name = &quot;Category&quot;, values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;verbal&quot;, &quot;math&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Looking at the histogram, we can see that there appears to be a systematic difference in the scores. Running a t-test will help us see if that initial observation is statistically correct. Since we will be comparing verbal and math scores for each student, this will be a dependent samples (or paired samples) t-test. sat_t_test &lt;- t.test(sat_df$verbal, sat_df$math, paired = TRUE) # don&#39;t forget to add: paired = TRUE # now look at the results sat_t_test ## ## Paired t-test ## ## data: sat_df$verbal and sat_df$math ## t = -38.699, df = 999, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -84.23739 -76.10661 ## sample estimates: ## mean of the differences ## -80.172 We see there was a statistically significant difference, but now lets try changing the distributions and see what happens. First, well change make the means very close together and see how sensitive the test is to that samp_size &lt;- 1000 student_id_2 &lt;- seq(samp_size) sat_verbal_2 &lt;- round(rnorm(n = samp_size, mean = 690, sd = 55), 0) sat_math_2 &lt;- round(rnorm(n = samp_size, mean = 700, sd = 40), 0) # let&#39;s cap the simulated scores at 800 sat_verbal_2_capped &lt;- modify(.x = sat_verbal_2, .f = ~ min(800, .x)) sat_math_2_capped &lt;- modify(.x = sat_math_2, .f = ~min(800, .x)) sat_df_2 &lt;- tibble(id = student_id, verbal = sat_verbal_2_capped, math = sat_math_2_capped) sat_df_2 %&gt;% ggplot(aes(x = verbal)) + geom_histogram() + labs(title = &quot;Simulated SAT Verbal Histogram&quot;, x = &quot;Verbal Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. sat_df_2 %&gt;% ggplot(aes(x = math)) + geom_histogram() + labs(title = &quot;Simulated SAT Math Histogram&quot;, x = &quot;Math Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Alternatively, we could plot these together by either making a long data set or just overlaying histograms and modifying transparency (the alpha parameter). sat_df_2 %&gt;% ggplot() + geom_histogram(aes(x = math, fill = &quot;red&quot;), alpha = 0.2) + labs(title = &quot;Simulated SAT Scores Histogram&quot;, x = &quot;SAT Score&quot;, y = &quot;Count&quot;) + geom_histogram(aes(x = verbal, fill = &quot;blue&quot;), alpha = 0.2) + scale_fill_manual(name = &quot;Category&quot;, values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;verbal&quot;, &quot;math&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Looking at the histogram, we can see that there appears to be a systematic difference in the scores. Running a t-test will help us see if that initial observation is statistically correct. Since we will be comparing verbal and math scores for each student, this will be a dependent samples (or paired samples) t-test sat_t_test_2 &lt;- t.test(sat_df_2$verbal, sat_df_2$math, paired = TRUE) # don&#39;t forget to add: paired = TRUE # now look at the results sat_t_test_2 ## ## Paired t-test ## ## data: sat_df_2$verbal and sat_df_2$math ## t = -5.7463, df = 999, p-value = 1.21e-08 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -15.724989 -7.719011 ## sample estimates: ## mean of the differences ## -11.722 Lets try a third test - this time well change the sample size to be 25 students rather than 1000 samp_size &lt;- 25 student_id_3 &lt;- seq(samp_size) sat_verbal_3 &lt;- round(rnorm(n = samp_size, mean = 690, sd = 55), 0) sat_math_3 &lt;- round(rnorm(n = samp_size, mean = 700, sd = 40), 0) # cap the scores at 800 sat_verbal_3_capped &lt;- modify(.x = sat_verbal_3, .f = ~ min(800, .x)) sat_math_3_capped &lt;- modify(.x = sat_math_3, .f = ~min(800, .x)) sat_df_3 &lt;- tibble(id = student_id_3, verbal = sat_verbal_3_capped, math = sat_math_3_capped) sat_df_3 %&gt;% ggplot(aes(x = verbal)) + geom_histogram() + labs(title = &quot;Simulated SAT Verbal Histogram&quot;, x = &quot;Verbal Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. sat_df_3 %&gt;% ggplot(aes(x = math)) + geom_histogram() + labs(title = &quot;Simulated SAT Math Histogram&quot;, x = &quot;Math Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Alternatively, we could plot these together by either making a long data set or just overlaying histograms and modifying transparency (the alpha parameter) sat_df_3 %&gt;% ggplot() + geom_histogram(aes(x = math, fill = &quot;red&quot;), alpha = 0.2) + labs(title = &quot;Simulated SAT Scores Histogram&quot;, x = &quot;SAT Score&quot;, y = &quot;Count&quot;) + geom_histogram(aes(x = verbal, fill = &quot;blue&quot;), alpha = 0.2) + scale_fill_manual(name = &quot;Category&quot;, values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;verbal&quot;, &quot;math&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Looking at the histogram, we can see that there appears to be a systematic difference in the scores. Running a t-test will help us see if that initial observation is statistically correct.Since we will be comparing verbal and math scores for each student, this will be a dependent samples (or paired samples) t-test sat_t_test_3 &lt;- t.test(sat_df_3$verbal, sat_df_3$math, paired = TRUE) # don&#39;t forget to add: paired = TRUE # now look at the results sat_t_test_3 ## ## Paired t-test ## ## data: sat_df_3$verbal and sat_df_3$math ## t = -0.14479, df = 24, p-value = 0.8861 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -30.50846 26.50846 ## sample estimates: ## mean of the differences ## -2 Now we see that the statistically significant difference is gone. How about if we go back to having a large difference in the means samp_size &lt;- 25 student_id_4 &lt;- seq(samp_size) sat_verbal_4 &lt;- round(rnorm(n = samp_size, mean = 620, sd = 55), 0) sat_math_4 &lt;- round(rnorm(n = samp_size, mean = 700, sd = 40), 0) #cap the scores at 800 sat_verbal_4_capped &lt;- modify(.x = sat_verbal_4, .f = ~ min(800, .x)) sat_math_4_capped &lt;- modify(.x = sat_math_4, .f = ~min(800, .x)) sat_df_4 &lt;- tibble(id = student_id_4, verbal = sat_verbal_4_capped, math = sat_math_4_capped) # visualize the distributions of scores sat_df_4 %&gt;% ggplot(aes(x = verbal)) + geom_histogram() + labs(title = &quot;Simulated SAT Verbal Histogram&quot;, x = &quot;Verbal Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. sat_df_4 %&gt;% ggplot(aes(x = math)) + geom_histogram() + labs(title = &quot;Simulated SAT Math Histogram&quot;, x = &quot;Math Score&quot;, y = &quot;Count&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Alternatively, we could plot these together by either making a long data set or just overlaying histograms and modifying transparency (the alpha parameter) sat_df_4 %&gt;% ggplot() + geom_histogram(aes(x = math, fill = &quot;red&quot;), alpha = 0.2) + labs(title = &quot;Simulated SAT Scores Histogram&quot;, x = &quot;SAT Score&quot;, y = &quot;Count&quot;) + geom_histogram(aes(x = verbal, fill = &quot;blue&quot;), alpha = 0.2) + scale_fill_manual(name = &quot;Category&quot;, values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;verbal&quot;, &quot;math&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Looking at the histogram, we can see that there appears to be a systematic difference in the scores. Running a t-test will help us see if that initial observation is statistically correct. Since we will be comparing verbal and math scores for each student, this will be a dependent samples (or paired samples) t-test sat_t_test_4 &lt;- t.test(sat_df_4$math, sat_df_4$verbal, paired = TRUE) # don&#39;t forget to add: paired = TRUE # now look at the results sat_t_test_4 ## ## Paired t-test ## ## data: sat_df_4$math and sat_df_4$verbal ## t = 7.1392, df = 24, p-value = 2.226e-07 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 63.8111 115.7089 ## sample estimates: ## mean of the differences ## 89.76 We should see that the t-test will pick up differences between means if there is a sufficiently large difference. "]]
