[["index.html", "ENGE 5714 Course Notes 2021 Preamble", " ENGE 5714 Course Notes 2021 Dr. Katz 2021-02-28 Preamble This book will be a living document of notes for ENGE 5714 - Quantitative Research Methods in Engineering Education. I will try to keep it updated and post alerts about updates in our course Slack workspace. "],["week-1-introductions.html", "Chapter1 Week 1: Introductions", " Chapter1 Week 1: Introductions In week one we just reviewed some of the materials from the fall semester. By the end we discussed R and RStudio, but this first week was primarily about getting to know each other and the outline of the course. "],["week-2-intro-stats-data-distributions-intro-r-rstudio.html", "Chapter2 Week 2: Intro stats, Data &amp; Distributions, Intro R &amp; RStudio 2.1 First steps in R 2.2 Getting your R environment set up 2.3 Reading in data 2.4 Exploring the data 2.5 Plotting data 2.6 Some brief stats", " Chapter2 Week 2: Intro stats, Data &amp; Distributions, Intro R &amp; RStudio This week, we discuss some very basic ideas related to statistics, data, and working in R. 2.1 First steps in R We can create a new variable by assigning it a value with the &lt;- operator. Lets create a vector of numbers 1 to 10 with the seq() function and then a separate vector that takes each of the x values, multiplies it by 2, and adds 3. x &lt;- seq(1:10) y &lt;- 2* x + 3 Just to make sure everything worked as expected, we can then just type x and y and R will print their values. We could also look in the environment window to see whether those variables (and their expected values) were actually created. x ## [1] 1 2 3 4 5 6 7 8 9 10 y ## [1] 5 7 9 11 13 15 17 19 21 23 So far, so good. If we want to quickly visualize this, we could create a simple scatter plot with the plot() command (note: we will come back to plotting data much more in week 3). plot(x, y) 2.2 Getting your R environment set up One of the first things you will have in any script or .rmd file is a section to load all the libraries that you use in that script. You can install a library by using the install.packages() function, for example: install.packages(\"tidyverse\"), install.packages(\"janitor\"), and install.packages(\"psych\") with this installed, you can then load the package using the library() function library(tidyverse) ## -- Attaching packages ---------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.3 v dplyr 1.0.0 ## v tidyr 1.1.0 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts ------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(janitor) ## Warning: package &#39;janitor&#39; was built under R version 4.0.3 ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test library(psych) ## ## Attaching package: &#39;psych&#39; ## The following objects are masked from &#39;package:ggplot2&#39;: ## ## %+%, alpha 2.3 Reading in data A good first step when working in R is to check which directory you are working in with the getwd() function. You should get a directory in response. getwd() ## [1] &quot;C:/Users/akatz4/Desktop/test_course_note&quot; You can also check which files are in that directory with list.files(). list.files() ## [1] &quot;_book&quot; ## [2] &quot;_bookdown.yml&quot; ## [3] &quot;_bookdown_files&quot; ## [4] &quot;_output.yml&quot; ## [5] &quot;01-Week_01.Rmd&quot; ## [6] &quot;02-Week_02.Rmd&quot; ## [7] &quot;03-Week_03.Rmd&quot; ## [8] &quot;04-Week_04.Rmd&quot; ## [9] &quot;05-Week_05.Rmd&quot; ## [10] &quot;06-Week_06.Rmd&quot; ## [11] &quot;book.bib&quot; ## [12] &quot;ChildAggression.dat&quot; ## [13] &quot;docs&quot; ## [14] &quot;ENGE_5714_2021_pre_survey.csv&quot; ## [15] &quot;Free Reduced Lunch by Schools and Grade Structures 2008-2017_final.csv&quot; ## [16] &quot;index.Rmd&quot; ## [17] &quot;packages.bib&quot; ## [18] &quot;preamble.tex&quot; ## [19] &quot;README.md&quot; ## [20] &quot;RExam.dat&quot; ## [21] &quot;seniorsurvey.csv&quot; ## [22] &quot;student_happiness.csv&quot; ## [23] &quot;style.css&quot; ## [24] &quot;survey_student_info.csv&quot; ## [25] &quot;test_course_note.Rproj&quot; ## [26] &quot;test_course_notes.Rmd&quot; ## [27] &quot;test_course_notes_files&quot; If you notice that the file you are looking for is not there, then you can use setwd() to change your working directory setwd(\"./Week 2/\") After that, make sure you have switched to the correct working directory getwd() and then list.files(). Assuming you have directed yourself to the correct place, you can now read in the file(s) that you want to be working with. There are a lot of ways to do this. Since we will be spending a lot of time in class working with .csv files, we will focus on using the read_csv() function from the readr package (part of the tidyverse collection of packages). This function will read in the .csv file and store the data as a tibble (a tidyverse version of a data frame, which we can think of as a collection of observations stored in rows with values for variables for each observation stored in columns). prior_survey &lt;- read_csv(&quot;ENGE_5714_2021_pre_survey.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## student_id = col_double() ## ) ## See spec(...) for full column specifications. 2.4 Exploring the data Now that we have loaded in the data, lets take a look at the csv. If we just run a line with the name of the tibble - i.e., prior_survey then we should receive a printout that shows the first several rows of that tibble and a listing of all the columns, along with the data types (i.e., double for numeric values, character for strings, etc) of each column. prior_survey ## # A tibble: 24 x 49 ## student_id `I have taken a~ `I am intereste~ `I know what a ~ ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Somewhat disagr~ Somewhat agree Strongly disagr~ ## 2 2 Strongly disagr~ Neither agree n~ Somewhat agree ## 3 3 Strongly disagr~ Somewhat agree Somewhat agree ## 4 4 Somewhat disagr~ Strongly agree Strongly disagr~ ## 5 5 Somewhat agree Strongly agree Somewhat agree ## 6 6 Somewhat disagr~ Somewhat agree Somewhat disagr~ ## 7 7 Strongly disagr~ Somewhat agree Strongly disagr~ ## 8 8 Somewhat agree Somewhat agree Somewhat agree ## 9 9 Strongly disagr~ Strongly agree Somewhat agree ## 10 10 Neither agree n~ Strongly agree Somewhat agree ## # ... with 14 more rows, and 45 more variables: `I know what a type II error ## # is` &lt;chr&gt;, `I know what a (statistical) confidence level is` &lt;chr&gt;, `I know ## # what a p value is` &lt;chr&gt;, `I know what p-hacking means` &lt;chr&gt;, `I know what ## # statistical power means` &lt;chr&gt;, `I have heard of frequentist statistics ## # before` &lt;chr&gt;, `I have heard of Bayesian statistics before` &lt;chr&gt;, `I have ## # heard the term &quot;parametric statistics&quot; before` &lt;chr&gt;, `I have heard the ## # term &quot;non-parametric statistics&quot; before` &lt;chr&gt;, `I know what a histogram ## # is.` &lt;chr&gt;, `I know what a probability distribution is.` &lt;chr&gt;, `I know ## # what a random variable is.` &lt;chr&gt;, `I know what a probability distribution ## # function is.` &lt;chr&gt;, `I know what a cumulative distribution function ## # is.` &lt;chr&gt;, `I know what the expectation of a random variable is.` &lt;chr&gt;, ## # `I know how to calculate the variance of a random variable.` &lt;chr&gt;, `I know ## # what a z score is.` &lt;chr&gt;, `I know how to calculate the correlation between ## # two variables.` &lt;chr&gt;, `I know how to interpret the correlation coefficient ## # between two variables` &lt;chr&gt;, `I have heard of linear regression` &lt;chr&gt;, `I ## # know how to run a linear regression (in some software...or by hand, if I&#39;m ## # feeling wild).` &lt;chr&gt;, `I know how to interpret a linear ## # regression.` &lt;chr&gt;, `I have heard of multiple regression` &lt;chr&gt;, `I know ## # how to perform a multiple regression` &lt;chr&gt;, `I know how to interpret a ## # multiple regression` &lt;chr&gt;, `I have heard of logistic regression.` &lt;chr&gt;, ## # `I understand when to use a logistic regression.` &lt;chr&gt;, `I know how to ## # interpret the results of a logistic regression` &lt;chr&gt;, `I have heard of ## # t-tests` &lt;chr&gt;, `I have performed a t-test before` &lt;chr&gt;, `I know how to ## # interpret the results of a t-test` &lt;chr&gt;, `I have heard of Analysis of ## # Variance.` &lt;chr&gt;, `I understand when to run an Analysis of Variance ## # (ANOVA)` &lt;chr&gt;, `I know how to interpret the results from an ANOVA` &lt;chr&gt;, ## # `I have heard of a chi-square test` &lt;chr&gt;, `I have used a chi-square test ## # before` &lt;chr&gt;, `I know how to interpret the results of a chi-square ## # test` &lt;chr&gt;, `I have heard of cluster analysis before` &lt;chr&gt;, `I have used ## # cluster analysis before` &lt;chr&gt;, `I know how to interpret the results of a ## # cluster analysis` &lt;chr&gt;, `I have heard of factor analysis (either ## # exploratory or confirmatory)` &lt;chr&gt;, `I have used factor analysis (either ## # exploratory or confirmatory)` &lt;chr&gt;, `I know how to interpret the results ## # of a factor analysis (either exploratory or confirmatory)` &lt;chr&gt;, `I ## # already have R and Rstudio downloaded to my computer.` &lt;chr&gt;, `I have used ## # R before` &lt;chr&gt; When we do this, we see that there are a bunch of columns that have spaces in their names. This is okay (in the sense that R can handle this), but it can be a little frustrating to work with. Lets try cleaning the column names with clean_names() from the janitor package. This function will replace the spaces in the column names with underscores and make everything lower case. So, a column name like I have take a statistics course before will be changed to i_have_taken_a_statistics_course_before. prior_survey &lt;- prior_survey %&gt;% clean_names() # from janitor package Look at the data in prior_survey again and see if anything looks different (hint: it should). prior_survey ## # A tibble: 24 x 49 ## student_id i_have_taken_a_~ i_am_interested~ i_know_what_a_t~ ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Somewhat disagr~ Somewhat agree Strongly disagr~ ## 2 2 Strongly disagr~ Neither agree n~ Somewhat agree ## 3 3 Strongly disagr~ Somewhat agree Somewhat agree ## 4 4 Somewhat disagr~ Strongly agree Strongly disagr~ ## 5 5 Somewhat agree Strongly agree Somewhat agree ## 6 6 Somewhat disagr~ Somewhat agree Somewhat disagr~ ## 7 7 Strongly disagr~ Somewhat agree Strongly disagr~ ## 8 8 Somewhat agree Somewhat agree Somewhat agree ## 9 9 Strongly disagr~ Strongly agree Somewhat agree ## 10 10 Neither agree n~ Strongly agree Somewhat agree ## # ... with 14 more rows, and 45 more variables: ## # i_know_what_a_type_ii_error_is &lt;chr&gt;, ## # i_know_what_a_statistical_confidence_level_is &lt;chr&gt;, ## # i_know_what_a_p_value_is &lt;chr&gt;, i_know_what_p_hacking_means &lt;chr&gt;, ## # i_know_what_statistical_power_means &lt;chr&gt;, ## # i_have_heard_of_frequentist_statistics_before &lt;chr&gt;, ## # i_have_heard_of_bayesian_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_parametric_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_non_parametric_statistics_before &lt;chr&gt;, ## # i_know_what_a_histogram_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_is &lt;chr&gt;, ## # i_know_what_a_random_variable_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_function_is &lt;chr&gt;, ## # i_know_what_a_cumulative_distribution_function_is &lt;chr&gt;, ## # i_know_what_the_expectation_of_a_random_variable_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_variance_of_a_random_variable &lt;chr&gt;, ## # i_know_what_a_z_score_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_correlation_between_two_variables &lt;chr&gt;, ## # i_know_how_to_interpret_the_correlation_coefficient_between_two_variables &lt;chr&gt;, ## # i_have_heard_of_linear_regression &lt;chr&gt;, ## # i_know_how_to_run_a_linear_regression_in_some_software_or_by_hand_if_im_feeling_wild &lt;chr&gt;, ## # i_know_how_to_interpret_a_linear_regression &lt;chr&gt;, ## # i_have_heard_of_multiple_regression &lt;chr&gt;, ## # i_know_how_to_perform_a_multiple_regression &lt;chr&gt;, ## # i_know_how_to_interpret_a_multiple_regression &lt;chr&gt;, ## # i_have_heard_of_logistic_regression &lt;chr&gt;, ## # i_understand_when_to_use_a_logistic_regression &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_logistic_regression &lt;chr&gt;, ## # i_have_heard_of_t_tests &lt;chr&gt;, i_have_performed_a_t_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_t_test &lt;chr&gt;, ## # i_have_heard_of_analysis_of_variance &lt;chr&gt;, ## # i_understand_when_to_run_an_analysis_of_variance_anova &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_from_an_anova &lt;chr&gt;, ## # i_have_heard_of_a_chi_square_test &lt;chr&gt;, ## # i_have_used_a_chi_square_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_chi_square_test &lt;chr&gt;, ## # i_have_heard_of_cluster_analysis_before &lt;chr&gt;, ## # i_have_used_cluster_analysis_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_cluster_analysis &lt;chr&gt;, ## # i_have_heard_of_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_have_used_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_already_have_r_and_rstudio_downloaded_to_my_computer &lt;chr&gt;, ## # i_have_used_r_before &lt;chr&gt; One other function that will we see more in the future is the table() function, which will create a table with the counts of the values for a variable. For example, if we wanted to quickly know how students answered the I have taken a quantitative research methods course before question, we can run the following: table(prior_survey$i_have_taken_a_quantitative_research_methods_course_before) ## ## Neither agree nor disagree Somewhat agree ## 2 5 ## Somewhat disagree Strongly agree ## 5 2 ## Strongly disagree ## 10 2.5 Plotting data We will discuss plotting more next week, but here is a brief preview of whats to come There are multiple ways to plot data. Focusing on using ggplot, here are two. The first way passes the prior_survey dataframe explicitly to ggplot ggplot(data = prior_survey, mapping = aes(x = i_know_what_a_type_i_error_is)) + geom_bar() + coord_flip() The second way does this implicitly, using the pipe operator. Note that the results should be the same. prior_survey %&gt;% ggplot(mapping = aes(x = i_know_what_a_type_i_error_is)) + geom_bar() + coord_flip() If we wanted to get extra fancy, we could first convert the data from a wide format to a long format and then start plotting all the items together. Converting to long format would produce something like this: prior_survey %&gt;% gather(key = &quot;survey_item&quot;, value = &quot;survey_response&quot;) ## # A tibble: 1,176 x 2 ## survey_item survey_response ## &lt;chr&gt; &lt;chr&gt; ## 1 student_id 1 ## 2 student_id 2 ## 3 student_id 3 ## 4 student_id 4 ## 5 student_id 5 ## 6 student_id 6 ## 7 student_id 7 ## 8 student_id 8 ## 9 student_id 9 ## 10 student_id 10 ## # ... with 1,166 more rows Then we can combine that with the group_by() and summarize() functions and plot the results. prior_survey %&gt;% gather(key = &quot;survey_item&quot;, value = &quot;survey_response&quot;) %&gt;% group_by(survey_item, survey_response) %&gt;% summarize(n = n()) %&gt;% ggplot(mapping = aes(x = survey_response, y = survey_item, fill = n)) + geom_tile() ## `summarise()` regrouping output by &#39;survey_item&#39; (override with `.groups` argument) This plot is okay for giving a general sense of what is going on in these plots but there are a bunch of other ways to go about doing this. First, maybe we want to rename the response categories to a numerical scale. We can accomplish this with a mutate() and case_when(). prior_survey &lt;- prior_survey %&gt;% gather(key = &quot;survey_item&quot;, value = &quot;survey_response&quot;) %&gt;% mutate(survey_response_num = case_when(survey_response == &quot;Strongly disagree&quot; ~ 0, survey_response == &quot;Somewhat disagree&quot; ~ 1, survey_response == &quot;Neither agree nor disagree&quot; ~ 2, survey_response == &quot;Somewhat agree&quot; ~ 3, survey_response == &quot;Strongly agree&quot; ~ 4, )) Then we plot the same data but with the numerical scale along the x-axis. prior_survey %&gt;% group_by(survey_item, survey_response_num) %&gt;% summarize(n = n()) %&gt;% ggplot(mapping = aes(x = survey_response_num, y = survey_item, fill = n)) + geom_tile() ## `summarise()` regrouping output by &#39;survey_item&#39; (override with `.groups` argument) ## Warning: Removed 3 rows containing missing values (geom_tile). 2.6 Some brief stats In this weeks reading, there was also discussion about standard errors and the central limit theorem. These are fairly important theoretical concepts to grasp. To some extent they deal with the scenario where you go out and repeatedly sample from a population and calculate a statistic from each of those samples. The distributions of that statistic is what we will call the sampling distribution (as opposed to the sample distribution, which would more accurately describe the distribution of the data that we get in any one sample that we draw from the population). 2.6.1 Central Limit Theorem and Standard Error Demo - pop_students &lt;- 10000 zoom_min_pop &lt;- rnorm(n = pop_students, mean = 600, sd = 100) hist(zoom_min_pop) zoom_min_sample &lt;- sample(x = zoom_min_pop, size = 200, replace = FALSE) hist(zoom_min_sample) mean(zoom_min_sample) ## [1] 611.5296 sd(zoom_min_sample) ## [1] 96.18585 As a brief aside, lets review the idea of a loop num_reps &lt;- 100 data_vec &lt;- rep(NA, num_reps) # this creates an empty vector of size num_reps with NA in each entry # this loops through the vector starting at position 1 and ending at the final position (num_reps). For demonstration purposes, we replacing the NA in each entry with the number of that entry (i.e., the NA in the 20th entry is replaced with the number 20) for (i in 1:num_reps){ data_vec[i] &lt;- i } Okay, so thats how we create an empty vector and how we loop through its different entries. For this demo, we will also need to remenber how to generate random numbers from a norm distribution with a specified mean and standard deviation. rnorm(n = 10, mean = 5, sd = 2) # n is the number of random numbers we draw from this normal distribution ## [1] 5.581035 2.098434 3.493937 4.546990 1.700101 8.250580 4.228291 5.076769 ## [9] 4.195806 2.645440 Okay, so thats not bad. Now, that command will produce a vector with 10 random numbers. We can calculate the mean and standard deviation of those 10 numbers (which should be close to the values that we specified in rnorm() with the mean() and sd() functions. mean(rnorm(n = 10, mean = 5, sd = 2)) ## [1] 4.967267 sd(rnorm(n = 10, mean = 5, sd = 2)) ## [1] 2.115693 Next, lets act as if we are drawing a certain sample of size samp_size of data points for num_reps number of times. Keep in mind that, in practice, when we are collecting data ourselves in our own research, num_reps will almost always be 1. We are just demonstrating the underlying assumptions for how we can calculate some of the statistics that we use. num_reps &lt;- 1000 # specify how many times to take a sample samp_size &lt;- 200 # specify the size of each sample data_vec &lt;- rep(NA, num_reps) # create an empty vector of size num_reps with NA in each entry. for (i in 1:num_reps){ data_vec[i] &lt;- mean(rnorm(n = samp_size, mean = 600, sd = 100)) # store the mean of each of the num_rep samples } With this, we have a vector data_vec of size num_reps with the mean of each of our samples that we drew. This vector contains our sampling distribution of our sample means. NOTE: The standard deviation of this sampling mean is what we are calling our standard error. We can plot a histogram of this sampling distribution and calculate the standard deviation of the sampling mean. hist(data_vec) sd(data_vec) ## [1] 7.055258 On your own, try copying this code and changing the num_reps and sample_size variables to larger and smaller values. Focus on how the x-axis values in your histogram change when you change the num_reps and samp_size variables. Hint: CLT will explain the normal distribution of the sampling mean (the shape you see in the histogram) while the Weak Law of Large Numbers will explain the concentration around the true mean as samp_size increases (i.e., when we draw a larger sample size from the population, our sample mean gets closer to the population mean). ## Quick note on the rep() function: notice what happens when you specify &quot;each&quot; vs &quot;times&quot;. rep(c(1, 2), times = 5) ## [1] 1 2 1 2 1 2 1 2 1 2 rep(c(1, 2), each = 5) ## [1] 1 1 1 1 1 2 2 2 2 2 "],["week-3-data-cleaning-organizing-describing-and-communicating.html", "Chapter3 Week 3: Data Cleaning, Organizing, Describing, and Communicating 3.1 Visualizing your data 3.2 Joining two datasets 3.3 Discrete Predictor, Continuous Outcome 3.4 Continuous predictor and continuous outcome 3.5 Mutating Variables 3.6 Filtering and Selecting 3.7 Grouping and Summarizing", " Chapter3 Week 3: Data Cleaning, Organizing, Describing, and Communicating This week we focus on different steps you will often take when you first start working with your data. These tend to fall under the umbrella of data processing and often need to happen before you can start doing any kind of analysis. 3.1 Visualizing your data Once your data have been clearned, you are ready to start visualizing what you are working with. There is a huge range of what you can do with these plots. Thats great! On the other hand, it can quickly start to feel overwhelming. To help get this under control and make it more manageable, it is convenient to think about the types of data that you have. In particular, are your variables nominal, ordinal, interval, or ratio variables? 3.1.1 One continuous variable (either predictor or outcome variable) When you have one continuous variable, a standard option is to plot a histogram. These are plots that show the frequency of each of the values that the variable takes. Oftentimes it is helpful to create bins of values so that any number that falls in the 0-4 range counts in one bin, numbers from 5-9 are in a second bin, and so on. For this example, we will start by generating some data using rnorm(), which generates a random number (or in our case, num numbers) from a normal distribution with mean mu and standard deviation stdev. num &lt;- 50 mu &lt;- 5 stdev &lt;- 2 x &lt;- rnorm(n = num, mean = mu, sd = stdev) With these data generated, we can then quickly plot the histogram with hist(). This will use base R graphics. hist(x) You can also do this using ggplot rather than base R graphics. x_df &lt;- tibble(x_col = x) ggplot(data = x_df, mapping = aes(x = x_col)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The histogram is a very standard plot, and you should consider it a go-to option in your toolkit. Alternatively, you can use geom_density() instead of geom_histogram() to get a smooth graph rather than one with discrete bins. We will use the same data that we generated before. We will write this two ways to demnostrate how the pipe %&gt;% operator works. First way: ggplot(data = x_df, mapping = aes(x = x_col)) + geom_density() Second way: x_df %&gt;% ggplot(mapping = aes(x = x_col)) + geom_density() Just for fun, look at what happens to the the plot if you increase the sample size First, we will generate the data with a sample size of 5,000 rather than 50. num &lt;- 5000 mu &lt;- 5 stdev &lt;- 2 x &lt;- rnorm(n = num, mean = mu, sd = stdev) x_df &lt;- tibble(x_col = x) Then we will plot the histogram x_df %&gt;% ggplot(aes(x = x_col)) + geom_histogram() + labs(x = &quot;x value&quot;, y = &quot;Count&quot;, title = &quot;Histogram of normal distribution with n = 5000, mu = 5, sd = 2&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. And, finally, we can make the density plot instead of the histogram, if thats our jam. ggplot(data = x_df, mapping = aes(x = x_col)) + geom_density() 3.1.2 One Discrete Variable (either predictor or outcome) What if instead of a continuous (i.e., interval or ratio) variable we have a discrete variable such as a nominal (e.g., major, university) or ordinal (e.g., Likert scale item, level of education) variable? For that we can use something like geom_bar() or geom_col() to plot the counts of observations within each of those categories. To demonstrate this, we first need some data to work with. We will use the pre-semester, prior knowledge survey that everyone took. I have combined this years results with last years results in order to increase the sample size. After reading in the data, I will also use the clean_names() function from the janitor package. ## load in the data survey_df &lt;- read_csv(&quot;ENGE_5714_2021_pre_survey.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## student_id = col_double() ## ) ## See spec(...) for full column specifications. survey_df &lt;- survey_df %&gt;% clean_names() Next, we can go ahead and make a bar plot with the following code: survey_df %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() Notice that the ordering is not quite what we would want. It is alphabetical. Lets try to fix this. Here is one way: we first specify the levels of that variable (i.e., the different values that it could take) and store that in the variable q_levels. Then, we pass that to the factor() function, which will tell R that we want whichever variable is passed to factor() two things. First, it will say that we want to make that variable a factor variable with levels = .... Second, we set ordered = TRUE to tell R that there is a specific ordering to that variable. This way, whenever there is something like a plot that we make, the ordering will persist in the labeling and R will not show the labels in alphabetical order. Here is an example of that in action: q_levels &lt;- c(&quot;Strongly disagree&quot;, &quot;Somewhat disagree&quot;, &quot;Neither agree nor disagree&quot;, &quot;Somewhat agree&quot;, &quot;Strongly agree&quot;) survey_df$i_have_taken_a_quantitative_research_methods_course_before &lt;- factor(survey_df$i_have_taken_a_quantitative_research_methods_course_before, levels = q_levels, ordered = TRUE) Now try plotting these data. We will also add in a coord_flip() to plot the categories along the y-axis. This is a common move to avoid text from the different levels overlapping with each other. Finally, we will also change the x, y, and title labels with labs(). survey_df %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() + coord_flip() + labs(x = &quot;I have taken a quantitative research methods course before&quot;, y = &quot;Count&quot;, title = &quot;Reordered Example&quot;) 3.2 Joining two datasets Lets imagine that we have a separate dataset that has information about the students who completed the pre-course prior knowledge survey. First, we will load in that dataset survey_info_df &lt;- read_csv(&quot;survey_student_info.csv&quot;) ## Parsed with column specification: ## cols( ## student_id = col_double(), ## standing = col_character(), ## college = col_character(), ## required = col_character() ## ) Next, lets join the two datasets based on the student id column, which is in each of the two dataframes. survey_df &lt;- survey_df %&gt;% inner_join(survey_info_df, by = &quot;student_id&quot;) Now we should have both datasets joined into one and saved as survey_df. With this, we can make some nicer plots and do something like use facet_grid() to look at students who are masters and doctoral students, for example. survey_df %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() + facet_grid(standing ~.) + labs(x = &quot;I have taken a quantitative research methods course before&quot;, y = &quot;Count&quot;, title = &quot;Reordered Example&quot;) The x axis looks a little crowded. What if we try coord_flip()? survey_df %&gt;% filter(standing == &quot;doctoral&quot;) %&gt;% ggplot(aes(x = i_have_taken_a_quantitative_research_methods_course_before)) + geom_bar() + coord_flip() + facet_grid(standing ~.) + labs(x = &quot;I have taken a quantitative research methods course before&quot;, y = &quot;Count&quot;, title = &quot;Reordered Example&quot;) That looks much better. A quick note on filters If you want to look at only a subset of your data, you will want to use the filter() function. The general idea is that you can look at observations (rows) that match a certain criteria. For example, you may want to only look at students from a certain region or year or major. In our case, with the prior knowledge survey, lets say we only want to look at student who have to take the course (i.e., there is a yes for them for the required variable). We can do that with the first line. The second line just stores the result as a new dataframe called filtered_df. survey_df %&gt;% filter(required == &quot;yes&quot;) ## # A tibble: 12 x 52 ## student_id i_have_taken_a_~ i_am_interested~ i_know_what_a_t~ ## &lt;dbl&gt; &lt;ord&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Somewhat disagr~ Somewhat agree Strongly disagr~ ## 2 2 Strongly disagr~ Neither agree n~ Somewhat agree ## 3 4 Somewhat disagr~ Strongly agree Strongly disagr~ ## 4 8 Somewhat agree Somewhat agree Somewhat agree ## 5 9 Strongly disagr~ Strongly agree Somewhat agree ## 6 11 Strongly disagr~ Strongly agree Strongly disagr~ ## 7 16 Strongly agree Strongly agree Somewhat agree ## 8 17 Strongly disagr~ Strongly agree Strongly disagr~ ## 9 18 Somewhat disagr~ Somewhat agree Somewhat disagr~ ## 10 20 Strongly disagr~ Neither agree n~ Neither agree n~ ## 11 22 Strongly disagr~ Strongly agree Strongly disagr~ ## 12 23 Somewhat agree Strongly agree Somewhat agree ## # ... with 48 more variables: i_know_what_a_type_ii_error_is &lt;chr&gt;, ## # i_know_what_a_statistical_confidence_level_is &lt;chr&gt;, ## # i_know_what_a_p_value_is &lt;chr&gt;, i_know_what_p_hacking_means &lt;chr&gt;, ## # i_know_what_statistical_power_means &lt;chr&gt;, ## # i_have_heard_of_frequentist_statistics_before &lt;chr&gt;, ## # i_have_heard_of_bayesian_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_parametric_statistics_before &lt;chr&gt;, ## # i_have_heard_the_term_non_parametric_statistics_before &lt;chr&gt;, ## # i_know_what_a_histogram_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_is &lt;chr&gt;, ## # i_know_what_a_random_variable_is &lt;chr&gt;, ## # i_know_what_a_probability_distribution_function_is &lt;chr&gt;, ## # i_know_what_a_cumulative_distribution_function_is &lt;chr&gt;, ## # i_know_what_the_expectation_of_a_random_variable_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_variance_of_a_random_variable &lt;chr&gt;, ## # i_know_what_a_z_score_is &lt;chr&gt;, ## # i_know_how_to_calculate_the_correlation_between_two_variables &lt;chr&gt;, ## # i_know_how_to_interpret_the_correlation_coefficient_between_two_variables &lt;chr&gt;, ## # i_have_heard_of_linear_regression &lt;chr&gt;, ## # i_know_how_to_run_a_linear_regression_in_some_software_or_by_hand_if_im_feeling_wild &lt;chr&gt;, ## # i_know_how_to_interpret_a_linear_regression &lt;chr&gt;, ## # i_have_heard_of_multiple_regression &lt;chr&gt;, ## # i_know_how_to_perform_a_multiple_regression &lt;chr&gt;, ## # i_know_how_to_interpret_a_multiple_regression &lt;chr&gt;, ## # i_have_heard_of_logistic_regression &lt;chr&gt;, ## # i_understand_when_to_use_a_logistic_regression &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_logistic_regression &lt;chr&gt;, ## # i_have_heard_of_t_tests &lt;chr&gt;, i_have_performed_a_t_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_t_test &lt;chr&gt;, ## # i_have_heard_of_analysis_of_variance &lt;chr&gt;, ## # i_understand_when_to_run_an_analysis_of_variance_anova &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_from_an_anova &lt;chr&gt;, ## # i_have_heard_of_a_chi_square_test &lt;chr&gt;, ## # i_have_used_a_chi_square_test_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_chi_square_test &lt;chr&gt;, ## # i_have_heard_of_cluster_analysis_before &lt;chr&gt;, ## # i_have_used_cluster_analysis_before &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_cluster_analysis &lt;chr&gt;, ## # i_have_heard_of_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_have_used_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_know_how_to_interpret_the_results_of_a_factor_analysis_either_exploratory_or_confirmatory &lt;chr&gt;, ## # i_already_have_r_and_rstudio_downloaded_to_my_computer &lt;chr&gt;, ## # i_have_used_r_before &lt;chr&gt;, standing &lt;chr&gt;, college &lt;chr&gt;, required &lt;chr&gt; filtered_df &lt;- survey_df %&gt;% filter(required == &quot;yes&quot;) A little more about plotting We are going to shift gears again and look at a few different kinds of plots. The main thing to remember here is that you want to think about whether the variables you have are nominal, ordinal, or continuous (that includes interval and ratio). 3.3 Discrete Predictor, Continuous Outcome So far we have looked at plots for one variable, but of course we want to have ways to plot multiple variables simultaneously. We will start with the scneario where where we want to plot a continuous variable against a discrete variable. This can arise when you want to plot something like an assessment score and you think it may differ across groups in some way (maybe you intentionally introduced a difference by exposing the two groups to different interventions, for example). In these scenarios, a boxplot is a very standard way to go. To demonstrate this, we will simulate a situation in which we want to look at differences on an assessment. We are specificially interested in differences between chemistry and chemical engineering students. Lets go ahead and create the data by creating two groups of 20 students each. The chemical engineering students will have scores generated from a normal distribution with \\(\\mu = 85\\) and \\(\\sigma = 4\\) (i.e., a mean of 85 and a standard deviation of 4). We will say the chemistry students have scores from a normal distribution with \\(\\mu = 78\\) anad \\(\\sigma = 6\\). This about what these distributions might look like in your head. group_size &lt;- 20 chem_e_scores &lt;- rnorm(n = group_size, mean = 85, sd = 4) chem_scores &lt;- rnorm(n = group_size, mean = 78, sd = 6) data_df &lt;- tibble( discipline = rep(c(&quot;ChemE&quot;, &quot;Chemistry&quot;), each = group_size), score = c(chem_e_scores, chem_scores) ) With these data, we can then create a boxplot using geom_boxplot() data_df %&gt;% ggplot(aes(x = discipline, y = score)) + geom_boxplot() You can make a few modifications to possibly make this plot easier to read. The first is to put the discrete category on the y axis instead of the x axis. The second is to use geom_jitter() in addition to geom_boxplot() to show the individual points in each group. data_df %&gt;% ggplot(aes(y = score, x = discipline)) + geom_boxplot() + geom_jitter() 3.4 Continuous predictor and continuous outcome First, lets re-do a lot of the steps in this weeks script for reading in data and transforming it a little mydata &lt;- read_csv(&quot;Free Reduced Lunch by Schools and Grade Structures 2008-2017_final.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## div_num = col_double() ## ) ## See spec(...) for full column specifications. Check the structure of the data (this output is a bit long). str(mydata) ## tibble [2,101 x 137] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ sch_id : chr [1:2101] &quot;001-0070&quot; &quot;001-0080&quot; &quot;001-0530&quot; &quot;001-0540&quot; ... ## $ div_num : num [1:2101] 1 1 1 1 1 1 1 1 1 1 ... ## $ div_name : chr [1:2101] &quot;Accomack County&quot; &quot;Accomack County&quot; &quot;Accomack County&quot; &quot;Accomack County&quot; ... ## $ school_num : chr [1:2101] &quot;0070&lt;U+00A0&gt;&quot; &quot;0080&lt;U+00A0&gt;&quot; &quot;0530&lt;U+00A0&gt;&quot; &quot;0540&lt;U+00A0&gt;&quot; ... ## $ school_name : chr [1:2101] &quot;NANDUA HIGH&quot; &quot;CHINCOTEAGUE ELEM&quot; &quot;TANGIER COMBINED&quot; &quot;ARCADIA HIGH&quot; ... ## $ school_name2 : chr [1:2101] NA NA NA NA ... ## $ type0809 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2008 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2008 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2008 : chr [1:2101] &quot;731&quot; &quot;263&quot; &quot;80&quot; &quot;638&quot; ... ## $ total_2008 : chr [1:2101] &quot;731&quot; &quot;263&quot; &quot;80&quot; &quot;638&quot; ... ## $ snp_0809 : chr [1:2101] &quot;659&quot; &quot;257&quot; &quot;80&quot; &quot;622&quot; ... ## $ free_elig_0809: chr [1:2101] &quot;306&quot; &quot;95&quot; &quot;38&quot; &quot;289&quot; ... ## $ free_per_0809 : chr [1:2101] &quot;46.43%&quot; &quot;36.96%&quot; &quot;47.50%&quot; &quot;46.46%&quot; ... ## $ red_elig_0809 : chr [1:2101] &quot;64&quot; &quot;8&quot; &quot;0&quot; &quot;56&quot; ... ## $ red_per_0809 : chr [1:2101] &quot;9.71%&quot; &quot;3.11%&quot; &quot;0.00%&quot; &quot;9.00%&quot; ... ## $ totalFRL_0809 : chr [1:2101] &quot;370&quot; &quot;103&quot; &quot;38&quot; &quot;345&quot; ... ## $ totalper_0809 : chr [1:2101] &quot;56.15%&quot; &quot;40.08%&quot; &quot;47.50%&quot; &quot;55.47%&quot; ... ## $ type0910 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2009 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2009 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2009 : chr [1:2101] &quot;654&quot; &quot;266&quot; &quot;78&quot; &quot;634&quot; ... ## $ total_2009 : chr [1:2101] &quot;654&quot; &quot;266&quot; &quot;78&quot; &quot;634&quot; ... ## $ snp_0910 : chr [1:2101] &quot;655&quot; &quot;266&quot; &quot;78&quot; &quot;635&quot; ... ## $ free_elig_0910: chr [1:2101] &quot;290&quot; &quot;99&quot; &quot;36&quot; &quot;286&quot; ... ## $ free_per_0910 : chr [1:2101] &quot;44.27%&quot; &quot;37.22%&quot; &quot;46.15%&quot; &quot;45.04%&quot; ... ## $ red_elig_0910 : chr [1:2101] &quot;37&quot; &quot;14&quot; &quot;0&quot; &quot;66&quot; ... ## $ red_per_0910 : chr [1:2101] &quot;5.65%&quot; &quot;5.26%&quot; &quot;0.00%&quot; &quot;10.39%&quot; ... ## $ totalFRL_09010: chr [1:2101] &quot;327&quot; &quot;113&quot; &quot;36&quot; &quot;352&quot; ... ## $ totalper_0910 : chr [1:2101] &quot;49.92%&quot; &quot;42.48%&quot; &quot;46.15%&quot; &quot;55.43%&quot; ... ## $ type1011 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2010 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2010 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2010 : chr [1:2101] &quot;603&quot; &quot;268&quot; &quot;74&quot; &quot;614&quot; ... ## $ total_2010 : chr [1:2101] &quot;603&quot; &quot;268&quot; &quot;74&quot; &quot;614&quot; ... ## $ snp_1011 : chr [1:2101] &quot;603&quot; &quot;277&quot; &quot;74&quot; &quot;606&quot; ... ## $ free_elig_1011: chr [1:2101] &quot;285&quot; &quot;108&quot; &quot;32&quot; &quot;308&quot; ... ## $ free_per_1011 : chr [1:2101] &quot;47.26%&quot; &quot;38.99%&quot; &quot;43.24%&quot; &quot;50.83%&quot; ... ## $ red_elig_1011 : chr [1:2101] &quot;46&quot; &quot;8&quot; &quot;0&quot; &quot;50&quot; ... ## $ red_per_1011 : chr [1:2101] &quot;7.63%&quot; &quot;2.89%&quot; &quot;0.00%&quot; &quot;8.25%&quot; ... ## $ totalFRL_1011 : chr [1:2101] &quot;331&quot; &quot;116&quot; &quot;32&quot; &quot;358&quot; ... ## $ totalper_1011 : chr [1:2101] &quot;54.89%&quot; &quot;41.88%&quot; &quot;43.24%&quot; &quot;59.08%&quot; ... ## $ type1112 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2011 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2011 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2011 : chr [1:2101] &quot;593&quot; &quot;276&quot; &quot;73&quot; &quot;605&quot; ... ## $ total_2011 : chr [1:2101] &quot;593&quot; &quot;276&quot; &quot;73&quot; &quot;605&quot; ... ## $ snp_1112 : chr [1:2101] &quot;593&quot; &quot;281&quot; &quot;73&quot; &quot;611&quot; ... ## $ free_elig_1112: chr [1:2101] &quot;289&quot; &quot;116&quot; &quot;31&quot; &quot;318&quot; ... ## $ free_per_1112 : chr [1:2101] &quot;48.74%&quot; &quot;41.28%&quot; &quot;42.47%&quot; &quot;52.05%&quot; ... ## $ red_elig_1112 : chr [1:2101] &quot;50&quot; &quot;14&quot; &quot;0&quot; &quot;44&quot; ... ## $ red_per_1112 : chr [1:2101] &quot;8.43%&quot; &quot;4.98%&quot; &quot;0.00%&quot; &quot;7.20%&quot; ... ## $ totalFRL_1112 : chr [1:2101] &quot;339&quot; &quot;130&quot; &quot;31&quot; &quot;362&quot; ... ## $ totalper_1112 : chr [1:2101] &quot;57.17%&quot; &quot;46.26%&quot; &quot;42.47%&quot; &quot;59.25%&quot; ... ## $ type1213 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2012 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2012 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2012 : chr [1:2101] &quot;637&quot; &quot;258&quot; &quot;68&quot; &quot;579&quot; ... ## $ total_2012 : chr [1:2101] &quot;637&quot; &quot;258&quot; &quot;68&quot; &quot;579&quot; ... ## $ snp_1213 : chr [1:2101] &quot;633&quot; &quot;259&quot; &quot;68&quot; &quot;579&quot; ... ## $ free_elig_1213: chr [1:2101] &quot;324&quot; &quot;117&quot; &quot;21&quot; &quot;348&quot; ... ## $ free_per_1213 : chr [1:2101] &quot;51.18%&quot; &quot;45.17%&quot; &quot;30.88%&quot; &quot;60.10%&quot; ... ## $ red_elig_1213 : chr [1:2101] &quot;42&quot; &quot;20&quot; &quot;5&quot; &quot;33&quot; ... ## $ red_per_1213 : chr [1:2101] &quot;6.64%&quot; &quot;7.72%&quot; &quot;7.35%&quot; &quot;5.70%&quot; ... ## $ totalFRL_1213 : chr [1:2101] &quot;366&quot; &quot;137&quot; &quot;26&quot; &quot;381&quot; ... ## $ totalper_1213 : chr [1:2101] &quot;57.82%&quot; &quot;52.90%&quot; &quot;38.24%&quot; &quot;65.80%&quot; ... ## $ type1314 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2013 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2013 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2013 : chr [1:2101] &quot;670&quot; &quot;238&quot; &quot;66&quot; &quot;582&quot; ... ## $ total_2013 : chr [1:2101] &quot;670&quot; &quot;238&quot; &quot;66&quot; &quot;582&quot; ... ## $ snp_1314 : chr [1:2101] &quot;668&quot; &quot;239&quot; &quot;56&quot; &quot;589&quot; ... ## $ free_elig_1314: chr [1:2101] &quot;346&quot; &quot;102&quot; &quot;12&quot; &quot;347&quot; ... ## $ free_per_1314 : chr [1:2101] &quot;51.80%&quot; &quot;42.68%&quot; &quot;21.43%&quot; &quot;58.91%&quot; ... ## $ red_elig_1314 : chr [1:2101] &quot;44&quot; &quot;19&quot; &quot;4&quot; &quot;54&quot; ... ## $ red_per_1314 : chr [1:2101] &quot;6.59%&quot; &quot;7.95%&quot; &quot;7.14%&quot; &quot;9.17%&quot; ... ## $ totalFRL_1314 : chr [1:2101] &quot;390&quot; &quot;121&quot; &quot;16&quot; &quot;401&quot; ... ## $ totalper_1314 : chr [1:2101] &quot;58.38%&quot; &quot;50.63%&quot; &quot;28.57%&quot; &quot;68.08%&quot; ... ## $ type1415 : chr [1:2101] NA NA NA NA ... ## $ lowgrade_2014 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2014 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2014 : chr [1:2101] &quot;685&quot; &quot;251&quot; &quot;65&quot; &quot;581&quot; ... ## $ total_2014 : chr [1:2101] &quot;685&quot; &quot;251&quot; &quot;65&quot; &quot;581&quot; ... ## $ snp_1415 : chr [1:2101] &quot;672&quot; &quot;239&quot; &quot;61&quot; &quot;586&quot; ... ## $ free_elig_1415: chr [1:2101] &quot;361&quot; &quot;93&quot; &quot;14&quot; &quot;351&quot; ... ## $ free_per_1415 : chr [1:2101] &quot;53.72%&quot; &quot;38.91%&quot; &quot;22.95%&quot; &quot;59.90%&quot; ... ## $ red_elig_1415 : chr [1:2101] &quot;40&quot; &quot;17&quot; &quot;4&quot; &quot;40&quot; ... ## $ red_per_1415 : chr [1:2101] &quot;5.95%&quot; &quot;7.11%&quot; &quot;6.56%&quot; &quot;6.83%&quot; ... ## $ totalFRL_1415 : chr [1:2101] &quot;401&quot; &quot;110&quot; &quot;18&quot; &quot;391&quot; ... ## $ totalper_1415 : chr [1:2101] &quot;59.67%&quot; &quot;46.03%&quot; &quot;29.51%&quot; &quot;66.72%&quot; ... ## $ CEP_1516 : chr [1:2101] &quot;#NULL!&quot; &quot;#NULL!&quot; &quot;#NULL!&quot; &quot;#NULL!&quot; ... ## $ type1516 : chr [1:2101] &quot;SCH-HIGH&quot; &quot;SCH-ELEM&quot; &quot;SCH-COMB&quot; &quot;SCH-HIGH&quot; ... ## $ lowgrade_2015 : chr [1:2101] &quot;9&quot; &quot;PK&quot; &quot;KG&quot; &quot;9&quot; ... ## $ higrade_2015 : chr [1:2101] &quot;12&quot; &quot;5&quot; &quot;12&quot; &quot;12&quot; ... ## $ totalFT_2015 : chr [1:2101] &quot;737&quot; &quot;259&quot; &quot;65&quot; &quot;621&quot; ... ## $ total_2015 : chr [1:2101] &quot;737&quot; &quot;259&quot; &quot;65&quot; &quot;621&quot; ... ## $ snp_1516 : chr [1:2101] &quot;728&quot; &quot;268&quot; &quot;67&quot; &quot;608&quot; ... ## $ free_elig_1516: chr [1:2101] &quot;362&quot; &quot;109&quot; &quot;12&quot; &quot;339&quot; ... ## $ free_per_1516 : chr [1:2101] &quot;49.73%&quot; &quot;40.67%&quot; &quot;17.91%&quot; &quot;55.76%&quot; ... ## [list output truncated] ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. sch_id = col_character(), ## .. div_num = col_double(), ## .. div_name = col_character(), ## .. school_num = col_character(), ## .. school_name = col_character(), ## .. school_name2 = col_character(), ## .. type0809 = col_character(), ## .. lowgrade_2008 = col_character(), ## .. higrade_2008 = col_character(), ## .. totalFT_2008 = col_character(), ## .. total_2008 = col_character(), ## .. snp_0809 = col_character(), ## .. free_elig_0809 = col_character(), ## .. free_per_0809 = col_character(), ## .. red_elig_0809 = col_character(), ## .. red_per_0809 = col_character(), ## .. totalFRL_0809 = col_character(), ## .. totalper_0809 = col_character(), ## .. type0910 = col_character(), ## .. lowgrade_2009 = col_character(), ## .. higrade_2009 = col_character(), ## .. totalFT_2009 = col_character(), ## .. total_2009 = col_character(), ## .. snp_0910 = col_character(), ## .. free_elig_0910 = col_character(), ## .. free_per_0910 = col_character(), ## .. red_elig_0910 = col_character(), ## .. red_per_0910 = col_character(), ## .. totalFRL_09010 = col_character(), ## .. totalper_0910 = col_character(), ## .. type1011 = col_character(), ## .. lowgrade_2010 = col_character(), ## .. higrade_2010 = col_character(), ## .. totalFT_2010 = col_character(), ## .. total_2010 = col_character(), ## .. snp_1011 = col_character(), ## .. free_elig_1011 = col_character(), ## .. free_per_1011 = col_character(), ## .. red_elig_1011 = col_character(), ## .. red_per_1011 = col_character(), ## .. totalFRL_1011 = col_character(), ## .. totalper_1011 = col_character(), ## .. type1112 = col_character(), ## .. lowgrade_2011 = col_character(), ## .. higrade_2011 = col_character(), ## .. totalFT_2011 = col_character(), ## .. total_2011 = col_character(), ## .. snp_1112 = col_character(), ## .. free_elig_1112 = col_character(), ## .. free_per_1112 = col_character(), ## .. red_elig_1112 = col_character(), ## .. red_per_1112 = col_character(), ## .. totalFRL_1112 = col_character(), ## .. totalper_1112 = col_character(), ## .. type1213 = col_character(), ## .. lowgrade_2012 = col_character(), ## .. higrade_2012 = col_character(), ## .. totalFT_2012 = col_character(), ## .. total_2012 = col_character(), ## .. snp_1213 = col_character(), ## .. free_elig_1213 = col_character(), ## .. free_per_1213 = col_character(), ## .. red_elig_1213 = col_character(), ## .. red_per_1213 = col_character(), ## .. totalFRL_1213 = col_character(), ## .. totalper_1213 = col_character(), ## .. type1314 = col_character(), ## .. lowgrade_2013 = col_character(), ## .. higrade_2013 = col_character(), ## .. totalFT_2013 = col_character(), ## .. total_2013 = col_character(), ## .. snp_1314 = col_character(), ## .. free_elig_1314 = col_character(), ## .. free_per_1314 = col_character(), ## .. red_elig_1314 = col_character(), ## .. red_per_1314 = col_character(), ## .. totalFRL_1314 = col_character(), ## .. totalper_1314 = col_character(), ## .. type1415 = col_character(), ## .. lowgrade_2014 = col_character(), ## .. higrade_2014 = col_character(), ## .. totalFT_2014 = col_character(), ## .. total_2014 = col_character(), ## .. snp_1415 = col_character(), ## .. free_elig_1415 = col_character(), ## .. free_per_1415 = col_character(), ## .. red_elig_1415 = col_character(), ## .. red_per_1415 = col_character(), ## .. totalFRL_1415 = col_character(), ## .. totalper_1415 = col_character(), ## .. CEP_1516 = col_character(), ## .. type1516 = col_character(), ## .. lowgrade_2015 = col_character(), ## .. higrade_2015 = col_character(), ## .. totalFT_2015 = col_character(), ## .. total_2015 = col_character(), ## .. snp_1516 = col_character(), ## .. free_elig_1516 = col_character(), ## .. free_per_1516 = col_character(), ## .. red_elig_1516 = col_character(), ## .. red_Per_1516 = col_character(), ## .. totalFRL_1516 = col_character(), ## .. totalper_1516 = col_character(), ## .. CEP_1617 = col_character(), ## .. type1617 = col_character(), ## .. lowgrade_2016 = col_character(), ## .. higrade_2016 = col_character(), ## .. totalFT_2016 = col_character(), ## .. total_2016 = col_character(), ## .. snp_2016 = col_character(), ## .. free_elig_1617 = col_character(), ## .. free_per_1617 = col_character(), ## .. red_elig_1617 = col_character(), ## .. red_per_1617 = col_character(), ## .. totalFRL_1617 = col_character(), ## .. totalper_1617 = col_character(), ## .. CEP_1718 = col_character(), ## .. type1718 = col_character(), ## .. lowgrade_2017 = col_character(), ## .. higrade_2017 = col_character(), ## .. totalFT_2017 = col_character(), ## .. total_2017 = col_character(), ## .. snp_1718 = col_character(), ## .. free_elig_1718 = col_character(), ## .. free_per_1718 = col_character(), ## .. red_elig_1718 = col_character(), ## .. red_per_1718 = col_character(), ## .. totalFRL_1718 = col_character(), ## .. totalper_1718 = col_character(), ## .. stable = col_character(), ## .. new = col_character(), ## .. closed = col_character(), ## .. close_yr = col_character(), ## .. reuseid = col_character(), ## .. gradechg = col_character(), ## .. gradechg_yr = col_character(), ## .. grchgyr_2 = col_character() ## .. ) Or just check the structure of one specific variable. str(mydata$total_2017) ## chr [1:2101] &quot;742&quot; &quot;236&quot; &quot;60&quot; &quot;624&quot; &quot;286&quot; &quot;485&quot; &quot;583&quot; &quot;550&quot; &quot;600&quot; &quot;514&quot; ... NOTE: When you have a lot of variables, running this str() function is not a great idea - the output is a little too cumbersome 3.5 Mutating Variables Note that almost all of the data reads in as a character data type which are just strings, This can create issues. We know that many of the columns are actually storing numbers or numeric values as R refers to them. We need to fix this. Lets tell R that these columns (at least the two we are going to use) are numeric. We are going to see two interchangeable ways to do this. First, we use the $ operator which lets me specify a specific column within my data frame in combination with the as.numeric() function mydata$total_2017&lt;-as.numeric(mydata$total_2017) mydata$totalFRL_1718&lt;-as.numeric(mydata$totalFRL_1718) Some columns have a percent symbol, which you will need to remove before coercing to numeric data type mydata &lt;- mydata %&gt;% mutate(totalper_0809 = str_remove(totalper_0809, &quot;%&quot;)) Then we can change the column from character to numeric mydata$totalper_0809 &lt;- as.numeric(mydata$totalper_0809) ## Warning: NAs introduced by coercion Check to make sure it converted the column type correctly using str(). str(mydata$totalper_0809) ## num [1:2101] 56.1 40.1 47.5 55.5 33.4 ... Second, alternatively, we can do this for a whole set of variables at once. We just need to specify a matching criteria. newdf &lt;- mydata %&gt;% mutate_at(vars(starts_with(&quot;total&quot;)), as.numeric) ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion newdf &lt;- newdf %&gt;% mutate_at(vars(starts_with(&quot;totalFRL&quot;)), as.numeric) Check whether the old and new variables are stored differently (old as a character, new as a numeric variable) str(mydata$total_2008) ## chr [1:2101] &quot;731&quot; &quot;263&quot; &quot;80&quot; &quot;638&quot; &quot;333&quot; &quot;536&quot; &quot;610&quot; &quot;490&quot; &quot;585&quot; &quot;450&quot; ... str(newdf$total_2008) ## num [1:2101] 731 263 80 638 333 536 610 490 585 450 ... 3.6 Filtering and Selecting A basic operation we do a lot is to filter the data so that we are working with a subset of all that we have. We can do this with the filter() function, part of the dplyr package (in the tidyverse collection of packages). Lets say we want to look at the schools with div_num values less than 50. newdf %&gt;% filter(div_num &lt; 50) ## # A tibble: 800 x 137 ## sch_id div_num div_name school_num school_name school_name2 type0809 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001-0~ 1 Accomac~ &quot;0070\\xa0&quot; NANDUA HIGH &lt;NA&gt; SCH-HIGH ## 2 001-0~ 1 Accomac~ &quot;0080\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-ELEM ## 3 001-0~ 1 Accomac~ &quot;0530\\xa0&quot; TANGIER CO~ &lt;NA&gt; SCH-COMB ## 4 001-0~ 1 Accomac~ &quot;0540\\xa0&quot; ARCADIA HI~ &lt;NA&gt; SCH-HIGH ## 5 001-0~ 1 Accomac~ &quot;0580\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-COMB ## 6 001-0~ 1 Accomac~ &quot;0590\\xa0&quot; PUNGOTEAGU~ &lt;NA&gt; SCH-ELEM ## 7 001-0~ 1 Accomac~ &quot;0600\\xa0&quot; KEGOTANK E~ &lt;NA&gt; SCH-ELEM ## 8 001-0~ 1 Accomac~ &quot;0701\\xa0&quot; ACCAWMACKE~ &lt;NA&gt; SCH-ELEM ## 9 001-0~ 1 Accomac~ &quot;0702\\xa0&quot; METOMPKIN ~ &lt;NA&gt; SCH-ELEM ## 10 001-0~ 1 Accomac~ &quot;0703\\xa0&quot; NANDUA MID~ &lt;NA&gt; SCH-MID ## # ... with 790 more rows, and 130 more variables: lowgrade_2008 &lt;chr&gt;, ## # higrade_2008 &lt;chr&gt;, totalFT_2008 &lt;dbl&gt;, total_2008 &lt;dbl&gt;, snp_0809 &lt;chr&gt;, ## # free_elig_0809 &lt;chr&gt;, free_per_0809 &lt;chr&gt;, red_elig_0809 &lt;chr&gt;, ## # red_per_0809 &lt;chr&gt;, totalFRL_0809 &lt;dbl&gt;, totalper_0809 &lt;dbl&gt;, ## # type0910 &lt;chr&gt;, lowgrade_2009 &lt;chr&gt;, higrade_2009 &lt;chr&gt;, ## # totalFT_2009 &lt;dbl&gt;, total_2009 &lt;dbl&gt;, snp_0910 &lt;chr&gt;, free_elig_0910 &lt;chr&gt;, ## # free_per_0910 &lt;chr&gt;, red_elig_0910 &lt;chr&gt;, red_per_0910 &lt;chr&gt;, ## # totalFRL_09010 &lt;dbl&gt;, totalper_0910 &lt;dbl&gt;, type1011 &lt;chr&gt;, ## # lowgrade_2010 &lt;chr&gt;, higrade_2010 &lt;chr&gt;, totalFT_2010 &lt;dbl&gt;, ## # total_2010 &lt;dbl&gt;, snp_1011 &lt;chr&gt;, free_elig_1011 &lt;chr&gt;, ## # free_per_1011 &lt;chr&gt;, red_elig_1011 &lt;chr&gt;, red_per_1011 &lt;chr&gt;, ## # totalFRL_1011 &lt;dbl&gt;, totalper_1011 &lt;dbl&gt;, type1112 &lt;chr&gt;, ## # lowgrade_2011 &lt;chr&gt;, higrade_2011 &lt;chr&gt;, totalFT_2011 &lt;dbl&gt;, ## # total_2011 &lt;dbl&gt;, snp_1112 &lt;chr&gt;, free_elig_1112 &lt;chr&gt;, ## # free_per_1112 &lt;chr&gt;, red_elig_1112 &lt;chr&gt;, red_per_1112 &lt;chr&gt;, ## # totalFRL_1112 &lt;dbl&gt;, totalper_1112 &lt;dbl&gt;, type1213 &lt;chr&gt;, ## # lowgrade_2012 &lt;chr&gt;, higrade_2012 &lt;chr&gt;, totalFT_2012 &lt;dbl&gt;, ## # total_2012 &lt;dbl&gt;, snp_1213 &lt;chr&gt;, free_elig_1213 &lt;chr&gt;, ## # free_per_1213 &lt;chr&gt;, red_elig_1213 &lt;chr&gt;, red_per_1213 &lt;chr&gt;, ## # totalFRL_1213 &lt;dbl&gt;, totalper_1213 &lt;dbl&gt;, type1314 &lt;chr&gt;, ## # lowgrade_2013 &lt;chr&gt;, higrade_2013 &lt;chr&gt;, totalFT_2013 &lt;dbl&gt;, ## # total_2013 &lt;dbl&gt;, snp_1314 &lt;chr&gt;, free_elig_1314 &lt;chr&gt;, ## # free_per_1314 &lt;chr&gt;, red_elig_1314 &lt;chr&gt;, red_per_1314 &lt;chr&gt;, ## # totalFRL_1314 &lt;dbl&gt;, totalper_1314 &lt;dbl&gt;, type1415 &lt;chr&gt;, ## # lowgrade_2014 &lt;chr&gt;, higrade_2014 &lt;chr&gt;, totalFT_2014 &lt;dbl&gt;, ## # total_2014 &lt;dbl&gt;, snp_1415 &lt;chr&gt;, free_elig_1415 &lt;chr&gt;, ## # free_per_1415 &lt;chr&gt;, red_elig_1415 &lt;chr&gt;, red_per_1415 &lt;chr&gt;, ## # totalFRL_1415 &lt;dbl&gt;, totalper_1415 &lt;dbl&gt;, CEP_1516 &lt;chr&gt;, type1516 &lt;chr&gt;, ## # lowgrade_2015 &lt;chr&gt;, higrade_2015 &lt;chr&gt;, totalFT_2015 &lt;dbl&gt;, ## # total_2015 &lt;dbl&gt;, snp_1516 &lt;chr&gt;, free_elig_1516 &lt;chr&gt;, ## # free_per_1516 &lt;chr&gt;, red_elig_1516 &lt;chr&gt;, red_Per_1516 &lt;chr&gt;, ## # totalFRL_1516 &lt;dbl&gt;, totalper_1516 &lt;dbl&gt;, CEP_1617 &lt;chr&gt;, type1617 &lt;chr&gt;, ## # lowgrade_2016 &lt;chr&gt;, higrade_2016 &lt;chr&gt;, ... Or, if we want to look at schools where the highest grade in 2008 was grade five, we can try: newdf %&gt;% filter(higrade_2008 == &quot;5&quot;) # this returns a subsetted dataframe with 878 rows ## # A tibble: 878 x 137 ## sch_id div_num div_name school_num school_name school_name2 type0809 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001-0~ 1 Accomac~ &quot;0080\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-ELEM ## 2 001-0~ 1 Accomac~ &quot;0590\\xa0&quot; PUNGOTEAGU~ &lt;NA&gt; SCH-ELEM ## 3 001-0~ 1 Accomac~ &quot;0600\\xa0&quot; KEGOTANK E~ &lt;NA&gt; SCH-ELEM ## 4 001-0~ 1 Accomac~ &quot;0701\\xa0&quot; ACCAWMACKE~ &lt;NA&gt; SCH-ELEM ## 5 001-0~ 1 Accomac~ &quot;0702\\xa0&quot; METOMPKIN ~ &lt;NA&gt; SCH-ELEM ## 6 002-0~ 2 Albemar~ &quot;0010\\xa0&quot; HOLLYMEAD ~ &lt;NA&gt; SCH-ELEM ## 7 002-0~ 2 Albemar~ &quot;0030\\xa0&quot; SCOTTSVILL~ &lt;NA&gt; SCH-ELEM ## 8 002-0~ 2 Albemar~ &quot;0040\\xa0&quot; MARY CARR ~ &lt;NA&gt; SCH-ELEM ## 9 002-0~ 2 Albemar~ &quot;0100\\xa0&quot; BROADUS WO~ &lt;NA&gt; SCH-ELEM ## 10 002-0~ 2 Albemar~ &quot;0150\\xa0&quot; PAUL H CAL~ &lt;NA&gt; SCH-ELEM ## # ... with 868 more rows, and 130 more variables: lowgrade_2008 &lt;chr&gt;, ## # higrade_2008 &lt;chr&gt;, totalFT_2008 &lt;dbl&gt;, total_2008 &lt;dbl&gt;, snp_0809 &lt;chr&gt;, ## # free_elig_0809 &lt;chr&gt;, free_per_0809 &lt;chr&gt;, red_elig_0809 &lt;chr&gt;, ## # red_per_0809 &lt;chr&gt;, totalFRL_0809 &lt;dbl&gt;, totalper_0809 &lt;dbl&gt;, ## # type0910 &lt;chr&gt;, lowgrade_2009 &lt;chr&gt;, higrade_2009 &lt;chr&gt;, ## # totalFT_2009 &lt;dbl&gt;, total_2009 &lt;dbl&gt;, snp_0910 &lt;chr&gt;, free_elig_0910 &lt;chr&gt;, ## # free_per_0910 &lt;chr&gt;, red_elig_0910 &lt;chr&gt;, red_per_0910 &lt;chr&gt;, ## # totalFRL_09010 &lt;dbl&gt;, totalper_0910 &lt;dbl&gt;, type1011 &lt;chr&gt;, ## # lowgrade_2010 &lt;chr&gt;, higrade_2010 &lt;chr&gt;, totalFT_2010 &lt;dbl&gt;, ## # total_2010 &lt;dbl&gt;, snp_1011 &lt;chr&gt;, free_elig_1011 &lt;chr&gt;, ## # free_per_1011 &lt;chr&gt;, red_elig_1011 &lt;chr&gt;, red_per_1011 &lt;chr&gt;, ## # totalFRL_1011 &lt;dbl&gt;, totalper_1011 &lt;dbl&gt;, type1112 &lt;chr&gt;, ## # lowgrade_2011 &lt;chr&gt;, higrade_2011 &lt;chr&gt;, totalFT_2011 &lt;dbl&gt;, ## # total_2011 &lt;dbl&gt;, snp_1112 &lt;chr&gt;, free_elig_1112 &lt;chr&gt;, ## # free_per_1112 &lt;chr&gt;, red_elig_1112 &lt;chr&gt;, red_per_1112 &lt;chr&gt;, ## # totalFRL_1112 &lt;dbl&gt;, totalper_1112 &lt;dbl&gt;, type1213 &lt;chr&gt;, ## # lowgrade_2012 &lt;chr&gt;, higrade_2012 &lt;chr&gt;, totalFT_2012 &lt;dbl&gt;, ## # total_2012 &lt;dbl&gt;, snp_1213 &lt;chr&gt;, free_elig_1213 &lt;chr&gt;, ## # free_per_1213 &lt;chr&gt;, red_elig_1213 &lt;chr&gt;, red_per_1213 &lt;chr&gt;, ## # totalFRL_1213 &lt;dbl&gt;, totalper_1213 &lt;dbl&gt;, type1314 &lt;chr&gt;, ## # lowgrade_2013 &lt;chr&gt;, higrade_2013 &lt;chr&gt;, totalFT_2013 &lt;dbl&gt;, ## # total_2013 &lt;dbl&gt;, snp_1314 &lt;chr&gt;, free_elig_1314 &lt;chr&gt;, ## # free_per_1314 &lt;chr&gt;, red_elig_1314 &lt;chr&gt;, red_per_1314 &lt;chr&gt;, ## # totalFRL_1314 &lt;dbl&gt;, totalper_1314 &lt;dbl&gt;, type1415 &lt;chr&gt;, ## # lowgrade_2014 &lt;chr&gt;, higrade_2014 &lt;chr&gt;, totalFT_2014 &lt;dbl&gt;, ## # total_2014 &lt;dbl&gt;, snp_1415 &lt;chr&gt;, free_elig_1415 &lt;chr&gt;, ## # free_per_1415 &lt;chr&gt;, red_elig_1415 &lt;chr&gt;, red_per_1415 &lt;chr&gt;, ## # totalFRL_1415 &lt;dbl&gt;, totalper_1415 &lt;dbl&gt;, CEP_1516 &lt;chr&gt;, type1516 &lt;chr&gt;, ## # lowgrade_2015 &lt;chr&gt;, higrade_2015 &lt;chr&gt;, totalFT_2015 &lt;dbl&gt;, ## # total_2015 &lt;dbl&gt;, snp_1516 &lt;chr&gt;, free_elig_1516 &lt;chr&gt;, ## # free_per_1516 &lt;chr&gt;, red_elig_1516 &lt;chr&gt;, red_Per_1516 &lt;chr&gt;, ## # totalFRL_1516 &lt;dbl&gt;, totalper_1516 &lt;dbl&gt;, CEP_1617 &lt;chr&gt;, type1617 &lt;chr&gt;, ## # lowgrade_2016 &lt;chr&gt;, higrade_2016 &lt;chr&gt;, ... Note that we had to set it equal to the character value 5 rather than the numeric value 5. Why? If we wanted to filter on numeric values instead, we would want to do something like this: newdf %&gt;% mutate(higrade_2008 = as.numeric(higrade_2008)) %&gt;% filter(higrade_2008 == 5) # again, this returns a subsetted dataframe with 878 rows ## Warning in mask$eval_all_mutate(dots[[i]]): NAs introduced by coercion ## # A tibble: 878 x 137 ## sch_id div_num div_name school_num school_name school_name2 type0809 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001-0~ 1 Accomac~ &quot;0080\\xa0&quot; CHINCOTEAG~ &lt;NA&gt; SCH-ELEM ## 2 001-0~ 1 Accomac~ &quot;0590\\xa0&quot; PUNGOTEAGU~ &lt;NA&gt; SCH-ELEM ## 3 001-0~ 1 Accomac~ &quot;0600\\xa0&quot; KEGOTANK E~ &lt;NA&gt; SCH-ELEM ## 4 001-0~ 1 Accomac~ &quot;0701\\xa0&quot; ACCAWMACKE~ &lt;NA&gt; SCH-ELEM ## 5 001-0~ 1 Accomac~ &quot;0702\\xa0&quot; METOMPKIN ~ &lt;NA&gt; SCH-ELEM ## 6 002-0~ 2 Albemar~ &quot;0010\\xa0&quot; HOLLYMEAD ~ &lt;NA&gt; SCH-ELEM ## 7 002-0~ 2 Albemar~ &quot;0030\\xa0&quot; SCOTTSVILL~ &lt;NA&gt; SCH-ELEM ## 8 002-0~ 2 Albemar~ &quot;0040\\xa0&quot; MARY CARR ~ &lt;NA&gt; SCH-ELEM ## 9 002-0~ 2 Albemar~ &quot;0100\\xa0&quot; BROADUS WO~ &lt;NA&gt; SCH-ELEM ## 10 002-0~ 2 Albemar~ &quot;0150\\xa0&quot; PAUL H CAL~ &lt;NA&gt; SCH-ELEM ## # ... with 868 more rows, and 130 more variables: lowgrade_2008 &lt;chr&gt;, ## # higrade_2008 &lt;dbl&gt;, totalFT_2008 &lt;dbl&gt;, total_2008 &lt;dbl&gt;, snp_0809 &lt;chr&gt;, ## # free_elig_0809 &lt;chr&gt;, free_per_0809 &lt;chr&gt;, red_elig_0809 &lt;chr&gt;, ## # red_per_0809 &lt;chr&gt;, totalFRL_0809 &lt;dbl&gt;, totalper_0809 &lt;dbl&gt;, ## # type0910 &lt;chr&gt;, lowgrade_2009 &lt;chr&gt;, higrade_2009 &lt;chr&gt;, ## # totalFT_2009 &lt;dbl&gt;, total_2009 &lt;dbl&gt;, snp_0910 &lt;chr&gt;, free_elig_0910 &lt;chr&gt;, ## # free_per_0910 &lt;chr&gt;, red_elig_0910 &lt;chr&gt;, red_per_0910 &lt;chr&gt;, ## # totalFRL_09010 &lt;dbl&gt;, totalper_0910 &lt;dbl&gt;, type1011 &lt;chr&gt;, ## # lowgrade_2010 &lt;chr&gt;, higrade_2010 &lt;chr&gt;, totalFT_2010 &lt;dbl&gt;, ## # total_2010 &lt;dbl&gt;, snp_1011 &lt;chr&gt;, free_elig_1011 &lt;chr&gt;, ## # free_per_1011 &lt;chr&gt;, red_elig_1011 &lt;chr&gt;, red_per_1011 &lt;chr&gt;, ## # totalFRL_1011 &lt;dbl&gt;, totalper_1011 &lt;dbl&gt;, type1112 &lt;chr&gt;, ## # lowgrade_2011 &lt;chr&gt;, higrade_2011 &lt;chr&gt;, totalFT_2011 &lt;dbl&gt;, ## # total_2011 &lt;dbl&gt;, snp_1112 &lt;chr&gt;, free_elig_1112 &lt;chr&gt;, ## # free_per_1112 &lt;chr&gt;, red_elig_1112 &lt;chr&gt;, red_per_1112 &lt;chr&gt;, ## # totalFRL_1112 &lt;dbl&gt;, totalper_1112 &lt;dbl&gt;, type1213 &lt;chr&gt;, ## # lowgrade_2012 &lt;chr&gt;, higrade_2012 &lt;chr&gt;, totalFT_2012 &lt;dbl&gt;, ## # total_2012 &lt;dbl&gt;, snp_1213 &lt;chr&gt;, free_elig_1213 &lt;chr&gt;, ## # free_per_1213 &lt;chr&gt;, red_elig_1213 &lt;chr&gt;, red_per_1213 &lt;chr&gt;, ## # totalFRL_1213 &lt;dbl&gt;, totalper_1213 &lt;dbl&gt;, type1314 &lt;chr&gt;, ## # lowgrade_2013 &lt;chr&gt;, higrade_2013 &lt;chr&gt;, totalFT_2013 &lt;dbl&gt;, ## # total_2013 &lt;dbl&gt;, snp_1314 &lt;chr&gt;, free_elig_1314 &lt;chr&gt;, ## # free_per_1314 &lt;chr&gt;, red_elig_1314 &lt;chr&gt;, red_per_1314 &lt;chr&gt;, ## # totalFRL_1314 &lt;dbl&gt;, totalper_1314 &lt;dbl&gt;, type1415 &lt;chr&gt;, ## # lowgrade_2014 &lt;chr&gt;, higrade_2014 &lt;chr&gt;, totalFT_2014 &lt;dbl&gt;, ## # total_2014 &lt;dbl&gt;, snp_1415 &lt;chr&gt;, free_elig_1415 &lt;chr&gt;, ## # free_per_1415 &lt;chr&gt;, red_elig_1415 &lt;chr&gt;, red_per_1415 &lt;chr&gt;, ## # totalFRL_1415 &lt;dbl&gt;, totalper_1415 &lt;dbl&gt;, CEP_1516 &lt;chr&gt;, type1516 &lt;chr&gt;, ## # lowgrade_2015 &lt;chr&gt;, higrade_2015 &lt;chr&gt;, totalFT_2015 &lt;dbl&gt;, ## # total_2015 &lt;dbl&gt;, snp_1516 &lt;chr&gt;, free_elig_1516 &lt;chr&gt;, ## # free_per_1516 &lt;chr&gt;, red_elig_1516 &lt;chr&gt;, red_Per_1516 &lt;chr&gt;, ## # totalFRL_1516 &lt;dbl&gt;, totalper_1516 &lt;dbl&gt;, CEP_1617 &lt;chr&gt;, type1617 &lt;chr&gt;, ## # lowgrade_2016 &lt;chr&gt;, higrade_2016 &lt;chr&gt;, ... 3.7 Grouping and Summarizing Lets shift gears to a different combination of operations Lets go ahead and try using tidyverse to narrow to what we want. Imagine we want to see the county level aggregate numbers for FRL in the 2017-2018 school year. We will start out with our entire data frame and then use pipes (the %&gt;% operator) to work from there. The final result will be stored in our new data frame that we are creating, called county_level_aggregate. First, select will pick columns Next, group_by and summarize work together to get us our aggregate totals. county_level_aggregate &lt;- newdf %&gt;% select(div_name, total_2017, totalFRL_1718) %&gt;% group_by(div_name) %&gt;% summarize(totalstudents = sum(total_2017), totalFRL = sum(totalFRL_1718)) ## `summarise()` ungrouping output (override with `.groups` argument) Now, we can compute percentages if we like and we can specify a new column by referring to. One that doesnt exist yet but will after we run this code. We will do this two interchangeable ways. First, the old school way: county_level_aggregate$percent_FRL &lt;- county_level_aggregate$totalFRL/county_level_aggregate$totalstudents*100 Second, the tidyverse way: county_level_aggregate &lt;- county_level_aggregate %&gt;% mutate(percent_frl = totalFRL / totalstudents * 100) Just for fun, lets see how this could have been incorporated into our summarize call county_level_percents &lt;- newdf %&gt;% select(div_name, total_2017, totalFRL_1718) %&gt;% group_by(div_name) %&gt;% summarize(percentFRL=sum(totalFRL_1718)/sum(total_2017) * 100) ## `summarise()` ungrouping output (override with `.groups` argument) Something is going to look weird with this plot newdf %&gt;% ggplot(aes(totalFRL_0809, totalFT_2008)) + geom_point() + labs(title = &quot;FRL 2008&quot;, x = &quot;totalFRL_0809&quot;) ## Warning: Removed 236 rows containing missing values (geom_point). Lets see if we can fix it newdf %&gt;% filter(!is.na(totalFRL_0809)) %&gt;% ggplot(aes(totalFRL_0809, totalFT_2008)) + geom_point() + labs(title = &quot;FRL 2008&quot;, x = &quot;totalFRL_0809&quot;) + xlim(0, 1000) + ylim(0, 1000) ## Warning: Removed 324 rows containing missing values (geom_point). "],["week-4-assumptions-and-correlations.html", "Chapter4 Week 4: Assumptions and Correlations 4.1 Assumptions 4.2 Correlation 4.3 Another worked example for cleaning and prelim analysis", " Chapter4 Week 4: Assumptions and Correlations This week we will be discussing Chapters 5 and 6 from DSUR. These notes will pull out some of the important pieces from each chapter. 4.1 Assumptions These assumptions that we are making are helpful when determining whether we should be using parametric vs non-parametric statistical tests. What does parametric mean here? It means that the data are from a parameterized distribution (i.e., parameters characterize the distribution that the data come from). An example of a parameterized distribution that we have already seen is the normal distribution. The two parameters for the normal distribution are \\(\\mu\\) for the mean and \\(\\sigma\\) for the standard deviation. We have seen this altogether with this kind of notation to denote that \\(x_i\\) is from a normal distribution: \\(x_i \\sim \\mathcal{N} (\\mu, \\,\\sigma^{2})\\) 4.1.1 Normally distributed data This assumption is about the normality of the sampling distribution. The big idea here is that we tend to operate under the belief that if our sampled data are normally distributed then the underlying sampling distribution is also normally distributed. Also, keep in mind that this becomes less of a concern as our sample size increases (thank, Central Limit Theorem!). There are several tests for normality that we will discuss, which include either (a) calculations or (b) visual examination. We will discuss both. 4.1.1.1 Visual check of normality You can accomplish this with a histogram (e.g., hist() or geom_histogram() or a q-q plot qplot() (which stands for quantile-quantile). 4.1.2 Homogeneity of variance Here, you want to know whether the variance of a variable is the same across different groups. For example, if you are looking at test scores in chemistry and chemical engineering students, you want to know if the variances (spread) of the test scores in the chemistry group and the chemical engineering group are close to each other. 4.1.3 Interval data This might be a little redundant given that we want normally distributed data, but you want at least interval data (ratio data are also fine, but in practice very few things we work with actually qualify as ratio variables). If you have ordinal or nominal variables, you might be in trouble with this assumption 4.1.4 Independence This assumption is about the observations not being related to each other or affecting each other in some way. In practice, this can also be a little tricky. For example, if you are sampling students from different classrooms, depending on the variables you are measuring, you might actually have reason to believe that students in one classroom are more related to each other than students in a different classroom. In practice, you can handle this with a multi-level model (aka hierarchical model), but that is beyond the scope of this class. 4.2 Correlation 4.2.1 Covariance First, start with the observation that variance is calculated with: \\(Variance(s^2) = \\frac{\\sum(x_i - \\overline{x})^2}{N - 1} = \\frac{\\sum(x_i - \\overline{x})(x_i - \\overline{x})}{N - 1}\\) But now lets say that we want to know how, for each observation we have, how does the value of \\(x\\) vary with the value of \\(y\\) on average. For example, when the value of \\(x\\) increases, does the value of \\(y\\) also increase? This could happen when \\(x\\) represents the number of hours of sleep you get each night and \\(y\\) is your average grade on an exam you take the next day. The opposite could arise when \\(x\\) increases but we expect \\(y\\) to go down. An example of this might be when \\(x\\) is the number of hilarious jokes that a teacher tells in class and \\(y\\) is the number of students who fall asleep in class. As the number of jokes increases, we might expect/hope that it keeps students attention and keeps them from dozing. This generally process of considering how one variable changes when another variable changes is where the notion of covariance comes in. In practice, what we really want to know is: when \\(x_i\\) is above its average value in a sample (\\(\\overline{x}\\)), how does \\(y_i\\) change? Does it also tend to be above the sample average for \\(y\\) (\\(\\overline{y}\\))? This is expressed in the general formular for covariance: \\(cov(x,y) = \\frac{\\sum(x_i - \\overline{x})(y_i - \\overline{y})}{N - 1}\\) While covariance can be a helpful value to work with in many settings, for most of what we do in this class, we will be using correlation coefficients instead of covariance. This is because covariance is an unnormalized value, which can make comparisons across different ranges of values difficult. 4.2.2 Correlation coefficient In order to standardize the covariance to a value the is easier to work with across ranges of values, we use the correlatoin coefficient. There are several version of this, depending on the type of data you are working with. The most basic version is the Pearson correlation coefficient. It is calculated by dividing the covariance by the standard deviations of your two variables of interest: \\(r = \\frac{cov_{xy}}{s_xs_y} = \\frac{\\sum(x_i - \\overline{x})(y_i - \\overline{y})}{(N-1)s_xs_y}\\) This is a bivariate correlation coefficient because it is looking at the correlation between two variables. There are also partial correlation coefficients, which look at the correlation between two variables whil controlling for other variables. We can calculate the correlatoin between two variables using the cor() or cor.test() functions, which are part of base R. 4.3 Another worked example for cleaning and prelim analysis This script takes an incomplete subset of senior data from a .csv file, cleans it, computes factor scores, and prepares it for analysis. If you have not already done so, make sure that you have run library(tidyverse) and library(psych) since we will be using functions from both of those packages. 4.3.1 Loading in data First, as usual, load in your data. We will use the file seniorsurvey.csv for this demo. file_path &lt;- \"YOUR PATH HERE\" setwd(file_path) use this command to change the working directory to the folder where you have your file list.files() run this to make sure that your file is in your current working directory seniorSurvey_df &lt;- read_csv(&quot;seniorsurvey.csv&quot;) # replace text in the parentheses with your file name ## Parsed with column specification: ## cols( ## .default = col_double() ## ) ## See spec(...) for full column specifications. 4.3.2 Data prep and cleaning After loading, it is always nice to just see how things loaded in. Functions like str() and describe() from the psych package are nice for this. For example, if we use describe(), we can see the following (we deleted some variables): psych::describe(seniorSurvey_df) ## vars n mean sd median ## What is your PRIMARY MAJOR? 1 1849 31.79 20.43 29 ## Internship, field experience, co-op, or practicum 2 1121 1.00 0.00 1 ## ParticipateServiceL 3 489 1.00 0.00 1 ## ParticipateCService 4 1296 1.00 0.00 1 ## ParticipateStudyAbroadSemester 5 142 1.00 0.00 1 ## SJ1 6 1733 2.32 1.03 2 ## SJ2 7 1732 2.08 0.96 2 ## SJ3 8 1731 2.77 0.88 3 ## SJ4 9 1726 2.27 1.01 2 ## SJ5 10 1728 3.27 0.92 3 ## SJ6 11 1719 3.50 0.83 4 ## SJ7 12 1719 4.01 0.79 4 ## SJ8 13 1719 4.15 0.83 4 ## DA1 14 1719 2.23 0.93 2 ## DA2 15 1719 2.86 0.95 3 ## DA3 16 1720 1.97 0.81 2 ## DA4 17 1721 4.20 0.72 4 ## DA5 18 1721 4.06 0.81 4 ## LocalRole 19 1453 3.49 0.94 4 ## LocalFinance 20 1453 3.22 0.90 3 ## LocalTime 21 1453 3.58 0.89 4 ## GlobalRole 22 1446 3.57 0.99 4 ## GlobalFinance 23 1449 3.19 1.00 3 ## GlobalTime 24 1449 3.42 0.98 3 ## Your gender? 25 1678 1.49 0.50 1 ## trimmed mad min max range ## What is your PRIMARY MAJOR? 31.25 28.17 1 70 69 ## Internship, field experience, co-op, or practicum 1.00 0.00 1 1 0 ## ParticipateServiceL 1.00 0.00 1 1 0 ## ParticipateCService 1.00 0.00 1 1 0 ## ParticipateStudyAbroadSemester 1.00 0.00 1 1 0 ## SJ1 2.25 1.48 1 5 4 ## SJ2 1.98 1.48 1 5 4 ## SJ3 2.79 1.48 1 5 4 ## SJ4 2.20 1.48 1 5 4 ## SJ5 3.27 1.48 1 5 4 ## SJ6 3.54 1.48 1 5 4 ## SJ7 4.07 0.00 1 5 4 ## SJ8 4.23 1.48 1 5 4 ## DA1 2.15 1.48 1 5 4 ## DA2 2.89 1.48 1 5 4 ## DA3 1.90 0.00 1 5 4 ## DA4 4.27 1.48 1 5 4 ## DA5 4.11 1.48 1 5 4 ## LocalRole 3.51 1.48 1 5 4 ## LocalFinance 3.23 1.48 1 5 4 ## LocalTime 3.63 1.48 1 5 4 ## GlobalRole 3.62 1.48 1 5 4 ## GlobalFinance 3.18 1.48 1 5 4 ## GlobalTime 3.44 1.48 1 5 4 ## Your gender? 1.49 0.00 1 2 1 ## skew kurtosis se ## What is your PRIMARY MAJOR? 0.18 -1.33 0.48 ## Internship, field experience, co-op, or practicum NaN NaN 0.00 ## ParticipateServiceL NaN NaN 0.00 ## ParticipateCService NaN NaN 0.00 ## ParticipateStudyAbroadSemester NaN NaN 0.00 ## SJ1 0.46 -0.51 0.02 ## SJ2 0.64 -0.16 0.02 ## SJ3 -0.03 -0.14 0.02 ## SJ4 0.52 -0.40 0.02 ## SJ5 -0.19 -0.03 0.02 ## SJ6 -0.40 0.15 0.02 ## SJ7 -0.75 1.05 0.02 ## SJ8 -0.86 0.69 0.02 ## DA1 0.57 -0.11 0.02 ## DA2 -0.09 -0.41 0.02 ## DA3 0.70 0.31 0.02 ## DA4 -0.66 0.54 0.02 ## DA5 -0.59 0.16 0.02 ## LocalRole -0.44 -0.33 0.02 ## LocalFinance -0.19 -0.27 0.02 ## LocalTime -0.59 0.22 0.02 ## GlobalRole -0.47 -0.30 0.03 ## GlobalFinance -0.11 -0.33 0.03 ## GlobalTime -0.35 -0.17 0.03 ## Your gender? 0.03 -2.00 0.01 Upon examining this, we can notice a few things: Primary Major variable is all messed up. We wont fix it here, but basically there is a numeric code needed (e.g., 13 = underwater basket weaving) Columns 3 and 5 have lots of missing values (note the small Ns)  this means that this was asked via checkbox so (1) is true and missing is not missing but False SJ1-8 and DA1-5 all look essentially ok  about the same N (some survey fatigue or skips) but all values in range (1-5) Now, we know that SJ and DA are scales from the literature and we want to compute scale scores for those. Typically for attitude scales like these we just report means across the items. So, we will use the psych package to use a built in function to help us with this. If you have not used psych yet, be sure it is installed using the command install.packages(psych)  you need only do this once and then in subsequent uses you only need library(psych) to tell R to look in that package for the functions you will be using. library(psych) Subset out only the SJ and DA items in their own dataframe and then use tools in the psych package to compute scale means The first method to do this - use numbering of the columns: seniorSurveyScales_df &lt;- seniorSurvey_df[6:18] A second method to do this - use select() from dplyr seniorSurveyScales_df &lt;- seniorSurvey_df %&gt;% select(SJ1:DA5) Use the make.keys() function from psych package to key-in how the scales are built (mapping items to scales, use - for reverse scored items) my_keys &lt;- make.keys(seniorSurveyScales_df, list(SJCa=c(-1,-2,-3,-4),SJCh=c(5,6,7),DA=c(-9,-10,-11,12,13))) Use scoreItems function to score each respondent on the three scales of interest SJCa, SJCh, and DA  the default here in scoreItems is to takes the mean of the items (not additive though that is sometimes used) and also, it imputes missing values instead of dropping cases the scoreItems function calculates many things. At this stage, all we really want are the scores, so we include a line to only extract that info. my_scales &lt;- scoreItems(my_keys, seniorSurveyScales_df) my_scores &lt;- my_scales$scores Now, if you view the first few rows of the my.scores vector using the header  head() command  it looks like we expect: head(my_scores) ## SJCa SJCh DA ## [1,] 2.75 3.000000 3.2 ## [2,] 3.75 3.333333 4.2 ## [3,] 3.00 3.000000 3.0 ## [4,] 2.25 4.333333 3.6 ## [5,] 3.00 3.333333 3.4 ## [6,] 4.50 4.333333 3.4 Now, lets build a clean dataframe to prep for analysis - by clean in this case I mean that we have replaced item scores from the scales with their means and also that we have fixed the NAs that dont belong (for participation variables, in this dataset, the NAs should be 0s) my_df &lt;- data.frame(seniorSurvey_df[1:5],my_scores, seniorSurvey_df[19:25]) This is an old school method to replace NAs in specific columns my_df$ParticipateServiceL[is.na(my_df$ParticipateServiceL)] &lt;- 0 my_df$ParticipateCService[is.na(my_df$ParticipateCService)] &lt;- 0 my_df$ParticipateStudyAbroadSemester[is.na(my_df$ParticipateStudyAbroadSemester)] &lt;- 0 my_df\\(ParticipateInternCoop...[is.na(mydf\\)ParticipateInternCoop)] &lt;- 0 - this variable read in cumbersomely named and I dont care about it right now so Ill skip Here is An alternative method to replace NAs in specific columns: my_df &lt;- my_df %&gt;% replace_na(list(ParticipateCService = 0, ParticipateStudyAbroadSemester = 0, ParticipateServiceL = 0)) 4.3.3 Preliminary analysis At this point, we are ready for some analysis Lets investigate correlations. What seems most obvious would just be to run cor() but, as we found out in class, this can cause us to run full speed ahead without considering assumptions my_correlations &lt;- my_df %&gt;% select(SJCa,SJCh,DA) %&gt;% cor() print(my_correlations) ## SJCa SJCh DA ## SJCa 1.0000000 0.2590211 0.3342276 ## SJCh 0.2590211 1.0000000 0.2310703 ## DA 0.3342276 0.2310703 1.0000000 Ok, so, it is important that we note that this ran correlations but R doesnt know that this was sample data and therefore that we are interested instatistical significance (or not) of these results AND that our data may need another method (e.g., non-parametric). cor() does have a way to run spearman instead. my_spearman_correlations &lt;- my_df %&gt;% select(SJCa,SJCh,DA) %&gt;% cor(method=&quot;spearman&quot;) print(my_spearman_correlations) ## SJCa SJCh DA ## SJCa 1.0000000 0.2727828 0.3148168 ## SJCh 0.2727828 1.0000000 0.2340174 ## DA 0.3148168 0.2340174 1.0000000 If we need p values though, we need to change to something else  corr.test my_results &lt;- corr.test(my_df$SJCa,my_df$DA) Then we can pull out results from this list or print it. Lets do both. print(my_results,short=FALSE) ## Call:corr.test(x = my_df$SJCa, y = my_df$DA) ## Correlation matrix ## [1] 0.33 ## Sample Size ## [1] 1852 ## Probability values adjusted for multiple tests. ## [1] 0 ## ## Confidence intervals based upon normal theory. To get bootstrapped values, try cor.ci ## raw.lower raw.r raw.upper raw.p lower.adj upper.adj ## NA-NA 0.29 0.33 0.37 0 0.29 0.37 my_results$r # correlation coefficient ## [1] 0.3342276 my_results$p # p-value ## [1] 1.433637e-49 Visually, we should be able to see this on a scatterplot. We are going to use qplot which stands for quickplot from within ggplot. It is useful and quicker for simple plotting than building up ggplot (though from the same package) we need to jitter my points (take geom=jitter out if you want to see why) qplot(SJCa,DA,data=my_df,geom=&quot;jitter&quot;) qqnorm(my_df$SJCa, frame = FALSE) qqline(my_df$SJCa, col = &quot;steelblue&quot;, lwd = 1.5) my_df %&gt;% ggplot(aes(x = SJCa)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Other functions we used today in class were describe() and also the q-q plot creation to investigate normality assumption copying syntax from the Field, Miles, &amp; Field book "],["week-5-simple-regression.html", "Chapter5 Week 5: Simple Regression 5.1 General Modeling Philosophy 5.2 Data generation demo - one set sample size 5.3 Data generation demo - one set sample size; 5.4 Data generation with three different sample sizes", " Chapter5 Week 5: Simple Regression require(tidyverse) require(psych) require(kableExtra) ## Loading required package: kableExtra ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows library(broom) This week we will start learning about linear regression. In particular, we focus on simple regression. These kinds of models involve one predictor variable and one continuous outcome variable. Next week we will move to models with multiple regression, which involves - you guessed it - multiple predictor variables. 5.1 General Modeling Philosophy The general approach is to model the outcome variable as a function of some predictor(s) plus an error term. Mathematically, this looks like: \\(outcome_i = model + error_i\\) where the \\(i\\) subscript refers to the \\(i^{th}\\) person in the sample. 5.1.0.1 Review of the normal distribution and standardizing variables Just to review, lets think about normally distributed variables and the notion of centering and standardizing. First, we will generate some data by drawing n random numbers from a normal distribution with a mean and standard deviation that we will specify. mean &lt;- 5 sd &lt;- 3 n &lt;- 1000 random_x &lt;- rnorm(n = n, mean = mean, sd = sd) We can then visualize those numbers hist(random_x) Now if we subtract the mean and plot the histogram, notice how the values have all basically shifted to the left along the x-axis. sample_mean &lt;- mean(random_x) centered_x &lt;- random_x - sample_mean hist(centered_x) Finally, we can divide by the sample standard deviation, which should have the effect of either stretching or squishing the values along the x-axis (without changing their mean). Pay attention again to the values along the x-axis. sample_sd &lt;- sd(random_x) standardized_x &lt;- centered_x / sample_sd hist(standardized_x) This final plot should remind you have the standard normal plot (with mean 0 and standard deviation 1). This is noted as \\(x \\sim \\mathcal{N}(0, 1)\\) and is read as x is distributed according to a normal distribution with a mean of 0 and variance of 1. 5.2 Data generation demo - one set sample size The following is a demo from class, found in the week_5_demo.R file #store the sample size that we want to use samp_size &lt;- 100 # uniformly sample X values (values for our predictor variable) from 0 to 20 x &lt;- round(runif(n = samp_size, min = 0, max = 30), digits = 1) # this gives samp_size number of random numbers Store the noise values for our different test models sd_min &lt;- 2 # low noise sd_med &lt;- 6 # medium noise sd_max &lt;- 12 # high noise Generate the outcome variable values under different amounts of noise (the rnorm() function is what is generating noise here) y_noise_sd_none &lt;- 3 + 2*x # this is the true relationship without any noise y_noise_sd_min &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_min), digits = 1) y_noise_sd_med &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_med), digits = 1) y_noise_sd_max &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_max), digits = 1) Typical step 1: visualize! Lets plot each of these x values vs y plot(x, y_noise_sd_none) plot(x, y_noise_sd_min) plot(x, y_noise_sd_med) plot(x, y_noise_sd_max) Lets put all of these vectors together into a data frame to make it easier to analyze later on Note, this is not a vital step for conducting the simple regression demo_df &lt;- tibble(&quot;x&quot; = x, &quot;y_noise_sd_none&quot;=y_noise_sd_none, &quot;y_noise_sd_min&quot; = y_noise_sd_min, &quot;y_noise_sd_med&quot; = y_noise_sd_med, &quot;y_noise_sd_max&quot; = y_noise_sd_max) Check out what demo_df looks like head(demo_df) ## # A tibble: 6 x 5 ## x y_noise_sd_none y_noise_sd_min y_noise_sd_med y_noise_sd_max ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.5 14 16.6 13.2 18.3 ## 2 19.6 42.2 43.5 35.4 33 ## 3 23.3 49.6 49.8 44.5 20.4 ## 4 15.3 33.6 37.8 28.5 21.6 ## 5 7.8 18.6 18.9 11.8 10.8 ## 6 10.5 24 21 23.3 13 Order by increasing x value demo_df &lt;- demo_df %&gt;% arrange(x) Check out what the arrange() function did head(demo_df) ## # A tibble: 6 x 5 ## x y_noise_sd_none y_noise_sd_min y_noise_sd_med y_noise_sd_max ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.3 3.6 2.9 6 6.1 ## 2 0.5 4 2.3 -4.8 6.9 ## 3 1.3 5.6 8.8 12.9 11.5 ## 4 1.4 5.8 4.8 17.4 -5.90 ## 5 1.7 6.4 9.1 5.2 -2.5 ## 6 1.7 6.4 9.6 7 14.7 Lets make this a long df so that we can plot multiple standard deviation values together demo_df_long &lt;- demo_df %&gt;% pivot_longer(cols = starts_with(&quot;y_noise&quot;), names_to = &quot;y_col&quot;, values_to = &quot;y_val&quot; ) Again, check on what this did head(demo_df_long) ## # A tibble: 6 x 3 ## x y_col y_val ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 0.3 y_noise_sd_none 3.6 ## 2 0.3 y_noise_sd_min 2.9 ## 3 0.3 y_noise_sd_med 6 ## 4 0.3 y_noise_sd_max 6.1 ## 5 0.5 y_noise_sd_none 4 ## 6 0.5 y_noise_sd_min 2.3 Lets add in a column to note whether the value is from the min, med, max, or zero sd (noise) model demo_df_long &lt;- demo_df_long %&gt;% mutate(sd_val = case_when(str_detect(y_col, &quot;sd_none&quot;) ~ 0, str_detect(y_col, &quot;sd_min&quot;) ~ sd_min, str_detect(y_col, &quot;sd_med&quot;) ~ sd_med, str_detect(y_col, &quot;sd_max&quot;) ~ sd_max)) Use facet_grid to separate the plots out by demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + facet_grid(.~y_col) You can also automatically add in a line with the geom_smooth() function demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_grid(.~y_col) ## `geom_smooth()` using formula &#39;y ~ x&#39; Now we can create a linear model for the data with minimum noise with the following command: fit_demo_min &lt;- lm(y_noise_sd_min ~ x) and we can look at the summary of the model with: summary(fit_demo_min) ## ## Call: ## lm(formula = y_noise_sd_min ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.9489 -1.4029 0.1168 1.5156 4.2138 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.53318 0.40214 8.786 5.2e-14 *** ## x 1.97995 0.02547 77.740 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.055 on 98 degrees of freedom ## Multiple R-squared: 0.984, Adjusted R-squared: 0.9839 ## F-statistic: 6043 on 1 and 98 DF, p-value: &lt; 2.2e-16 We can also look at model results with the glance() function from the broom package broom::glance(fit_demo_min) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.984 0.984 2.06 6043. 7.13e-90 1 -213. 432. 440. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; We can create models for the med and max sd values as well and take a look at those with the summary() function once again fit_demo_med &lt;- lm(y_noise_sd_med ~ x) summary(fit_demo_med) ## ## Call: ## lm(formula = y_noise_sd_med ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -14.1619 -4.1997 -0.1899 3.7308 17.1795 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.23495 1.09556 2.04 0.044 * ## x 2.07626 0.06939 29.92 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.599 on 98 degrees of freedom ## Multiple R-squared: 0.9014, Adjusted R-squared: 0.9003 ## F-statistic: 895.4 on 1 and 98 DF, p-value: &lt; 2.2e-16 fit_demo_max &lt;- lm(y_noise_sd_max ~ x) summary(fit_demo_max) ## ## Call: ## lm(formula = y_noise_sd_max ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -27.224 -8.624 2.337 7.890 27.913 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.8917 2.2475 0.842 0.402 ## x 1.9627 0.1423 13.789 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.49 on 98 degrees of freedom ## Multiple R-squared: 0.6599, Adjusted R-squared: 0.6564 ## F-statistic: 190.1 on 1 and 98 DF, p-value: &lt; 2.2e-16 Notice the increase in the standard error of the coefficient estimates as the noise in y values went up From a programming perspective, this was not very efficient because I just copied, pasted, and corrected these values. There is a better way to do this using lists (see below) Lets do some fancy stuff to make multiple models at once rather than having to write new lines for each model *Some of these ideas are taken from the R4DS book chapter 25 test_nest &lt;- demo_df_long %&gt;% nest(data = -sd_val) linear_model &lt;- function(df) { lm(y_val ~ x, data = df) } models &lt;- map(test_nest$data, linear_model) summary(models[[2]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.9489 -1.4029 0.1168 1.5156 4.2138 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.53318 0.40214 8.786 5.2e-14 *** ## x 1.97995 0.02547 77.740 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.055 on 98 degrees of freedom ## Multiple R-squared: 0.984, Adjusted R-squared: 0.9839 ## F-statistic: 6043 on 1 and 98 DF, p-value: &lt; 2.2e-16 summary(models[[3]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -14.1619 -4.1997 -0.1899 3.7308 17.1795 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.23495 1.09556 2.04 0.044 * ## x 2.07626 0.06939 29.92 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.599 on 98 degrees of freedom ## Multiple R-squared: 0.9014, Adjusted R-squared: 0.9003 ## F-statistic: 895.4 on 1 and 98 DF, p-value: &lt; 2.2e-16 summary(models[[4]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -27.224 -8.624 2.337 7.890 27.913 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.8917 2.2475 0.842 0.402 ## x 1.9627 0.1423 13.789 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.49 on 98 degrees of freedom ## Multiple R-squared: 0.6599, Adjusted R-squared: 0.6564 ## F-statistic: 190.1 on 1 and 98 DF, p-value: &lt; 2.2e-16 We can also store the models as new columns in the nested dataframe test_nest &lt;- test_nest %&gt;% mutate(model = map(data, linear_model)) Finally, we can unnest the models to make it easier to compare them with each other in a data frame test_nest &lt;- test_nest %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable 5.3 Data generation demo - one set sample size; The change from the past demo is that we are now sampling from integer values rather than continuous for the predictor Store the sample size that we want to use samp_size &lt;- 200 Instead of sampling uniformly from 0 to 20, this is to sample integers from 40 to 100 uniformly. We take samp_size number of samples. Replace = TRUE means we can get the same x value multiple times x &lt;- sample(x = c(60:100), size = samp_size, replace = TRUE) As before, store the noise values for our different test models sd_min &lt;- 2 sd_med &lt;- 6 sd_max &lt;- 12 y_noise_sd_none &lt;- 3 + 2*x y_noise_sd_min &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_min), digits = 1) y_noise_sd_med &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_med), digits = 1) y_noise_sd_max &lt;- 3 + 2*x + round(x = rnorm(n = samp_size, mean = 0, sd = sd_max), digits = 1) Typical step 1: visualize! Lets plot each of these x values vs y plot(x, y_noise_sd_none) plot(x, y_noise_sd_min) plot(x, y_noise_sd_med) plot(x, y_noise_sd_max) Lets put all of these vectors together into a data frame to make it easier to analyze later on. Note, this is not a vital step for conducting the simple regression demo_df &lt;- tibble(&quot;x&quot; = x, &quot;y_noise_sd_none&quot;=y_noise_sd_none, &quot;y_noise_sd_min&quot; = y_noise_sd_min, &quot;y_noise_sd_med&quot; = y_noise_sd_med, &quot;y_noise_sd_max&quot; = y_noise_sd_max) Order by increasing x value demo_df &lt;- demo_df %&gt;% arrange(x) Lets make this a long df so that we can plot multiple standard deviation values together demo_df_long &lt;- demo_df %&gt;% pivot_longer(cols = starts_with(&quot;y_noise&quot;), names_to = &quot;y_col&quot;, values_to = &quot;y_val&quot; ) demo_df_long &lt;- demo_df_long %&gt;% mutate(sd_val = case_when(str_detect(y_col, &quot;sd_none&quot;) ~ 0, str_detect(y_col, &quot;sd_min&quot;) ~ sd_min, str_detect(y_col, &quot;sd_med&quot;) ~ sd_med, str_detect(y_col, &quot;sd_max&quot;) ~ sd_max)) And visualize the data, faceting by different noise demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + facet_grid(.~y_col) And add in a line with geom_smooth(method = 'lm') demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_grid(.~y_col) ## `geom_smooth()` using formula &#39;y ~ x&#39; Create a linear model and look at the summary. fit_demo_min &lt;- lm(y_noise_sd_min ~ x) summary(fit_demo_min) ## ## Call: ## lm(formula = y_noise_sd_min ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.0937 -1.4186 0.0157 1.3993 4.6890 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.37231 0.88931 2.668 0.00827 ** ## x 2.00865 0.01106 181.535 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.991 on 198 degrees of freedom ## Multiple R-squared: 0.994, Adjusted R-squared: 0.994 ## F-statistic: 3.295e+04 on 1 and 198 DF, p-value: &lt; 2.2e-16 We can also look at model results with the glance() function from the broom package broom::glance(fit_demo_min) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.994 0.994 1.99 32955. 3.91e-222 1 -420. 847. 857. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; We can create models for the med and max sd values as well and take a look at those with the summary() function once again. fit_demo_med &lt;- lm(y_noise_sd_med ~ x) summary(fit_demo_med) ## ## Call: ## lm(formula = y_noise_sd_med ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -16.9577 -3.4180 -0.0953 3.6596 12.6136 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.6070 2.4517 0.655 0.513 ## x 2.0178 0.0305 66.150 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.488 on 198 degrees of freedom ## Multiple R-squared: 0.9567, Adjusted R-squared: 0.9565 ## F-statistic: 4376 on 1 and 198 DF, p-value: &lt; 2.2e-16 fit_demo_max &lt;- lm(y_noise_sd_max ~ x) summary(fit_demo_max) ## ## Call: ## lm(formula = y_noise_sd_max ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -26.2440 -8.7198 -0.1522 6.8642 28.8044 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.89375 5.04559 0.772 0.441 ## x 1.96953 0.06278 31.374 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.29 on 198 degrees of freedom ## Multiple R-squared: 0.8325, Adjusted R-squared: 0.8317 ## F-statistic: 984.3 on 1 and 198 DF, p-value: &lt; 2.2e-16 Notice the increase in the standard error of the coefficient estimates as the noise in y values went up From a programming perspective, this was not very efficient because I just copied, pasted, and corrected these values. There is a better way to do this using lists (see below) Lets do some fancy stuff to make multiple models at once rather than having to write new lines for each model *Some of these ideas are taken from the R4DS book chapter 25 test_nest &lt;- demo_df_long %&gt;% nest(data = -sd_val) linear_model &lt;- function(df) { lm(y_val ~ x, data = df) } models &lt;- map(test_nest$data, linear_model) summary(models[[2]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.0937 -1.4186 0.0157 1.3993 4.6890 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.37231 0.88931 2.668 0.00827 ** ## x 2.00865 0.01106 181.535 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.991 on 198 degrees of freedom ## Multiple R-squared: 0.994, Adjusted R-squared: 0.994 ## F-statistic: 3.295e+04 on 1 and 198 DF, p-value: &lt; 2.2e-16 summary(models[[3]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -16.9577 -3.4180 -0.0953 3.6596 12.6136 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.6070 2.4517 0.655 0.513 ## x 2.0178 0.0305 66.150 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 5.488 on 198 degrees of freedom ## Multiple R-squared: 0.9567, Adjusted R-squared: 0.9565 ## F-statistic: 4376 on 1 and 198 DF, p-value: &lt; 2.2e-16 summary(models[[4]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -26.2440 -8.7198 -0.1522 6.8642 28.8044 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.89375 5.04559 0.772 0.441 ## x 1.96953 0.06278 31.374 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.29 on 198 degrees of freedom ## Multiple R-squared: 0.8325, Adjusted R-squared: 0.8317 ## F-statistic: 984.3 on 1 and 198 DF, p-value: &lt; 2.2e-16 We can also store the models as new columns in the nested dataframe test_nest &lt;- test_nest %&gt;% mutate(model = map(data, linear_model)) Finally, we can unnest the models to make it easier to compare them with each other in a data frame test_nest &lt;- test_nest %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) 5.4 Data generation with three different sample sizes Lets run the same demo but now have three different sample sizes - 10, 50, and 500 First, store the sample sizes we want to use samp_sizes &lt;- c(10, 50, 500) Next, create a bookkeping column for ourselves to keep track of which sample size the future values will come from samp_size_col &lt;- rep(x = c(10,50, 500), times = samp_sizes) Calculate the total number of values we will need from the three samples combined tot_samp_size &lt;- sum(samp_sizes) Sample uniformly from 0 to 20 x &lt;- round(x = runif(n = tot_samp_size, min = 0, max = 20), digits = 1) Store the standard deviations for the min, med, and max models sd_min &lt;- 2 sd_med &lt;- 6 sd_max &lt;- 12 Calculate the y values for the different scenarios where there is no noise up to max noise y_noise_sd_none &lt;- 3 + 2*x y_noise_sd_min &lt;- 3 + 2*x + round(x = rnorm(n = tot_samp_size, mean = 0, sd = sd_min), digits = 1) y_noise_sd_med &lt;- 3 + 2*x + round(x = rnorm(n = tot_samp_size, mean = 0, sd = sd_med), digits = 1) y_noise_sd_max &lt;- 3 + 2*x + round(x = rnorm(n = tot_samp_size, mean = 0, sd = sd_max), digits = 1) Typical step 1: visualize! Lets plot each of these x values vs y plot(x, y_noise_sd_none) plot(x, y_noise_sd_min) plot(x, y_noise_sd_med) plot(x, y_noise_sd_max) Can we calculate the correlations between x and these different y values? (pro tip: yes) Lets put all of these vectors together into a data frame to make it easier to analyze later on Note, this is not a vital step for conducting the simple regression demo_df &lt;- tibble(&quot;n&quot; = samp_size_col, &quot;x&quot; = x, &quot;y_noise_sd_none&quot;=y_noise_sd_none, &quot;y_noise_sd_min&quot; = y_noise_sd_min, &quot;y_noise_sd_med&quot; = y_noise_sd_med, &quot;y_noise_sd_max&quot; = y_noise_sd_max) Order by increasing x value demo_df &lt;- demo_df %&gt;% arrange(n, x) Lets make this a long df so that we can plot multiple standard deviation values together demo_df_long &lt;- demo_df %&gt;% pivot_longer(cols = starts_with(&quot;y_noise&quot;), names_to = &quot;y_col&quot;, values_to = &quot;y_val&quot; ) demo_df_long &lt;- demo_df_long %&gt;% mutate(sd_val = case_when(str_detect(y_col, &quot;sd_none&quot;) ~ 0, str_detect(y_col, &quot;sd_min&quot;) ~ sd_min, str_detect(y_col, &quot;sd_med&quot;) ~ sd_med, str_detect(y_col, &quot;sd_max&quot;) ~ sd_max)) demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + facet_grid(n~y_col) demo_df_long %&gt;% ggplot(aes(x = x, y = y_val)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_grid(n~y_col) ## `geom_smooth()` using formula &#39;y ~ x&#39; fit_demo_min &lt;- lm(y_noise_sd_min ~ x) summary(fit_demo_min) ## ## Call: ## lm(formula = y_noise_sd_min ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.6147 -1.2891 -0.0022 1.3830 5.6569 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.06222 0.17496 17.5 &lt;2e-16 *** ## x 1.99454 0.01485 134.3 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.958 on 558 degrees of freedom ## Multiple R-squared: 0.97, Adjusted R-squared: 0.9699 ## F-statistic: 1.804e+04 on 1 and 558 DF, p-value: &lt; 2.2e-16 We can also look at model results with the glance() function from the broom package broom::glance(fit_demo_min) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.970 0.970 1.96 18039. 0 1 -1170. 2346. 2359. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; We can create models for the med and max sd values as well and take a look at those with the summary() function once again fit_demo_med &lt;- lm(y_noise_sd_med ~ x) summary(fit_demo_med) ## ## Call: ## lm(formula = y_noise_sd_med ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -16.6685 -4.0415 0.4648 4.5044 17.4829 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.59398 0.55096 6.523 1.55e-10 *** ## x 1.96308 0.04676 41.979 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.166 on 558 degrees of freedom ## Multiple R-squared: 0.7595, Adjusted R-squared: 0.7591 ## F-statistic: 1762 on 1 and 558 DF, p-value: &lt; 2.2e-16 fit_demo_max &lt;- lm(y_noise_sd_max ~ x) summary(fit_demo_max) ## ## Call: ## lm(formula = y_noise_sd_max ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -30.976 -7.997 -0.673 7.769 40.788 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.86874 1.03877 2.762 0.00594 ** ## x 2.09010 0.08817 23.706 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.62 on 558 degrees of freedom ## Multiple R-squared: 0.5018, Adjusted R-squared: 0.5009 ## F-statistic: 562 on 1 and 558 DF, p-value: &lt; 2.2e-16 Notice the increase in the standard error of the coefficient estimates as the noise in y values went up From a programming perspective, this was not very efficient because I just copied, pasted, and corrected these values. There is a better way to do this using lists (see below) Lets do some fancy stuff to make multiple models at once rather than having to write new lines for each model *Some of these ideas are taken from the R4DS book chapter 25 test_nest &lt;- demo_df_long %&gt;% nest(data = -c(sd_val, n)) linear_model &lt;- function(df) { lm(y_val ~ x, data = df) } models &lt;- map(test_nest$data, linear_model) summary(models[[2]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.9188 -0.8377 0.2840 1.0041 3.1844 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.307 1.378 2.399 0.0432 * ## x 2.002 0.106 18.886 6.39e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.994 on 8 degrees of freedom ## Multiple R-squared: 0.9781, Adjusted R-squared: 0.9753 ## F-statistic: 356.7 on 1 and 8 DF, p-value: 6.388e-08 summary(models[[3]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -13.833 -5.095 2.864 6.077 8.110 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.7661 5.6780 -0.135 0.895999 ## x 2.4919 0.4367 5.706 0.000451 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 8.217 on 8 degrees of freedom ## Multiple R-squared: 0.8027, Adjusted R-squared: 0.7781 ## F-statistic: 32.56 on 1 and 8 DF, p-value: 0.0004514 summary(models[[4]]) ## ## Call: ## lm(formula = y_val ~ x, data = df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -16.154 -6.769 -2.235 5.381 26.509 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 13.9940 9.0212 1.551 0.159 ## x 0.6285 0.6939 0.906 0.391 ## ## Residual standard error: 13.05 on 8 degrees of freedom ## Multiple R-squared: 0.09303, Adjusted R-squared: -0.02034 ## F-statistic: 0.8206 on 1 and 8 DF, p-value: 0.3915 We can also store the models as new columns in the nested dataframe test_nest &lt;- test_nest %&gt;% mutate(model = map(data, linear_model)) Finally, we can unnest the models to make it easier to compare them with each other in a data frame test_nest &lt;- test_nest %&gt;% mutate(glance = map(model, broom::glance)) %&gt;% unnest(glance) ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable ## Warning in summary.lm(x): essentially perfect fit: summary may be unreliable And look at the different models by just calling the data frame test_nest ## # A tibble: 12 x 16 ## n sd_val data model r.squared adj.r.squared sigma statistic p.value ## &lt;dbl&gt; &lt;dbl&gt; &lt;lis&gt; &lt;lis&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10 0 &lt;tib~ &lt;lm&gt; 1 1 2.46e-15 2.34e+32 3.71e-127 ## 2 10 2 &lt;tib~ &lt;lm&gt; 0.978 0.975 1.99e+ 0 3.57e+ 2 6.39e- 8 ## 3 10 6 &lt;tib~ &lt;lm&gt; 0.803 0.778 8.22e+ 0 3.26e+ 1 4.51e- 4 ## 4 10 12 &lt;tib~ &lt;lm&gt; 0.0930 -0.0203 1.31e+ 1 8.21e- 1 3.91e- 1 ## 5 50 0 &lt;tib~ &lt;lm&gt; 1 1 4.65e-15 3.52e+32 0. ## 6 50 2 &lt;tib~ &lt;lm&gt; 0.974 0.973 2.08e+ 0 1.77e+ 3 1.44e- 39 ## 7 50 6 &lt;tib~ &lt;lm&gt; 0.803 0.799 6.17e+ 0 1.96e+ 2 1.44e- 18 ## 8 50 12 &lt;tib~ &lt;lm&gt; 0.451 0.440 1.25e+ 1 3.95e+ 1 9.16e- 8 ## 9 500 0 &lt;tib~ &lt;lm&gt; 1 1 3.53e-14 4.82e+31 0. ## 10 500 2 &lt;tib~ &lt;lm&gt; 0.969 0.969 1.95e+ 0 1.57e+ 4 0. ## 11 500 6 &lt;tib~ &lt;lm&gt; 0.754 0.753 6.13e+ 0 1.52e+ 3 1.44e-153 ## 12 500 12 &lt;tib~ &lt;lm&gt; 0.520 0.519 1.14e+ 1 5.40e+ 2 2.06e- 81 ## # ... with 7 more variables: df &lt;dbl&gt;, logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, BIC &lt;dbl&gt;, ## # deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; "],["week-6-regression-ii.html", "Chapter6 Week 6: Regression II 6.1 Explore the child aggression data set 6.2 Multiple regression", " Chapter6 Week 6: Regression II This week we will be discussing multiple regression. We will use the child aggression data set as a running example for this. 6.1 Explore the child aggression data set ca_df &lt;- read.table(&quot;ChildAggression.dat&quot;, header = TRUE) Method 1 for quickly getting summary statistics for the data you have, using the built-in summary() function summary(ca_df) ## Aggression Television Computer_Games ## Min. :-1.295608 Min. :-1.46012 Min. :-1.1538345 ## 1st Qu.:-0.174279 1st Qu.:-0.18206 1st Qu.:-0.1687007 ## Median :-0.005548 Median :-0.01247 Median :-0.0001997 ## Mean :-0.005011 Mean :-0.02758 Mean : 0.0103812 ## 3rd Qu.: 0.149611 3rd Qu.: 0.14983 3rd Qu.: 0.1881810 ## Max. : 1.178823 Max. : 0.98162 Max. : 1.6175039 ## Sibling_Aggression Diet Parenting_Style ## Min. :-1.433127 Min. :-1.28490 Min. :-4.46041 ## 1st Qu.:-0.156414 1st Qu.:-0.16136 1st Qu.:-0.58008 ## Median : 0.008459 Median : 0.00934 Median : 0.02736 ## Mean : 0.008275 Mean : 0.01162 Mean : 0.00000 ## 3rd Qu.: 0.185136 3rd Qu.: 0.18708 3rd Qu.: 0.51784 ## Max. : 1.103671 Max. : 1.22383 Max. : 3.99326 Method 2, using the describe() function from the psych package psych::describe(ca_df) ## vars n mean sd median trimmed mad min max range ## Aggression 1 666 -0.01 0.32 -0.01 -0.01 0.24 -1.30 1.18 2.47 ## Television 2 666 -0.03 0.31 -0.01 -0.02 0.25 -1.46 0.98 2.44 ## Computer_Games 3 666 0.01 0.34 0.00 0.00 0.27 -1.15 1.62 2.77 ## Sibling_Aggression 4 666 0.01 0.33 0.01 0.01 0.26 -1.43 1.10 2.54 ## Diet 5 666 0.01 0.34 0.01 0.01 0.26 -1.28 1.22 2.51 ## Parenting_Style 6 666 0.00 1.00 0.03 0.01 0.82 -4.46 3.99 8.45 ## skew kurtosis se ## Aggression -0.02 1.61 0.01 ## Television -0.36 1.34 0.01 ## Computer_Games 0.25 1.60 0.01 ## Sibling_Aggression -0.17 1.40 0.01 ## Diet -0.12 1.51 0.01 ## Parenting_Style -0.22 1.67 0.04 Spot check: where do the se values come from? Now that we have seen some of the numbers, lets try to visualize some of these data. Lets try to visualize the data while were at it ca_df %&gt;% ggplot(aes(x = Aggression)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. We could do this for each of our variables or we could try something a little fancier by using the pivot_longer() function to make a longer dataframe and plot everything at once First, create the long dataframe. After running this command, its a good idea to view the new data frame to make sure this did what you intended ca_df_long &lt;- ca_df %&gt;% pivot_longer(cols = Aggression:Parenting_Style, names_to = &quot;variable_name&quot;, values_to = &quot;variable_value&quot;) After making sure everything looks in order, run the same plot command with the addition of a facet. Note that the fill = variable_name tells R to color the plot with different colors by variable_name and the theme() tells R to get rid of the legend that automatically shows up ca_df_long %&gt;% ggplot(aes(x = variable_value, fill = variable_name)) + geom_histogram() + facet_wrap(variable_name ~.) + theme(legend.position = &quot;none&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. From this we should be able to see that everything is normally distributed and appears to be standardized Lets try a different kind of visualization: the empirical cumulative distribution function (eCDF) (sounds fancy, but its not bad) ca_df_long %&gt;% ggplot(aes(x = variable_value)) + stat_ecdf(geom = &quot;point&quot;) + facet_wrap(variable_name ~.) It looks like a bunch of distorted s shapes. In order to understand what is going on here, we should take a brief detour into the world of cumulative distribution functions (CDFs), eCDFs, and eventually QQ plots. This detour is at the end of the markdown file. Now we can try a third way of visualizing our data - QQ plots! As before, we can plot each variable with separate calls or plot them all together with the long data frame ca_df %&gt;% ggplot(aes(sample=Aggression)) + stat_qq() + stat_qq_line() ca_df_long %&gt;% ggplot(aes(sample=variable_value)) + stat_qq() + stat_qq_line() + facet_wrap(variable_name ~ .) 6.2 Multiple regression Lets create a model of child aggression as a function of parenting style and sibling aggression model_fam &lt;- lm(Aggression ~ Parenting_Style + Sibling_Aggression, data = ca_df) Run the summary on the model summary(model_fam) ## ## Call: ## lm(formula = Aggression ~ Parenting_Style + Sibling_Aggression, ## data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.09755 -0.17180 0.00092 0.15405 1.23037 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.005784 0.012065 -0.479 0.632 ## Parenting_Style 0.061984 0.012257 5.057 5.51e-07 *** ## Sibling_Aggression 0.093409 0.037505 2.491 0.013 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3113 on 663 degrees of freedom ## Multiple R-squared: 0.05325, Adjusted R-squared: 0.05039 ## F-statistic: 18.64 on 2 and 663 DF, p-value: 1.325e-08 This will be helpful later when we want to plot the residuals of the model. Lets create another model of child aggression as a function of computer games and television. model_screens &lt;- lm(Aggression ~ Computer_Games + Television, data = ca_df) summary(model_screens) ## ## Call: ## lm(formula = Aggression ~ Computer_Games + Television, data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.05234 -0.15191 -0.00512 0.15156 1.24062 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.002879 0.012132 -0.237 0.812526 ## Computer_Games 0.153874 0.035845 4.293 2.03e-05 *** ## Television 0.135263 0.039546 3.420 0.000664 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3115 on 663 degrees of freedom ## Multiple R-squared: 0.05149, Adjusted R-squared: 0.04862 ## F-statistic: 17.99 on 2 and 663 DF, p-value: 2.455e-08 Now lets see what the full model looks like with all five predictors model_all &lt;- lm(Aggression ~ Parenting_Style + Sibling_Aggression + Diet + Computer_Games + Television, data = ca_df) summary(model_all) ## ## Call: ## lm(formula = Aggression ~ Parenting_Style + Sibling_Aggression + ## Diet + Computer_Games + Television, data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.12629 -0.15253 -0.00421 0.15222 1.17669 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.004988 0.011983 -0.416 0.677350 ## Parenting_Style 0.056648 0.014557 3.891 0.000110 *** ## Sibling_Aggression 0.081684 0.038780 2.106 0.035550 * ## Diet -0.109054 0.038076 -2.864 0.004315 ** ## Computer_Games 0.142161 0.036920 3.851 0.000129 *** ## Television 0.032916 0.046057 0.715 0.475059 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3071 on 660 degrees of freedom ## Multiple R-squared: 0.08258, Adjusted R-squared: 0.07563 ## F-statistic: 11.88 on 5 and 660 DF, p-value: 5.025e-11 We can get the output from the summary() function but as a tibble instead: broom::tidy(model_all, conf.int = TRUE) ## # A tibble: 6 x 7 ## term estimate std.error statistic p.value conf.low conf.high ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -0.00499 0.0120 -0.416 0.677 -0.0285 0.0185 ## 2 Parenting_Style 0.0566 0.0146 3.89 0.000110 0.0281 0.0852 ## 3 Sibling_Aggression 0.0817 0.0388 2.11 0.0355 0.00554 0.158 ## 4 Diet -0.109 0.0381 -2.86 0.00432 -0.184 -0.0343 ## 5 Computer_Games 0.142 0.0369 3.85 0.000129 0.0697 0.215 ## 6 Television 0.0329 0.0461 0.715 0.475 -0.0575 0.123 We can also get summary statistics like the R^2, F-statistics, and AIC from the glance() function in the Broom package broom::glance(model_all) ## # A tibble: 1 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.0826 0.0756 0.307 11.9 5.02e-11 5 -156. 325. 357. ## # ... with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; Lets stop here to interpret what the model output is telling us(specifically, the coefficient estimates, the standard errors, the p values, and the R^2 values). Notice the Television p value and standard errors (especially how the estimate is so close to zero, and its 95% confidence interval crosses 0) We can also have R handle factors automatically in a regression model for us. First, we will generate a new factor for the child aggression data - the handedness of the child (left vs right). This code generates a random handedness for each of the 666 students and assigns it to a new column in ca_df handed_levels &lt;- c(&quot;left&quot;, &quot;right&quot;) handed_vector &lt;- sample(handed_levels, size = nrow(ca_df), replace = TRUE, prob = c(0.4, 0.6)) ca_df$Handedness &lt;- handed_vector Check to make sure we have all the predictor names correct to add into the linear model. names(ca_df) ## [1] &quot;Aggression&quot; &quot;Television&quot; &quot;Computer_Games&quot; ## [4] &quot;Sibling_Aggression&quot; &quot;Diet&quot; &quot;Parenting_Style&quot; ## [7] &quot;Handedness&quot; model_all_3 &lt;- lm(Aggression ~ Parenting_Style + Sibling_Aggression + Television + Computer_Games + Diet + Handedness, data = ca_df) Check the model summary and notice how the Handedness predictor variable was handled. summary(model_all_3) ## ## Call: ## lm(formula = Aggression ~ Parenting_Style + Sibling_Aggression + ## Television + Computer_Games + Diet + Handedness, data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.11129 -0.15322 -0.00368 0.15307 1.19195 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.02174 0.01920 -1.132 0.257971 ## Parenting_Style 0.05696 0.01456 3.913 0.000101 *** ## Sibling_Aggression 0.07888 0.03885 2.030 0.042731 * ## Television 0.03201 0.04606 0.695 0.487236 ## Computer_Games 0.14190 0.03691 3.844 0.000133 *** ## Diet -0.10888 0.03807 -2.860 0.004372 ** ## Handednessright 0.02734 0.02449 1.116 0.264658 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.307 on 659 degrees of freedom ## Multiple R-squared: 0.08431, Adjusted R-squared: 0.07597 ## F-statistic: 10.11 on 6 and 659 DF, p-value: 1.035e-10 lm(Aggression ~ ., data=ca_df) ## ## Call: ## lm(formula = Aggression ~ ., data = ca_df) ## ## Coefficients: ## (Intercept) Television Computer_Games Sibling_Aggression ## -0.02174 0.03201 0.14190 0.07888 ## Diet Parenting_Style Handednessright ## -0.10888 0.05696 0.02734 6.2.1 Assumption testing Note: A lot of the things we are doing here can be accomplished with the augment() function in the broom package Check for correlation between adjacent residual terms using Durbin-Watson test dwt(model_all) ## lag Autocorrelation D-W Statistic p-value ## 1 0.04218005 1.912808 0.234 ## Alternative hypothesis: rho != 0 Check for multicollinearity. car::vif(model_all) ## Parenting_Style Sibling_Aggression Diet Computer_Games ## 1.494296 1.132618 1.160466 1.122719 ## Television ## 1.435525 Now lets go back and check for influential cases following the procedure Field does in the textbook. ca_df$residuals &lt;- resid(model_all) # notice how this is the same as looking at View(model_all) and then residuals or model_all$residuals #model_all$residuals ca_df$standardized.residuals &lt;- rstandard(model_all) ca_df$studentized.residuals &lt;- rstudent(model_all) ca_df$cooks.distance &lt;- cooks.distance(model_all) ca_df$dfbeta &lt;- dfbeta(model_all) ca_df$dffit &lt;- dffits(model_all) ca_df$leverage &lt;- hatvalues(model_all) ca_df$covariance.ratios &lt;- covratio(model_all) Now that we have all of the extra model fit statistics calculated, we can add a new olumn using a different method than what he does in the textbook (but this accomplishes the same task). We are using a combination of mutate() and case_when() instead of the traditional logical test subsetting that we see in the bookon pp. 289-290 ca_df &lt;- ca_df %&gt;% mutate(large.residual = case_when(standardized.residuals &gt; 2 | standardized.residuals &lt; -2 ~ TRUE, abs(standardized.residuals) &lt;= 2 ~ FALSE)) Now lets just look at the observations where there was a large residual (absolute value &gt; 2) ca_df %&gt;% filter(large.residual == TRUE) %&gt;% head() ## Aggression Television Computer_Games Sibling_Aggression Diet ## 1 0.7711534 -0.03287184 0.70991822 0.576836667 -0.0229903 ## 2 -0.9309839 -0.14695730 0.58503832 0.143914123 0.1341567 ## 3 0.8437696 -0.53337187 0.62674291 0.006193792 -0.0542531 ## 4 -0.8604237 -0.32734996 -0.10228524 0.088454410 0.3403472 ## 5 0.7374707 0.05104538 0.06804261 0.742478946 0.3607529 ## 6 0.6158280 -0.17945254 -0.14381635 0.337002793 -0.5992525 ## Parenting_Style Handedness residuals standardized.residuals ## 1 -1.2481665 left 0.6973813 2.289855 ## 2 -1.0470961 left -0.9421375 -3.081966 ## 3 0.2386578 left 0.7572738 2.484122 ## 4 -0.6988965 right -0.7606374 -2.483667 ## 5 0.9243197 right 0.6574374 2.152417 ## 6 -1.0334894 right 0.6128345 2.006389 ## studentized.residuals cooks.distance dfbeta.(Intercept) ## 1 2.297263 0.014610960 0.0010048327 ## 2 -3.102033 0.014474124 -0.0013336489 ## 3 2.493925 0.015185553 0.0008375093 ## 4 -2.493465 0.005595170 -0.0010247662 ## 5 2.158374 0.008347004 0.0008799517 ## 6 2.011011 0.007252602 0.0009296294 ## dfbeta.Parenting_Style dfbeta.Sibling_Aggression dfbeta.Diet ## 1 -0.0022102310 0.0053377408 -0.0015602060 ## 2 0.0022877988 -0.0008058492 -0.0011872151 ## 3 0.0016068696 0.0002508274 -0.0028943101 ## 4 0.0006636867 -0.0011984511 -0.0042173119 ## 5 0.0008756410 0.0069052922 0.0014075292 ## 6 -0.0005401040 0.0047888699 -0.0054530647 ## dfbeta.Computer_Games dfbeta.Television dffit leverage ## 1 0.0067966200 0.0013345865 0.2970419 0.016444209 ## 2 -0.0079629954 -0.0003344591 -0.2966131 0.009060145 ## 3 0.0072143563 -0.0098994502 0.3030411 0.014550253 ## 4 0.0015183740 0.0029152017 -0.1839467 0.005412783 ## 5 -0.0015476206 -0.0021915865 0.2244095 0.010694476 ## 6 -0.0004611714 -0.0010521222 0.2090845 0.010694131 ## covariance.ratios large.residual ## 1 0.9780649 TRUE ## 2 0.9335336 TRUE ## 3 0.9679182 TRUE ## 4 0.9590456 TRUE ## 5 0.9778335 TRUE ## 6 0.9832825 TRUE Theres a problem here because we dont preserve observation numbers. In general, it might be a good idea to give each observation an ID with something like dim(ca_df)[1] ## [1] 666 ca_df &lt;- ca_df %&gt;% mutate(ID = seq(1:dim(ca_df)[1])) In the tidyverse, there is an even simpler way to do this with the rowid_to_column() function! ca_df &lt;- ca_df %&gt;% rowid_to_column(var = &quot;participant_id&quot;) Now we can run the filter again and see which observations have large residuals ca_df %&gt;% filter(large.residual == TRUE) %&gt;% view() Plot the residuals against the fitted values ca_df$fitted &lt;- model_all$fitted.values First, plot the distribution of the residuals by themselves histogram &lt;- ca_df %&gt;% ggplot(aes(x = studentized.residuals)) + geom_histogram(aes(y = ..density..)) + labs(x = &quot;Studentized Residuals&quot;, y = &quot;Density&quot;) histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Now lets add a normal density on top of that for comparison histogram + stat_function(fun = dnorm, args = list(mean = mean(ca_df$studentized.residuals, na.rm = TRUE), sd = sd(ca_df$studentized.residuals, na.rm = TRUE)), color = &quot;blue&quot;, size = 1) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Second, plot the residuals against the fitted values to make sure there are no systematic patterns ca_df %&gt;% ggplot(aes(x = fitted, y = studentized.residuals)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + labs(x = &quot;Fitted Residual&quot;, y = &quot;Studentized Residual&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; We can also skip all the fancy code from the book and use the plot() function on the model. R knows that this means we want to plot four fit plots par(mfrow=c(2,2)) # this changes the arrangement for the plots to show two rows and two columns of plots plot(model_all) par(mfrow=c(1,1)) # this changes the plotting arrangement back to the default of one plot at a time Note that we could also create a model that uses all our covariates as predictors with the following call model_all_2 &lt;- lm(Aggression ~ ., data=ca_df) Inspect the results to make sure it is giving the same results as before plot(model_all_2) summary(model_all_2) ## ## Call: ## lm(formula = Aggression ~ ., data = ca_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.111e-14 -3.080e-17 2.400e-17 8.930e-17 9.530e-16 ## ## Coefficients: (2 not defined because of singularities) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.988e-03 2.629e-15 -1.898e+12 &lt; 2e-16 *** ## participant_id 6.445e-19 9.989e-20 6.453e+00 2.16e-10 *** ## Television 3.292e-02 7.447e-17 4.420e+14 &lt; 2e-16 *** ## Computer_Games 1.422e-01 5.979e-17 2.378e+15 &lt; 2e-16 *** ## Sibling_Aggression 8.168e-02 6.276e-17 1.301e+15 &lt; 2e-16 *** ## Diet -1.091e-01 6.187e-17 -1.763e+15 &lt; 2e-16 *** ## Parenting_Style 5.665e-02 2.358e-17 2.403e+15 &lt; 2e-16 *** ## Handednessright -8.860e-18 3.930e-17 -2.250e-01 0.822 ## residuals 1.000e+00 5.036e-12 1.986e+11 &lt; 2e-16 *** ## standardized.residuals -8.707e-13 3.010e-12 -2.890e-01 0.772 ## studentized.residuals -6.860e-15 7.264e-15 -9.440e-01 0.345 ## cooks.distance 5.837e-15 6.811e-15 8.570e-01 0.392 ## dfbeta(Intercept) 9.199e-10 3.176e-09 2.900e-01 0.772 ## dfbetaParenting_Style 2.438e-14 3.655e-14 6.670e-01 0.505 ## dfbetaSibling_Aggression 7.602e-12 2.628e-11 2.890e-01 0.772 ## dfbetaDiet 1.070e-11 3.691e-11 2.900e-01 0.772 ## dfbetaComputer_Games 9.547e-12 3.297e-11 2.900e-01 0.772 ## dfbetaTelevision -2.537e-11 8.759e-11 -2.900e-01 0.772 ## dffit 2.938e-15 6.810e-15 4.310e-01 0.666 ## leverage -2.481e-15 4.301e-15 -5.770e-01 0.564 ## covariance.ratios -3.305e-17 2.618e-15 -1.300e-02 0.990 ## large.residualTRUE -7.933e-17 1.489e-16 -5.330e-01 0.594 ## ID NA NA NA NA ## fitted NA NA NA NA ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.88e-16 on 644 degrees of freedom ## Multiple R-squared: 1, Adjusted R-squared: 1 ## F-statistic: 1.357e+31 on 21 and 644 DF, p-value: &lt; 2.2e-16 Check how augment() works and which parts of the above it replicates augmented_model_all &lt;- augment(model_all) ca_df_long %&gt;% ggplot(aes(x = variable_value, fill = variable_name)) + geom_histogram(position = &quot;identity&quot;, alpha = 0.5) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 6.2.2 Detour: Cumulative Distribution Function (CDF), empirical CDF, and QQ Plot Discussion Our goal here is to visualize the cumulative distribution function for a normal distribution as a stepping stone toward undestanding QQ plots. We will use plots of the empirical cumulative distribution function (eCDF) As a way to visualize our data. Although we have not discussed eCDFs before, they are another tool you can use to visualize the distribution of quantitative data. We will also look at the effect of sample size on the kinds of plots that we may make when visualizing the distribution of data. First, lets generate some data to help us see what these concepts are all about. Note that We are generating data to make things easier on ourselves - we know the underlying data-generating process. So that lets us form an expectation of what should happen. These kinds of toy examples can be helpful for building an intuition about these concepts that we can then use in our own work. df_1 &lt;- tibble(x = round(rnorm(n = 25, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 25, times = 25)) df_2 &lt;- tibble(x = round(rnorm(n = 50, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 50, times = 50)) df_3 &lt;- tibble(x = round(rnorm(n = 100, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 100, times = 100)) df_4 &lt;- tibble(x = round(rnorm(n = 200, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 200, times = 200)) df_5 &lt;- tibble(x = round(rnorm(n = 500, mean = 0, sd = 1), digits = 1), samp_size = rep(x = 500, times = 500)) Combine the generated data together into one data frame to make it easy to plot everything in one ggplot call. sample_df &lt;- bind_rows(df_1, df_2, df_3, df_4, df_5) Look at the empirical CDFs sample_df %&gt;% ggplot(aes(x)) + stat_ecdf(geom = &quot;point&quot;) + facet_grid(samp_size~.) sample_df %&gt;% ggplot(aes(x)) + geom_histogram() + facet_grid(samp_size~.) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. In class, this should lead to a discussion about how to find quantiles now lets try to look at some QQ plots. df_1 %&gt;% ggplot(aes(sample=x)) + stat_qq() + stat_qq_line() Lets try to wrap our heads around what is going on by looking at sorted versions of df_1 values head(df_1 %&gt;% arrange(x)) ## # A tibble: 6 x 2 ## x samp_size ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -2 25 ## 2 -1.9 25 ## 3 -1.8 25 ## 4 -1.1 25 ## 5 -0.6 25 ## 6 -0.6 25 Lets also look at the other end of the dataframe. We can do this either using arrange(desc(x)) or tail instead of head Confirm that theyre basically two ways of accomplishing the same objective. head(df_1 %&gt;% arrange(desc(x))) ## # A tibble: 6 x 2 ## x samp_size ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2.3 25 ## 2 0.9 25 ## 3 0.5 25 ## 4 0.5 25 ## 5 0.4 25 ## 6 0.3 25 tail(df_1 %&gt;% arrange(x)) ## # A tibble: 6 x 2 ## x samp_size ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.3 25 ## 2 0.4 25 ## 3 0.5 25 ## 4 0.5 25 ## 5 0.9 25 ## 6 2.3 25 End detour 6.2.3 Generating data for student happiness exercise. We are going to student happiness scores on a scale from 0 to 100 as a function of their time spent outdoors, time spent on Zoom, class standing, and department. pop_size &lt;- 5000 sample_size &lt;- 200 pop_df &lt;- tibble(standing = rep(c(&quot;undergrad&quot;, &quot;masters&quot;, &quot;phd&quot;), times = c(pop_size/2, pop_size/4, pop_size/4))) pop_df$discipline &lt;- rep(c(&quot;mechanical&quot;, &quot;civil&quot;, &quot;electrical&quot;), length.out = pop_size) pop_df$min_outdoors &lt;- round(runif(n = pop_size, min = 0, max = 300), 0) pop_df$min_zoom &lt;- round(runif(n = pop_size, min = 0, max = 400), 0) pop_df &lt;- pop_df %&gt;% mutate(undergrad = case_when(standing == &quot;undergrad&quot; ~ 1, TRUE ~ 0), masters = case_when(standing == &quot;masters&quot; ~ 1, TRUE ~ 0), phd = case_when(standing == &quot;phd&quot; ~ 1, TRUE ~ 0), civil = case_when(discipline == &quot;civil&quot; ~ 1, TRUE ~ 0), mechanical = case_when(discipline == &quot;mechanical&quot; ~ 1, TRUE ~ 0), electrical = case_when(discipline == &quot;electrical&quot; ~ 1, TRUE ~ 0)) With the predictors generated, we can now generate the happiness scores. #pop_df &lt;- pop_df %&gt;% # mutate(happiness = 50 + -.2*(min_zoom+runif(n = 1, min = 10, max = 30)) + .1 * min_outdoors + 4*civil -.3 * mechanical) b_0 &lt;- 50 b_out &lt;- 0.03 b_zoom &lt;- -0.05 b_civ &lt;- 6 b_mech &lt;- 2 b_ele &lt;- -3 b_under &lt;- 5 b_masters &lt;- -2 b_phd &lt;- 10 pop_df$happiness &lt;- b_0 + b_out*(pop_df$min_outdoors + rnorm(pop_size, 0, 40)) + b_zoom*(pop_df$min_zoom + rnorm(pop_size, 0, 40)) + b_civ*(pop_df$civil + rnorm(pop_size, 0, 2)) + b_mech*pop_df$mechanical + b_ele*pop_df$electrical + b_under * pop_df$undergrad + b_masters*pop_df$masters + b_phd*pop_df$phd + round(rnorm(n = pop_size, mean = 0, sd = 10), 0) We will save the full population dataset. That is what we will start with in class. pop_df %&gt;% write_csv(&quot;student_happiness.csv&quot;) Now we create a sample of students by sampling from the population dataframe. samp_df &lt;- sample_n(pop_df, size = 200) On the modeling side, we can first start with a very simple model with only one predictor. happiness_zoom &lt;- lm(happiness ~ min_zoom, data = samp_df) summary(happiness_zoom) ## ## Call: ## lm(formula = happiness ~ min_zoom, data = samp_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -55.704 -10.541 -0.413 9.759 54.069 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 63.64321 2.31850 27.450 &lt; 2e-16 *** ## min_zoom -0.06961 0.01013 -6.872 8.05e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 16.61 on 198 degrees of freedom ## Multiple R-squared: 0.1926, Adjusted R-squared: 0.1885 ## F-statistic: 47.22 on 1 and 198 DF, p-value: 8.047e-11 Next, we can look at what happens with a more complex model with multiple predictors. Pay attention to how the \\(R^2\\) value changes. happiness_all &lt;- lm(happiness ~ min_outdoors + min_zoom + civil + mechanical + electrical + undergrad + masters + phd, data = samp_df) summary(happiness_all) ## ## Call: ## lm(formula = happiness ~ min_outdoors + min_zoom + civil + mechanical + ## electrical + undergrad + masters + phd, data = samp_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -43.593 -9.372 -1.181 9.707 42.635 ## ## Coefficients: (2 not defined because of singularities) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 56.182866 3.732885 15.051 &lt; 2e-16 *** ## min_outdoors 0.041287 0.012695 3.252 0.00135 ** ## min_zoom -0.070870 0.009316 -7.608 1.2e-12 *** ## civil 7.980143 2.573519 3.101 0.00222 ** ## mechanical 1.443759 2.779511 0.519 0.60406 ## electrical NA NA NA NA ## undergrad 1.150201 2.631727 0.437 0.66256 ## masters -9.830555 2.998334 -3.279 0.00124 ** ## phd NA NA NA NA ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 15.25 on 193 degrees of freedom ## Multiple R-squared: 0.3359, Adjusted R-squared: 0.3152 ## F-statistic: 16.27 on 6 and 193 DF, p-value: 3.956e-15 An alternative way of writing the full model happiness_all &lt;- lm(happiness ~ min_outdoors + min_zoom + discipline + standing, data = samp_df) summary(happiness_all) ## ## Call: ## lm(formula = happiness ~ min_outdoors + min_zoom + discipline + ## standing, data = samp_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -43.593 -9.372 -1.181 9.707 42.635 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 54.332454 3.605520 15.069 &lt; 2e-16 *** ## min_outdoors 0.041287 0.012695 3.252 0.00135 ** ## min_zoom -0.070870 0.009316 -7.608 1.20e-12 *** ## disciplineelectrical -7.980143 2.573519 -3.101 0.00222 ** ## disciplinemechanical -6.536383 2.664130 -2.453 0.01504 * ## standingphd 9.830555 2.998334 3.279 0.00124 ** ## standingundergrad 10.980756 2.648187 4.147 5.05e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 15.25 on 193 degrees of freedom ## Multiple R-squared: 0.3359, Adjusted R-squared: 0.3152 ## F-statistic: 16.27 on 6 and 193 DF, p-value: 3.956e-15 "]]
